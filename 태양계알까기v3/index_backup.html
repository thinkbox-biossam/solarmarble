<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>솔라 시스템 마블 - 태양계 학습 게임</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #00d4ff;
            --secondary-color: #ff6b35;
            --accent-color: #ffd700;
            --dark-bg: #0a0a15;
            --darker-bg: #050508;
            --card-bg: rgba(15, 25, 45, 0.95);
            --glass-bg: rgba(255, 255, 255, 0.1);
            --text-primary: #ffffff;
            --text-secondary: #b8c6db;
            --success-color: #4caf50;
            --warning-color: #ff9800;
            --danger-color: #f44336;
            --border-glow: rgba(0, 212, 255, 0.3);
            --shadow-glow: 0 0 30px rgba(0, 212, 255, 0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--dark-bg) 0%, var(--darker-bg) 100%);
            color: var(--text-primary);
            font-family: 'Noto Sans KR', sans-serif;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(120, 219, 255, 0.3) 0%, transparent 50%);
            animation: backgroundMove 20s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes backgroundMove {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(1deg); }
        }

        #gameCanvas {
            background: transparent;
            border: 2px solid var(--border-glow);
            border-radius: 16px;
            box-shadow: var(--shadow-glow), inset 0 0 20px rgba(0, 0, 0, 0.3);
            display: block;
            transition: all 0.3s ease;
        }

        #gameCanvas:hover {
            box-shadow: 0 0 50px rgba(0, 212, 255, 0.4), inset 0 0 20px rgba(0, 0, 0, 0.3);
        }

        .ui-panel {
            background: var(--card-bg);
            backdrop-filter: blur(15px);
            border: 1px solid var(--border-glow);
            border-radius: 16px;
            padding: 20px;
            box-shadow: var(--shadow-glow);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .ui-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            animation: shimmer 2s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        .ui-panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 40px rgba(0, 212, 255, 0.3);
        }

        #draftInfoPanel {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 420px;
            min-height: 140px;
            display: none;
            z-index: 100;
            animation: slideUpIn 0.3s ease-out;
        }

        @keyframes slideUpIn {
            from { transform: translateX(-50%) translateY(20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        #draftInfoPanel h3 {
            margin: 0 0 12px 0;
            color: var(--accent-color);
            font-size: 1.2em;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        #draftInfoPanel p {
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .stat-bar-container {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.8em;
        }

        .stat-bar-label {
            width: 50px;
            margin-right: 8px;
            color: var(--text-secondary);
            font-weight: 500;
            text-align: left;
        }

        .stat-bar {
            flex-grow: 1;
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }

        .stat-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
            animation: statShimmer 2s ease-in-out infinite;
        }

        @keyframes statShimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(200%); }
        }

        .stat-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success-color), #66bb6a);
            border-radius: 5px;
            transition: width 0.5s ease-out;
            position: relative;
            overflow: hidden;
        }

        .stat-bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: fillGlow 1.5s ease-in-out infinite;
        }

        @keyframes fillGlow {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        .stat-bar-value {
            width: 40px;
            text-align: right;
            margin-left: 8px;
            color: var(--text-primary);
            font-weight: 500;
        }

        #powerBarContainer {
            position: fixed;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            width: 280px;
            height: 36px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 18px;
            border: 2px solid var(--border-glow);
            padding: 4px;
            box-shadow: var(--shadow-glow);
            display: none;
            z-index: 100;
            animation: powerBarPulse 2s ease-in-out infinite alternate;
        }

        @keyframes powerBarPulse {
            from { box-shadow: 0 0 20px rgba(0, 212, 255, 0.3); }
            to { box-shadow: 0 0 30px rgba(0, 212, 255, 0.5); }
        }

        #powerBarFill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, var(--success-color), var(--warning-color), var(--danger-color));
            border-radius: 14px;
            transition: width 0.1s linear, box-shadow 0.1s linear;
            position: relative;
            overflow: hidden;
        }

        #powerBarFill::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: powerFillMove 1s ease-in-out infinite;
        }

        @keyframes powerFillMove {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        #powerBarText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--text-primary);
            font-size: 0.9em;
            font-weight: 700;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            font-family: 'Orbitron', monospace;
        }

        .game-ui-element {
            position: fixed;
            padding: 12px 18px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid var(--border-glow);
            box-shadow: var(--shadow-glow);
            font-size: 1em;
            z-index: 90;
            transition: all 0.3s ease;
        }

        .game-ui-element:hover {
            transform: scale(1.02);
            box-shadow: 0 0 25px rgba(0, 212, 255, 0.4);
        }

        #gameMessages {
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.1em;
            font-weight: 600;
            z-index: 120;
            text-align: center;
            min-width: 200px;
            animation: messageSlide 0.5s ease-out;
        }

        @keyframes messageSlide {
            from { transform: translateX(-50%) translateY(-20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        #turnIndicator {
            top: 20px;
            left: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: var(--accent-color);
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        #aliveCount {
            top: 70px;
            left: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 500;
        }

        #instructions {
            bottom: 20px;
            right: 20px;
            font-size: 0.8em;
            color: var(--text-secondary);
            text-align: right;
            max-width: 250px;
            line-height: 1.3;
        }

        .player-picks-ui {
            position: fixed;
            padding: 8px 12px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            border: 1px solid var(--border-glow);
            font-size: 0.9em;
            display: flex;
            align-items: center;
            z-index: 90;
            box-shadow: var(--shadow-glow);
            transition: all 0.3s ease;
        }

        .player-picks-ui:hover {
            transform: scale(1.05);
        }

        .player-picks-ui img {
            width: 28px;
            height: 28px;
            margin-left: 6px;
            border-radius: 50%;
            border: 2px solid var(--border-glow);
            transition: transform 0.2s ease;
        }

        .player-picks-ui img:hover {
            transform: scale(1.1);
        }

        #p1Picks { 
            left: 20px; 
            top: 120px;
            border-color: #ff6464;
            box-shadow: 0 0 15px rgba(255, 100, 100, 0.3);
        }

        #p2Picks { 
            right: 20px; 
            top: 20px;
            border-color: #6464ff;
            box-shadow: 0 0 15px rgba(100, 100, 255, 0.3);
        }

        .button {
            padding: 14px 28px;
            background: linear-gradient(135deg, var(--primary-color), #0099cc);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            margin: 12px;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            font-family: 'Noto Sans KR', sans-serif;
        }

        .button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .button:hover {
            background: linear-gradient(135deg, #00b4d8, var(--primary-color));
            box-shadow: 0 6px 25px rgba(0, 212, 255, 0.5);
            transform: translateY(-2px);
        }

        .button:hover::before {
            left: 100%;
        }

        .button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 212, 255, 0.3);
        }

        .button.secondary {
            background: linear-gradient(135deg, var(--secondary-color), #cc5500);
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
        }

        .button.secondary:hover {
            background: linear-gradient(135deg, #ff8a65, var(--secondary-color));
            box-shadow: 0 6px 25px rgba(255, 107, 53, 0.5);
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 200;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            justify-content: center;
            align-items: center;
            animation: modalFadeIn 0.3s ease-out;
        }

        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            margin: auto;
            padding: 30px;
            border: 2px solid var(--border-glow);
            border-radius: 20px;
            width: 90%;
            max-width: 700px;
            text-align: center;
            box-shadow: 0 10px 50px rgba(0, 212, 255, 0.3);
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from { transform: scale(0.7) translateY(50px); opacity: 0; }
            to { transform: scale(1) translateY(0); opacity: 1; }
        }

        .modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            animation: shimmer 2s ease-in-out infinite;
        }

        .modal-content h2 {
            color: var(--accent-color);
            margin-top: 0;
            margin-bottom: 20px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        .modal-content p {
            margin-bottom: 16px;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .close-button {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            font-size: 1.5em;
            color: var(--text-secondary);
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-button:hover {
            color: var(--danger-color);
        }

        .planet-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            text-align: left;
            margin-top: 20px;
        }

        .planet-info-item {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .planet-info-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .planet-info-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.2);
            border-color: var(--border-glow);
        }

        .planet-info-item:hover::before {
            opacity: 1;
        }

        .planet-info-item h4 {
            margin-top: 0;
            margin-bottom: 12px;
            color: var(--accent-color);
            font-family: 'Orbitron', sans-serif;
            font-weight: 600;
        }

        .planet-info-item p {
            font-size: 0.9em;
            margin-bottom: 6px;
            color: var(--text-secondary);
        }

        .planet-info-item .planet-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            float: right;
            margin-left: 15px;
            border: 2px solid var(--border-glow);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        .fun-fact {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 107, 53, 0.1));
            padding: 12px;
            border-radius: 10px;
            margin-top: 10px;
            border-left: 4px solid var(--accent-color);
            font-style: italic;
            color: var(--text-primary);
        }

        #startScreen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 150;
            width: 90%;
            max-width: 650px;
            text-align: center;
        }

        #startScreen h1 {
            color: var(--accent-color);
            font-size: 2.5em;
            margin-bottom: 15px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            animation: titleGlow 3s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            from { text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
            to { text-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
        }

        #startScreen p {
            color: var(--text-secondary);
            font-size: 1.1em;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        #modeSelectContainer {
            margin: 20px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            font-size: 1.1em;
            color: var(--text-primary);
            font-weight: 500;
        }

        #modeSelect {
            padding: 12px 16px;
            border-radius: 10px;
            border: 2px solid var(--border-glow);
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            color: var(--text-primary);
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Noto Sans KR', sans-serif;
        }

        #modeSelect:hover {
            border-color: var(--primary-color);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        #modeSelect option {
            background: var(--card-bg);
            color: var(--text-primary);
        }

        #modeDescription {
            margin: 15px 0 25px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.95em;
            color: var(--text-secondary);
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.4;
        }

        .tutorial-section {
            background: rgba(255, 255, 255, 0.03);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 4px solid var(--primary-color);
        }

        .tutorial-section h3 {
            color: var(--primary-color);
            margin-bottom: 12px;
            font-family: 'Orbitron', sans-serif;
        }

        .tutorial-step {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .tutorial-step-number {
            background: var(--primary-color);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 12px;
            font-size: 0.8em;
        }

        .comparison-chart {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .chart-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chart-item h5 {
            color: var(--accent-color);
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .chart-bar {
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 5px 0;
        }

        .chart-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            border-radius: 10px;
            transition: width 1s ease-out;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            #startScreen h1 { font-size: 2em; }
            .modal-content { padding: 20px; max-height: 80vh; }
            .planet-info-grid { grid-template-columns: 1fr; gap: 15px; }
            .game-ui-element { padding: 8px 12px; font-size: 0.9em; }
            #powerBarContainer { width: 220px; height: 32px; }
            #draftInfoPanel { max-width: 350px; bottom: 20px; }
            .comparison-chart { grid-template-columns: 1fr; }
            .tutorial-step { flex-direction: column; text-align: center; }
            .tutorial-step-number { margin: 0 0 8px 0; }
        }

        @media (max-width: 480px) {
            #startScreen h1 { font-size: 1.6em; }
            .modal-content { padding: 15px; }
            .button { padding: 10px 20px; font-size: 0.9em; }
            .game-ui-element { padding: 6px 10px; font-size: 0.8em; }
            #powerBarContainer { width: 180px; height: 28px; }
            .player-picks-ui img { width: 24px; height: 24px; }
        }

        /* Loading Animation */
        .loading-spinner {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #00b4d8;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="turnIndicator" class="game-ui-element" style="display: none;">
        <i class="fas fa-user"></i> P1의 턴
    </div>
    
    <div id="aliveCount" class="game-ui-element" style="display: none;">
        <i class="fas fa-chart-bar"></i> P1: 3 | P2: 3
    </div>
    
    <div id="instructions" class="game-ui-element" style="display: none;">
        <i class="fas fa-info-circle"></i> 행성 클릭 후 반대방향으로 드래그<br>
        <i class="fas fa-keyboard"></i> SPACE: 최대 파워 | R: 재시작<br>
        <i class="fas fa-question-circle"></i> H: 도움말
    </div>

    <div id="draftInfoPanel" class="ui-panel">
        <h3 id="draftPlanetName">
            <i class="fas fa-globe"></i> 행성 이름
        </h3>
        <p id="draftPlanetDesc">행성 설명이 여기에 표시됩니다.</p>
        <div class="stat-bar-container">
            <span class="stat-bar-label">크기:</span>
            <div class="stat-bar">
                <div id="draftStatSize" class="stat-bar-fill"></div>
            </div>
            <span id="draftStatSizeValue" class="stat-bar-value">0</span>
        }
        <div class="stat-bar-container">
            <span class="stat-bar-label">밀도:</span>
            <div class="stat-bar">
                <div id="draftStatDensity" class="stat-bar-fill" style="background: linear-gradient(90deg, #8A2BE2, #9932CC);"></div>
            </div>
            <span id="draftStatDensityValue" class="stat-bar-value">0</span>
        }
        <div class="stat-bar-container">
            <span class="stat-bar-label">중력:</span>
            <div class="stat-bar">
                <div id="draftStatGravity" class="stat-bar-fill" style="background: linear-gradient(90deg, #00BFFF, #1E90FF);"></div>
            </div>
            <span id="draftStatGravityValue" class="stat-bar-value">0</span>
        }
    }

    <div id="powerBarContainer">
        <div id="powerBarFill"></div>
        <div id="powerBarText">
            <i class="fas fa-bolt"></i> 파워: 0%
        }
    }

    <div id="gameMessages" class="game-ui-element" style="display: none;">
        <i class="fas fa-comment"></i> 게임 메시지
    }

    <div id="p1Picks" class="player-picks-ui" style="display:none;">
        <i class="fas fa-user" style="color: #ff6464;"></i> P1 선택:
    }
    
    <div id="p2Picks" class="player-picks-ui" style="display:none;">
        <i class="fas fa-user" style="color: #6464ff;"></i> P2 선택:
    }
    
    <!-- Game End Modal -->
    <div id="endGameModal" class="modal">
        <div class="modal-content">
            <button class="close-button" onclick="document.getElementById('endGameModal').style.display='none'">
                <i class="fas fa-times"></i>
            }
            <h2 id="winnerMessage">
                <i class="fas fa-trophy"></i> 승리 메시지
            }
            <p id="congratsMessage">축하 메시지</p>
            <button id="restartButton" class="button">
                <i class="fas fa-redo"></i> 다시 플레이 (R)
            }
        }
    }

    <!-- Tutorial Modal -->
    <div id="tutorialModal" class="modal">
        <div class="modal-content">
            <button class="close-button" onclick="document.getElementById('tutorialModal').style.display='none'">
                <i class="fas fa-times"></i>
            }
            <h2><i class="fas fa-graduation-cap"></i> 게임 설명서</h2>
            
            <div class="tutorial-section">
                <h3><i class="fas fa-gamepad"></i> 게임 목표</h3>
                <p>태양계의 행성들을 이용해 상대방의 행성을 모두 맵 밖으로 밀어내거나, 컬링 모드에서 높은 점수를 획득하세요!</p>
            }

            <div class="tutorial-section">
                <h3><i class="fas fa-mouse"></i> 조작 방법</h3>
                <div class="tutorial-step">
                    <div class="tutorial-step-number">1</div>
                    <div>자신의 행성을 마우스로 클릭하여 선택</div>
                }
                <div class="tutorial-step">
                    <div class="tutorial-step-number">2</div>
                    <div>발사하고 싶은 반대 방향으로 드래그</div>
                }
                <div class="tutorial-step">
                    <div class="tutorial-step-number">3</div>
                    <div>마우스를 놓아서 행성 발사</div>
                }
                <div class="tutorial-step">
                    <div class="tutorial-step-number">4</div>
                    <div>SPACE 키로 최대 파워 설정 가능</div>
                }
            }

            <div class="tutorial-section">
                <h3><i class="fas fa-star"></i> 게임 모드</h3>
                <p><strong>알까기 모드:</strong> 상대방의 모든 행성을 맵 밖으로 밀어내면 승리</p>
                <p><strong>컬링 모드:</strong> 3라운드 동안 중앙 원에 가까이 행성을 위치시켜 점수 획득</p>
            }

            <div class="tutorial-section">
                <h3><i class="fas fa-lightbulb"></i> 전략 팁</h3>
                <p>• 큰 행성은 무겁고 강력하지만 움직이기 어려움</p>
                <p>• 작은 행성은 빠르게 움직이지만 충돌시 밀려남</p>
                <p>• 중력을 이용해 궤도를 활용하세요</p>
                <p>• 태양의 강한 중력을 전략적으로 활용</p>
            }

            <button class="button" onclick="document.getElementById('tutorialModal').style.display='none'">
                <i class="fas fa-check"></i> 이해했습니다
            }
        }
    }

    <!-- Planet Info Modal -->
    <div id="planetInfoModal" class="modal">
        <div class="modal-content">
            <button class="close-button" onclick="document.getElementById('planetInfoModal').style.display='none'">
                <i class="fas fa-times"></i>
            }
            <h2><i class="fas fa-globe-americas"></i> 태양계 행성 학습</h2>
            
            <div class="comparison-chart">
                <div class="chart-item">
                    <h5>크기 비교 (지구=1)</h5>
                    <div class="chart-bar">
                        <div class="chart-fill" style="width: 100%;" data-planet="earth"></div>
                    }
                    <small>지구 기준</small>
                }
                <div class="chart-item">
                    <h5>거리 비교 (AU)</h5>
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>솔라 시스템 마블 - 태양계 학습 게임</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #00d4ff;
            --secondary-color: #ff6b35;
            --accent-color: #ffd700;
            --dark-bg: #0a0a15;
            --darker-bg: #050508;
            --card-bg: rgba(15, 25, 45, 0.95);
            --glass-bg: rgba(255, 255, 255, 0.1);
            --text-primary: #ffffff;
            --text-secondary: #b8c6db;
            --success-color: #4caf50;
            --warning-color: #ff9800;
            --danger-color: #f44336;
            --border-glow: rgba(0, 212, 255, 0.3);
            --shadow-glow: 0 0 30px rgba(0, 212, 255, 0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--dark-bg) 0%, var(--darker-bg) 100%);
            color: var(--text-primary);
            font-family: 'Noto Sans KR', sans-serif;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(120, 219, 255, 0.3) 0%, transparent 50%);
            animation: backgroundMove 20s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes backgroundMove {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(1deg); }
        }

        #gameCanvas {
            background: transparent;
            border: 2px solid var(--border-glow);
            border-radius: 16px;
            box-shadow: var(--shadow-glow), inset 0 0 20px rgba(0, 0, 0, 0.3);
            display: block;
            transition: all 0.3s ease;
        }

        #gameCanvas:hover {
            box-shadow: 0 0 50px rgba(0, 212, 255, 0.4), inset 0 0 20px rgba(0, 0, 0, 0.3);
        }

        .ui-panel {
            background: var(--card-bg);
            backdrop-filter: blur(15px);
            border: 1px solid var(--border-glow);
            border-radius: 16px;
            padding: 20px;
            box-shadow: var(--shadow-glow);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .ui-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            animation: shimmer 2s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        .ui-panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 40px rgba(0, 212, 255, 0.3);
        }

        #draftInfoPanel {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 420px;
            min-height: 140px;
            display: none;
            z-index: 100;
            animation: slideUpIn 0.3s ease-out;
        }

        @keyframes slideUpIn {
            from { transform: translateX(-50%) translateY(20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        #draftInfoPanel h3 {
            margin: 0 0 12px 0;
            color: var(--accent-color);
            font-size: 1.2em;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        #draftInfoPanel p {
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .stat-bar-container {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.8em;
        }

        .stat-bar-label {
            width: 50px;
            margin-right: 8px;
            color: var(--text-secondary);
            font-weight: 500;
            text-align: left;
        }

        .stat-bar {
            flex-grow: 1;
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }

        .stat-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
            animation: statShimmer 2s ease-in-out infinite;
        }

        @keyframes statShimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(200%); }
        }

        .stat-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success-color), #66bb6a);
            border-radius: 5px;
            transition: width 0.5s ease-out;
            position: relative;
            overflow: hidden;
        }

        .stat-bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: fillGlow 1.5s ease-in-out infinite;
        }

        @keyframes fillGlow {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        .stat-bar-value {
            width: 40px;
            text-align: right;
            margin-left: 8px;
            color: var(--text-primary);
            font-weight: 500;
        }

        #powerBarContainer {
            position: fixed;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            width: 280px;
            height: 36px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 18px;
            border: 2px solid var(--border-glow);
            padding: 4px;
            box-shadow: var(--shadow-glow);
            display: none;
            z-index: 100;
            animation: powerBarPulse 2s ease-in-out infinite alternate;
        }

        @keyframes powerBarPulse {
            from { box-shadow: 0 0 20px rgba(0, 212, 255, 0.3); }
            to { box-shadow: 0 0 30px rgba(0, 212, 255, 0.5); }
        }

        #powerBarFill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, var(--success-color), var(--warning-color), var(--danger-color));
            border-radius: 14px;
            transition: width 0.1s linear, box-shadow 0.1s linear;
            position: relative;
            overflow: hidden;
        }

        #powerBarFill::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: powerFillMove 1s ease-in-out infinite;
        }

        @keyframes powerFillMove {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        #powerBarText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--text-primary);
            font-size: 0.9em;
            font-weight: 700;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            font-family: 'Orbitron', monospace;
        }

        .game-ui-element {
            position: fixed;
            padding: 12px 18px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid var(--border-glow);
            box-shadow: var(--shadow-glow);
            font-size: 1em;
            z-index: 90;
            transition: all 0.3s ease;
        }

        .game-ui-element:hover {
            transform: scale(1.02);
            box-shadow: 0 0 25px rgba(0, 212, 255, 0.4);
        }

        #gameMessages {
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.1em;
            font-weight: 600;
            z-index: 120;
            text-align: center;
            min-width: 200px;
            animation: messageSlide 0.5s ease-out;
        }

        @keyframes messageSlide {
            from { transform: translateX(-50%) translateY(-20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        #turnIndicator {
            top: 20px;
            left: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: var(--accent-color);
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        #aliveCount {
            top: 70px;
            left: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 500;
        }

        #instructions {
            bottom: 20px;
            right: 20px;
            font-size: 0.8em;
            color: var(--text-secondary);
            text-align: right;
            max-width: 250px;
            line-height: 1.3;
        }

        .player-picks-ui {
            position: fixed;
            padding: 8px 12px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            border: 1px solid var(--border-glow);
            font-size: 0.9em;
            display: flex;
            align-items: center;
            z-index: 90;
            box-shadow: var(--shadow-glow);
            transition: all 0.3s ease;
        }

        .player-picks-ui:hover {
            transform: scale(1.05);
        }

        .player-picks-ui img {
            width: 28px;
            height: 28px;
            margin-left: 6px;
            border-radius: 50%;
            border: 2px solid var(--border-glow);
            transition: transform 0.2s ease;
        }

        .player-picks-ui img:hover {
            transform: scale(1.1);
        }

        #p1Picks { 
            left: 20px; 
            top: 120px;
            border-color: #ff6464;
            box-shadow: 0 0 15px rgba(255, 100, 100, 0.3);
        }

        #p2Picks { 
            right: 20px; 
            top: 20px;
            border-color: #6464ff;
            box-shadow: 0 0 15px rgba(100, 100, 255, 0.3);
        }

        .button {
            padding: 14px 28px;
            background: linear-gradient(135deg, var(--primary-color), #0099cc);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            margin: 12px;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            font-family: 'Noto Sans KR', sans-serif;
        }

        .button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .button:hover {
            background: linear-gradient(135deg, #00b4d8, var(--primary-color));
            box-shadow: 0 6px 25px rgba(0, 212, 255, 0.5);
            transform: translateY(-2px);
        }

        .button:hover::before {
            left: 100%;
        }

        .button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 212, 255, 0.3);
        }

        .button.secondary {
            background: linear-gradient(135deg, var(--secondary-color), #cc5500);
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
        }

        .button.secondary:hover {
            background: linear-gradient(135deg, #ff8a65, var(--secondary-color));
            box-shadow: 0 6px 25px rgba(255, 107, 53, 0.5);
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 200;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            justify-content: center;
            align-items: center;
            animation: modalFadeIn 0.3s ease-out;
        }

        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            margin: auto;
            padding: 30px;
            border: 2px solid var(--border-glow);
            border-radius: 20px;
            width: 90%;
            max-width: 700px;
            text-align: center;
            box-shadow: 0 10px 50px rgba(0, 212, 255, 0.3);
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from { transform: scale(0.7) translateY(50px); opacity: 0; }
            to { transform: scale(1) translateY(0); opacity: 1; }
        }

        .modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            animation: shimmer 2s ease-in-out infinite;
        }

        .modal-content h2 {
            color: var(--accent-color);
            margin-top: 0;
            margin-bottom: 20px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        .modal-content p {
            margin-bottom: 16px;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .close-button {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            font-size: 1.5em;
            color: var(--text-secondary);
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-button:hover {
            color: var(--danger-color);
        }

        .planet-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            text-align: left;
            margin-top: 20px;
        }

        .planet-info-item {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .planet-info-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .planet-info-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.2);
            border-color: var(--border-glow);
        }

        .planet-info-item:hover::before {
            opacity: 1;
        }

        .planet-info-item h4 {
            margin-top: 0;
            margin-bottom: 12px;
            color: var(--accent-color);
            font-family: 'Orbitron', sans-serif;
            font-weight: 600;
        }

        .planet-info-item p {
            font-size: 0.9em;
            margin-bottom: 6px;
            color: var(--text-secondary);
        }

        .planet-info-item .planet-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            float: right;
            margin-left: 15px;
            border: 2px solid var(--border-glow);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        .fun-fact {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 107, 53, 0.1));
            padding: 12px;
            border-radius: 10px;
            margin-top: 10px;
            border-left: 4px solid var(--accent-color);
            font-style: italic;
            color: var(--text-primary);
        }

        #startScreen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 150;
            width: 90%;
            max-width: 650px;
            text-align: center;
        }

        #startScreen h1 {
            color: var(--accent-color);
            font-size: 2.5em;
            margin-bottom: 15px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            animation: titleGlow 3s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            from { text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
            to { text-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
        }

        #startScreen p {
            color: var(--text-secondary);
            font-size: 1.1em;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        #modeSelectContainer {
            margin: 20px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            font-size: 1.1em;
            color: var(--text-primary);
            font-weight: 500;
        }

        #modeSelect {
            padding: 12px 16px;
            border-radius: 10px;
            border: 2px solid var(--border-glow);
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            color: var(--text-primary);
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Noto Sans KR', sans-serif;
        }

        #modeSelect:hover {
            border-color: var(--primary-color);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        #modeSelect option {
            background: var(--card-bg);
            color: var(--text-primary);
        }

        #modeDescription {
            margin: 15px 0 25px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.95em;
            color: var(--text-secondary);
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.4;
        }

        .tutorial-section {
            background: rgba(255, 255, 255, 0.03);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 4px solid var(--primary-color);
        }

        .tutorial-section h3 {
            color: var(--primary-color);
            margin-bottom: 12px;
            font-family: 'Orbitron', sans-serif;
        }

        .tutorial-step {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .tutorial-step-number {
            background: var(--primary-color);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 12px;
            font-size: 0.8em;
        }

        .comparison-chart {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .chart-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chart-item h5 {
            color: var(--accent-color);
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .chart-bar {
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 5px 0;
        }

        .chart-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            border-radius: 10px;
            transition: width 1s ease-out;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            #startScreen h1 { font-size: 2em; }
            .modal-content { padding: 20px; max-height: 80vh; }
            .planet-info-grid { grid-template-columns: 1fr; gap: 15px; }
            .game-ui-element { padding: 8px 12px; font-size: 0.9em; }
            #powerBarContainer { width: 220px; height: 32px; }
            #draftInfoPanel { max-width: 350px; bottom: 20px; }
            .comparison-chart { grid-template-columns: 1fr; }
            .tutorial-step { flex-direction: column; text-align: center; }
            .tutorial-step-number { margin: 0 0 8px 0; }
        }

        @media (max-width: 480px) {
            #startScreen h1 { font-size: 1.6em; }
            .modal-content { padding: 15px; }
            .button { padding: 10px 20px; font-size: 0.9em; }
            .game-ui-element { padding: 6px 10px; font-size: 0.8em; }
            #powerBarContainer { width: 180px; height: 28px; }
            .player-picks-ui img { width: 24px; height: 24px; }
        }

        /* Loading Animation */
        .loading-spinner {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #00b4d8;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="turnIndicator" class="game-ui-element" style="display: none;">
        <i class="fas fa-user"></i> P1의 턴
    </div>
    
    <div id="aliveCount" class="game-ui-element" style="display: none;">
        <i class="fas fa-chart-bar"></i> P1: 3 | P2: 3
    </div>
    
    <div id="instructions" class="game-ui-element" style="display: none;">
        <i class="fas fa-info-circle"></i> 행성 클릭 후 반대방향으로 드래그<br>
        <i class="fas fa-keyboard"></i> SPACE: 최대 파워 | R: 재시작<br>
        <i class="fas fa-question-circle"></i> H: 도움말
    </div>

    <div id="draftInfoPanel" class="ui-panel">
        <h3 id="draftPlanetName">
            <i class="fas fa-globe"></i> 행성 이름
        </h3>
        <p id="draftPlanetDesc">행성 설명이 여기에 표시됩니다.</p>
        <div class="stat-bar-container">
            <span class="stat-bar-label">크기:</span>
            <div class="stat-bar">
                <div id="draftStatSize" class="stat-bar-fill"></div>
            </div>
            <span id="draftStatSizeValue" class="stat-bar-value">0</span>
        </div>
        <div class="stat-bar-container">
            <span class="stat-bar-label">밀도:</span>
            <div class="stat-bar">
                <div id="draftStatDensity" class="stat-bar-fill" style="background: linear-gradient(90deg, #8A2BE2, #9932CC);"></div>
            </div>
            <span id="draftStatDensityValue" class="stat-bar-value">0</span>
        </div>
        <div class="stat-bar-container">
            <span class="stat-bar-label">중력:</span>
            <div class="stat-bar">
                <div id="draftStatGravity" class="stat-bar-fill" style="background: linear-gradient(90deg, #00BFFF, #1E90FF);"></div>
            </div>
            <span id="draftStatGravityValue" class="stat-bar-value">0</span>
        </div>
    </div>

    <div id="powerBarContainer">
        <div id="powerBarFill"></div>
        <div id="powerBarText">
            <i class="fas fa-bolt"></i> 파워: 0%
        </div>
    </div>

    <div id="gameMessages" class="game-ui-element" style="display: none;">
        <i class="fas fa-comment"></i> 게임 메시지
    </div>

    <div id="p1Picks" class="player-picks-ui" style="display:none;">
        <i class="fas fa-user" style="color: #ff6464;"></i> P1 선택:
    </div>
    
    <div id="p2Picks" class="player-picks-ui" style="display:none;">
        <i class="fas fa-user" style="color: #6464ff;"></i> P2 선택:
    </div>
    
    <!-- Game End Modal -->
    <div id="endGameModal" class="modal">
        <div class="modal-content">
            <button class="close-button" onclick="document.getElementById('endGameModal').style.display='none'">
                <i class="fas fa-times"></i>
            </button>
            <h2 id="winnerMessage">
                <i class="fas fa-trophy"></i> 승리 메시지
            </h2>
            <p id="congratsMessage">축하 메시지</p>
            <button id="restartButton" class="button">
                <i class="fas fa-redo"></i> 다시 플레이 (R)
            </button>
        </div>
    </div>

    <!-- Tutorial Modal -->
    <div id="tutorialModal" class="modal">
        <div class="modal-content">
            <button class="close-button" onclick="document.getElementById('tutorialModal').style.display='none'">
                <i class="fas fa-times"></i>
            </button>
            <h2><i class="fas fa-graduation-cap"></i> 게임 설명서</h2>
            
            <div class="tutorial-section">
                <h3><i class="fas fa-gamepad"></i> 게임 목표</h3>
                <p>태양계의 행성들을 이용해 상대방의 행성을 모두 맵 밖으로 밀어내거나, 컬링 모드에서 높은 점수를 획득하세요!</p>
            </div>

            <div class="tutorial-section">
                <h3><i class="fas fa-mouse"></i> 조작 방법</h3>
                <div class="tutorial-step">
                    <div class="tutorial-step-number">1</div>
                    <div>자신의 행성을 마우스로 클릭하여 선택</div>
                </div>
                <div class="tutorial-step">
                    <div class="tutorial-step-number">2</div>
                    <div>발사하고 싶은 반대 방향으로 드래그</div>
                </div>
                <div class="tutorial-step">
                    <div class="tutorial-step-number">3</div>
                    <div>마우스를 놓아서 행성 발사</div>
                </div>
                <div class="tutorial-step">
                    <div class="tutorial-step-number">4</div>
                    <div>SPACE 키로 최대 파워 설정 가능</div>
                </div>
            </div>

            <div class="tutorial-section">
                <h3><i class="fas fa-star"></i> 게임 모드</h3>
                <p><strong>알까기 모드:</strong> 상대방의 모든 행성을 맵 밖으로 밀어내면 승리</p>
                <p><strong>컬링 모드:</strong> 3라운드 동안 중앙 원에 가까이 행성을 위치시켜 점수 획득</p>
            </div>

            <div class="tutorial-section">
                <h3><i class="fas fa-lightbulb"></i> 전략 팁</h3>
                <p>• 큰 행성은 무겁고 강력하지만 움직이기 어려움</p>
                <p>• 작은 행성은 빠르게 움직이지만 충돌시 밀려남</p>
                <p>• 중력을 이용해 궤도를 활용하세요</p>
                <p>• 태양의 강한 중력을 전략적으로 활용</p>
            </div>

            <button class="button" onclick="document.getElementById('tutorialModal').style.display='none'">
                <i class="fas fa-check"></i> 이해했습니다
            </button>
        </div>
    </div>

    <!-- Planet Info Modal -->
    <div id="planetInfoModal" class="modal">
        <div class="modal-content">
            <button class="close-button" onclick="document.getElementById('planetInfoModal').style.display='none'">
                <i class="fas fa-times"></i>
            </button>
            <h2><i class="fas fa-globe-americas"></i> 태양계 행성 학습</h2>
            
            <div class="comparison-chart">
                <div class="chart-item">
                    <h5>크기 비교 (지구=1)</h5>
                    <div class="chart-bar">
                        <div class="chart-fill" style="width: 100%;" data-planet="earth"></div>
                    </div>
                    <small>지구 기준</small>
                </div>
                <div class="chart-item">
                    <h5>거리 비교 (AU)</h5>
                    <div class="chart-bar">
                        <div class="chart-fill" style="width: 100%;" data-planet="distance"></div>
                    </div>
                    <small>태양으로부터</small>
                </div>
            </div>

            <div id="planetInfoGrid" class="planet-info-grid"></div>
            
            <button id="closePlanetInfoBtn" class="button">
                <i class="fas fa-arrow-left"></i> 돌아가기
            </button>
        </div>
    </div>

    <!-- Quiz Modal -->
    <div id="quizModal" class="modal">
        <div class="modal-content">
            <button class="close-button" onclick="document.getElementById('quizModal').style.display='none'">
                <i class="fas fa-times"></i>
            </button>
            <h2><i class="fas fa-brain"></i> 태양계 퀴즈</h2>
            <div id="quizContent">
                <div id="quizQuestion"></div>
                <div id="quizOptions"></div>
                <div id="quizResult" style="display: none;"></div>
                <div id="quizScore">점수: <span id="currentScore">0</span> / <span id="totalQuestions">0</span></div>
                <button id="nextQuizBtn" class="button" style="display: none;" onclick="nextQuiz()">
                    <i class="fas fa-arrow-right"></i> 다음 문제
                </button>
                <button id="startQuizBtn" class="button" onclick="startQuiz()">
                    <i class="fas fa-play"></i> 퀴즈 시작
                </button>
            </div>
        </div>
    </div>

    <!-- Debug Panel -->
    <div id="debugPanel" style="display: none; position: fixed; top: 10px; right: 300px; background: rgba(0,0,0,0.8); color: white; padding: 10px; border-radius: 8px; font-family: monospace; font-size: 12px; z-index: 200; max-width: 250px;">
        <h4 style="margin: 0 0 8px 0; color: #00ff00;">🔧 디버그 모드</h4>
        <div id="debugInfo"></div>
        <button onclick="toggleDebugMode()" style="margin-top: 8px; padding: 4px 8px; background: #333; color: white; border: 1px solid #666; border-radius: 4px; cursor: pointer;">
            디버그 모드 끄기
        </button>
    </div>

    <!-- Learning Progress Tracker -->
    <div id="learningProgress" style="display: none; position: fixed; top: 20px; right: 20px; background: var(--card-bg); backdrop-filter: blur(15px); border: 1px solid var(--border-glow); border-radius: 12px; padding: 15px; color: white; z-index: 150; max-width: 250px;">
        <h4 style="margin: 0 0 10px 0; color: var(--accent-color);">📚 학습 진행도</h4>
        <div id="progressBars"></div>
        <div style="margin-top: 10px; font-size: 12px; color: var(--text-secondary);">
            총 플레이 시간: <span id="totalPlayTime">0분</span>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="ui-panel">
        <h1><i class="fas fa-rocket"></i> 태양계 알까기</h1>
        <p>우주를 배경으로 펼쳐지는 전략 시뮬레이션 게임!<br>
        실제 태양계 행성들의 물리 법칙을 체험하며 전략적 사고력을 기르세요.</p>
        
        <div id="modeSelectContainer">
            <label for="modeSelect">
                <i class="fas fa-cog"></i> 게임 모드:
            </label>
            <select id="modeSelect">
                <option value="alggagi" selected>🎯 알까기 모드</option>
                <option value="culling">🥌 컬링 모드</option>
            </select>
        </div>
        
        <div id="modeDescription">
            행성들을 이용해 상대방의 행성을 모두 맵 밖으로 밀어내세요.
        </div>
        
        <button id="startGameBtn" class="button">
            <i class="fas fa-play"></i> 게임 시작
        </button>
        
        <button id="learnPlanetsBtn" class="button secondary">
            <i class="fas fa-book"></i> 행성 학습
        </button>
        
        <button id="tutorialBtn" class="button secondary">
            <i class="fas fa-question-circle"></i> 게임 설명
        </button>
        
        <button id="quizBtn" class="button secondary">
            <i class="fas fa-brain"></i> 태양계 퀴즈
        </button>
        
        <button id="debugModeBtn" class="button secondary" style="font-size: 0.8em;">
            <i class="fas fa-bug"></i> 디버그 모드
        </button>
    </div>

    <script type="module">
        // Enhanced Solar System Educational Game
        // Improved with modern UI/UX, debugging, and educational content

        // --- Constants and Global Variables ---
        let canvas, ctx;
        let spaceBackground;
        let currentGameState = null;
        let gameRunningState = "menu";
        let isDragging = false;
        let dragJustStarted = false;
        let selectedPlanet = null;
        let startDragPos = { x: 0, y: 0 };
        let trajectoryPoints = [];
        let lastTime = 0;
        let powerAmount = 0;
        let isGameOver = false;
        let gameLoop = null;
        let draftState = null;
        let draftHandleClick = null;
        let draftHandleMouseMove = null;
        let draftHandleKeyDown = null;
        const pickedPlanets = { P1: [], P2: [] };
        let npcPlanets = [];
        let uiInstructions;
        let debugMode = false;

        // --- Educational Quiz System ---
        const quizQuestions = [
            {
                question: "태양계에서 가장 큰 행성은 무엇인가요?",
                options: ["지구", "목성", "토성", "해왕성"],
                correct: 1,
                explanation: "목성은 태양계에서 가장 큰 행성으로, 지구보다 11배나 큽니다!",
                category: "크기"
            },
            {
                question: "태양에서 가장 가까운 행성은?",
                options: ["금성", "수성", "지구", "화성"],
                correct: 1,
                explanation: "수성은 태양에서 가장 가까운 행성입니다. 하지만 금성이 더 뜨거워요!",
                category: "거리"
            },
            {
                question: "어떤 행성이 거꾸로 자전하나요?",
                options: ["지구", "화성", "금성", "목성"],
                correct: 2,
                explanation: "금성은 다른 행성들과 반대 방향으로 자전합니다. 태양이 서쪽에서 떠요!",
                category: "운동"
            },
            {
                question: "토성의 가장 특별한 특징은?",
                options: ["가장 크다", "아름다운 고리", "가장 빠르다", "가장 뜨겁다"],
                correct: 1,
                explanation: "토성은 아름다운 고리로 유명합니다. 수십억 개의 얼음과 바위 조각으로 이루어져 있어요!",
                category: "특징"
            },
            {
                question: "지구의 자전축은 몇 도 기울어져 있나요?",
                options: ["0도", "23.4도", "45도", "90도"],
                correct: 1,
                explanation: "지구의 자전축은 23.4도 기울어져 있어서 계절이 생깁니다!",
                category: "지구"
            }
        ];

        let currentQuiz = {
            questions: [],
            currentIndex: 0,
            score: 0,
            categories: {}
        };

        // --- Learning Progress Tracking ---
        let learningProgress = {
            startTime: null,
            totalPlayTime: 0,
            planetsLearned: new Set(),
            quizzesTaken: 0,
            correctAnswers: 0,
            gamesPlayed: 0,
            strategiesUsed: new Set()
        };

        // --- Enhanced Educational Planet Data ---
        const planets_data_template = [
            {
                "name": "태양", "color": '#FFFF00', "size": 60, "mass": 150, "id": "sun",
                "texture_colors": { base: '#FFD700', corona: ['#FFFACD', '#FFE4B5', '#FFDEAD'], spots: ['#FFA500', '#FF8C00']},
                "desc": "태양계의 중심에 있는 항성으로, 모든 행성들이 태양 주위를 공전합니다.",
                "type": "star", axialTiltDeg: 7.25, orbitalPeriod: 0, density: 1.41, surfaceGravity: 27.9, rotationPeriod: 0.0001,
                "distanceFromSun": 0, "temperature": 5778, "moons": 0,
                "funFact": "태양은 매초 400만 톤의 질량을 에너지로 변환합니다! 이는 핵융합 반응 때문입니다.",
                "educationalNote": "태양의 중력은 지구보다 28배나 강해서, 만약 태양에 떨어진다면 엄청난 속도로 가속됩니다.",
                "gameStrategy": "태양의 강력한 중력을 이용해 행성의 궤도를 바꿀 수 있습니다. 태양 근처로 행성을 보내면 중력 가속을 받아 더 빠르게 움직입니다."
            },
            {
                "name": "수성", "color": '#A9A9A9', "size": 10, "mass": 0.06, "id": "mercury",
                "texture_colors": { base: '#808080', craters_dark: '#606060', craters_light: '#A0A0A0'},
                "desc": "태양에 가장 가까운 행성으로 작고 빠르며, 표면은 크레이터로 가득합니다.",
                "type": "rocky_cratered", axialTiltDeg: 0.03, orbitalPeriod: 88, density: 5.43, surfaceGravity: 0.38, rotationPeriod: 0.005,
                "distanceFromSun": 0.39, "temperature": 167, "moons": 0,
                "funFact": "수성의 하루는 지구의 176일과 같습니다! 자전이 매우 느리기 때문입니다.",
                "educationalNote": "수성은 밀도가 높아서 작지만 무겁습니다. 이는 큰 철 핵을 가지고 있기 때문입니다.",
                "gameStrategy": "수성은 작지만 밀도가 높아 의외로 무겁습니다. 다른 행성을 밀어낼 때 생각보다 큰 힘을 발휘할 수 있어요."
            },
            {
                "name": "금성", "color": '#F5DEB3', "size": 20, "mass": 0.82, "id": "venus",
                "texture_colors": { base: '#EEDC82', clouds: ['#FFF8DC', '#FAF0E6', '#FFEBCD']},
                "desc": "두꺼운 황산 구름으로 덮여 있으며, 온실효과로 인해 태양계에서 가장 뜨거운 행성입니다.",
                "type": "rocky_cloudy", axialTiltDeg: 177.4, orbitalPeriod: 225, density: 5.24, surfaceGravity: 0.90, rotationPeriod: 0.01,
                "distanceFromSun": 0.72, "temperature": 464, "moons": 0,
                "funFact": "금성은 거꾸로 자전합니다! 태양이 서쪽에서 뜨고 동쪽으로 집니다.",
                "educationalNote": "금성의 대기압은 지구의 90배나 됩니다. 마치 깊은 바다 밑에 있는 것과 같죠!",
                "gameStrategy": "금성은 크기와 질량이 지구와 비슷해 균형 잡힌 플레이가 가능합니다. 공격과 수비 모두에 적합해요."
            },
            {
                "name": "지구", "color": '#6495ED', "size": 22, "mass": 1.0, "id": "earth",
                "texture_colors": { ocean: '#4682B4', land: ['#228B22', '#8FBC8F', '#D2B48C'], cloud: 'rgba(240,248,255,0.7)'},
                "desc": "우리가 살고 있는 행성으로, 액체 상태의 물과 생명체가 존재하는 유일한 행성입니다.",
                "type": "earth-like", axialTiltDeg: 23.44, orbitalPeriod: 365, density: 5.51, surfaceGravity: 1.00, rotationPeriod: 0.003,
                "distanceFromSun": 1.0, "temperature": 15, "moons": 1,
                "funFact": "지구는 초속 30km로 태양 주위를 돌고 있습니다. 1년 동안 9억 4천만 km를 여행해요!",
                "educationalNote": "지구의 자전축이 23.4도 기울어져 있어서 계절이 생깁니다.",
                "gameStrategy": "지구는 게임의 기준이 되는 행성입니다. 모든 스탯이 표준적이어서 초보자가 사용하기 좋아요."
            },
            {
                "name": "화성", "color": '#CD5C5C', "size": 15, "mass": 0.11, "id": "mars",
                "texture_colors": { base: '#BC8F8F', dust: ['#D2B48C', '#CD853F'], ice_caps: '#FFFFFF', craters: '#A0522D'},
                "desc": "붉은 행성이라 불리며, 극지방에 얼음이 있고 과거에 물이 흘렀던 흔적이 발견됩니다.",
                "type": "rocky_ice_caps", axialTiltDeg: 25.19, orbitalPeriod: 687, density: 3.93, surfaceGravity: 0.38, rotationPeriod: 0.0031,
                "distanceFromSun": 1.52, "temperature": -65, "moons": 2,
                "funFact": "화성의 하루는 지구와 거의 같아요! 24시간 37분입니다.",
                "educationalNote": "화성에서는 먼지 폭풍이 행성 전체를 덮을 수 있습니다. 몇 달 동안 지속되기도 해요!",
                "gameStrategy": "화성은 작고 가벼워서 빠르게 움직일 수 있습니다. 기습 공격이나 정밀한 조준에 적합해요."
            },
            {
                "name": "목성", "color": '#DEB887', "size": 45, "mass": 318, "id": "jupiter",
                "texture_colors": { base: '#D2B48C', bands_light: ['#F5DEB3', '#FFEBCD'], bands_dark: ['#A0522D', '#8B4513'], spot: '#C19A6B'},
                "desc": "태양계에서 가장 큰 가스 행성으로, 대적점이라는 거대한 폭풍이 수백 년째 지속되고 있습니다.",
                "type": "gas_giant_bands_spot", axialTiltDeg: 3.13, orbitalPeriod: 4333, density: 1.33, surfaceGravity: 2.53, rotationPeriod: 0.0015,
                "distanceFromSun": 5.2, "temperature": -110, "moons": 95,
                "funFact": "목성의 대적점은 지구 3개가 들어갈 만큼 큰 폭풍입니다!",
                "educationalNote": "목성은 태양계의 '청소부' 역할을 합니다. 강한 중력으로 소행성들을 끌어당겨 지구를 보호해요.",
                "gameStrategy": "목성은 가장 크고 무거운 행성입니다. 움직이기는 어렵지만 한 번 움직이면 막을 수 없는 파괴력을 가집니다!"
            },
            {
                "name": "토성", "color": '#F0E68C', "size": 40, "mass": 95, "id": "saturn",
                "texture_colors": { body: '#EEE8AA', rings: ['rgba(210,180,140,0.7)', 'rgba(240,220,190,0.6)', 'rgba(188,150,120,0.5)']},
                "desc": "아름다운 고리로 유명한 가스 행성입니다. 밀도가 낮아서 물에 뜰 수 있습니다.",
                "type": "gas_giant_rings", axialTiltDeg: 26.73, orbitalPeriod: 10759, density: 0.69, surfaceGravity: 1.07, rotationPeriod: 0.0016,
                "distanceFromSun": 9.5, "temperature": -140, "moons": 146,
                "funFact": "토성의 고리는 수십억 개의 얼음과 바위 조각으로 이루어져 있어요!",
                "educationalNote": "토성은 물보다 가볍습니다. 거대한 바다가 있다면 토성이 둥둥 떠다닐 거예요!",
                "gameStrategy": "토성은 크지만 밀도가 낮아 목성보다 가벼워요. 고리가 있어서 회전 효과가 독특합니다."
            },
            {
                "name": "천왕성", "color": '#AFEEEE', "size": 30, "mass": 14.5, "id": "uranus",
                "texture_colors": { body: '#ADD8E6', atmosphere: ['#B0E0E6', '#AFEEEE'], rings_faint: 'rgba(200,220,220,0.3)'},
                "desc": "옆으로 누워서 자전하는 독특한 얼음 행성입니다. 메탄 때문에 푸른빛을 띱니다.",
                "type": "ice_giant_rings", axialTiltDeg: 97.77, orbitalPeriod: 30687, density: 1.27, surfaceGravity: 0.89, rotationPeriod: 0.0025,
                "distanceFromSun": 19.2, "temperature": -195, "moons": 27,
                "funFact": "천왕성의 자전축은 98도 기울어져 있어서 옆으로 굴러다니는 것 같아요!",
                "educationalNote": "천왕성의 극지방은 42년 동안 계속 겨울이거나 여름입니다.",
                "gameStrategy": "천왕성은 특이한 자전축 때문에 예측하기 어려운 움직임을 보입니다. 고급 전략에 활용해보세요."
            },
            {
                "name": "해왕성", "color": '#6495ED', "size": 28, "mass": 17, "id": "neptune",
                "texture_colors": { body: '#4169E1', spots_clouds: ['#5F9EA0', '#000080', 'rgba(173,216,230,0.4)']},
                "desc": "태양계에서 가장 바람이 강한 행성으로, 시속 2000km의 바람이 불기도 합니다.",
                "type": "ice_giant_spot_clouds", axialTiltDeg: 28.32, orbitalPeriod: 60190, density: 1.64, surfaceGravity: 1.14, rotationPeriod: 0.0023,
                "distanceFromSun": 30.1, "temperature": -200, "moons": 16,
                "funFact": "해왕성에서는 다이아몬드 비가 내릴 수도 있어요! 높은 압력과 온도 때문입니다.",
                "educationalNote": "해왕성은 수학으로 발견된 첫 번째 행성입니다. 천왕성의 궤도 이상을 설명하려다 발견했어요!",
                "gameStrategy": "해왕성은 강한 바람을 가진 행성입니다. 게임에서는 충돌 후 더 멀리 튕겨나가는 특성이 있어요."
            }
        ];

        // --- Enhanced Physics Engine ---
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : {r:255, g:255, b:255};
        }

        class Particle {
            constructor(x, y, color, size = 2, life = 30, vxOverride = null, vyOverride = null) {
                this.x = x;
                this.y = y;
                this.vx = vxOverride !== null ? vxOverride : (Math.random() - 0.5) * 4;
                this.vy = vyOverride !== null ? vyOverride : (Math.random() - 0.5) * 4;
                this.color = color;
                this.baseSize = size;
                this.life = life;
                this.age = 0;
                this.maxLife = life;
                this.damping = 0.97;
            }

            update(deltaTime) {
                this.x += this.vx * (deltaTime * 60);
                this.y += this.vy * (deltaTime * 60);
                this.vx *= Math.pow(this.damping, deltaTime * 60);
                this.vy *= Math.pow(this.damping, deltaTime * 60);
                this.age++;
                return this.age < this.maxLife;
            }

            draw(context) {
                const progress = this.age / this.maxLife;
                const alpha = Math.max(0, 1 - progress * progress);
                const currentSize = Math.max(0.5, this.baseSize * (1 - progress * 0.7));

                if (currentSize < 0.5 || alpha <= 0) return;

                const rgb = hexToRgb(this.color);
                context.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
                context.beginPath();
                context.arc(this.x, this.y, currentSize, 0, Math.PI * 2);
                context.fill();
            }
        }

        function detectCollision(p1, p2) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const distSq = dx * dx + dy * dy;
            const minDist = p1.size + p2.size;
            return distSq < minDist * minDist;
        }

        function resolveCollision(p1, p2, dt) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            let dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist === 0) {
                dist = 0.1;
            }
            
            const nx = dx / dist;
            const ny = dy / dist;
            
            const overlap = (p1.size + p2.size) - dist;
            if (overlap > 0) {
                const m1 = Math.max(0.1, p1.mass);
                const m2 = Math.max(0.1, p2.mass);
                const totalMass = m1 + m2;
                
                const p1Ratio = m2 / totalMass;
                const p2Ratio = m1 / totalMass;
                
                p1.x -= nx * overlap * p1Ratio * 0.5;
                p1.y -= ny * overlap * p1Ratio * 0.5;
                p2.x += nx * overlap * p2Ratio * 0.5;
                p2.y += ny * overlap * p2Ratio * 0.5;
            }
            
            const m1 = Math.max(0.1, p1.mass);
            const m2 = Math.max(0.1, p2.mass);
            
            const tx = -ny;
            const ty = nx;
            
            const v1n = p1.vx * nx + p1.vy * ny;
            const v1t = p1.vx * tx + p1.vy * ty;
            const v2n = p2.vx * nx + p2.vy * ny;
            const v2t = p2.vx * tx + p2.vy * ty;
            
            const e = 0.8;
            
            let v1nAfter = ((m1 - e * m2) * v1n + (1 + e) * m2 * v2n) / (m1 + m2);
            let v2nAfter = ((m2 - e * m1) * v2n + (1 + e) * m1 * v1n) / (m1 + m2);
            
            p1.vx = v1nAfter * nx + v1t * tx;
            p1.vy = v1nAfter * ny + v1t * ty;
            p2.vx = v2nAfter * nx + v2t * ty;
            p2.vy = v2nAfter * ny + v2t * ty;
            
            return {
                x: p1.x + nx * p1.size,
                y: p1.y + ny * p1.size,
                energy: Math.abs(v1nAfter - v1n) + Math.abs(v2nAfter - v2n)
            };
        }

        function applyGravity(p1, p2, dt, G = 0.1) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const distSq = dx * dx + dy * dy;
            if (distSq === 0) return;
            const dist = Math.sqrt(distSq);
            const minGravDist = p1.size + p2.size + 2;
            
            if (dist > minGravDist) {
                let gravityMult = 1;
                if (p1.type === 'star') gravityMult *= 2.5;
                if (p2.type === 'star') gravityMult *= 2.5;

                let forceMagnitude = G * gravityMult * (p1.mass * p2.mass) / distSq;
                const maxForceAllowed = 30;
                forceMagnitude = Math.min(forceMagnitude, maxForceAllowed);
                
                const forceX = forceMagnitude * dx / dist;
                const forceY = forceMagnitude * dy / dist;

                if (p1.mass > 0) {
                    p1.vx += forceX / p1.mass * dt;
                    p1.vy += forceY / p1.mass * dt;
                }
                if (p2.mass > 0) {
                    p2.vx -= forceX / p2.mass * dt;
                    p2.vy -= forceY / p2.mass * dt;
                }
            }
        }

        function createCollisionParticles(x, y, energy, color1, color2) {
            const particles = [];
            const numParticles = Math.min(25, Math.max(8, Math.floor(energy * 2.5)));
            
            for (let i = 0; i < numParticles; i++) {
                const speed = Math.random() * 2.5 + (energy * 0.35);
                const angle = Math.random() * Math.PI * 2;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                
                const color = Math.random() < 0.5 ? color1 : color2;
                const size = Math.random() * 2.5 + 1.5 + (energy * 0.15);
                const life = Math.random() * 15 + 25 + (energy * 6);
                
                particles.push(new Particle(x, y, color, size, life, vx, vy));
            }
            return particles;
        }

        function isOutOfBounds(planet, mapWidth, mapHeight, boundaryData) {
            if (boundaryData.type === "circle") {
                const centerX = boundaryData.center ? boundaryData.center.x * mapWidth : mapWidth / 2;
                const centerY = boundaryData.center ? boundaryData.center.y * mapHeight : mapHeight / 2;
                const radius = boundaryData.radius || Math.min(mapWidth, mapHeight) / 2 - 20;
                const distFromCenter = Math.hypot(planet.x - centerX, planet.y - centerY);
                return distFromCenter > radius + planet.size;
            } else {
                const margin = planet.size * 0.5;
                return (
                    planet.x < -margin ||
                    planet.x > mapWidth + margin ||
                    planet.y < -margin ||
                    planet.y > mapHeight + margin
                );
            }
        }

        // --- Enhanced Planet Class ---
        class Planet {
            constructor(x, y, data, owner = null) {
                this.x = x;
                this.y = y;
                this.initialX = x;
                this.initialY = y;
                this.vx = 0;
                this.vy = 0;
                this.data = data;
                this.size = data.size;
                this.mass = data.mass;
                this.baseColor = data.color;
                this.owner = owner;
                this.selected = false;
                this.out = false;
                
                this.axialTilt = data.axialTiltDeg !== undefined ? data.axialTiltDeg * (Math.PI / 180) : (Math.random() * 45 - 22.5) * (Math.PI / 180);
                this.rotationPeriodFactor = data.rotationPeriod !== undefined ? data.rotationPeriod : Math.random() * 0.009 + 0.001;
                this.angle = Math.random() * Math.PI * 2;
                this.rotationSpeed = this.rotationPeriodFactor * (Math.random() < 0.5 ? 1 : -1);

                this.trails = [];
                this.particles = [];
                
                this.planetType = data.type || "rocky_cratered";
                this.textureColors = data.texture_colors;
                this.textureCanvas = this.buildTexture();
                this.ringCanvas = (this.planetType.includes("rings")) ? this.buildRings() : null;
            }

            _drawShadedCircle(textureCtx, planetSize, baseColorStr, lightAngle = Math.PI / 4, shadowIntensity = 0.3, highlightIntensity = 0.15) {
                textureCtx.save();
                textureCtx.beginPath();
                textureCtx.arc(planetSize, planetSize, planetSize, 0, Math.PI * 2);
                textureCtx.clip();

                const shadowX = planetSize + Math.cos(lightAngle + Math.PI) * planetSize * 0.5;
                const shadowY = planetSize + Math.sin(lightAngle + Math.PI) * planetSize * 0.5;
                const shadowGrad = textureCtx.createRadialGradient(shadowX, shadowY, planetSize * 0.3, shadowX, shadowY, planetSize * 1.5);
                
                shadowGrad.addColorStop(0, `rgba(0, 0, 0, ${shadowIntensity})`);
                shadowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                // Fill base color
                textureCtx.fillStyle = baseColorStr;
                textureCtx.fill();
                
                // Add shadow
                textureCtx.fillStyle = shadowGrad;
                textureCtx.fill();
                
                // Add highlight
                const highlightX = planetSize + Math.cos(lightAngle) * planetSize * 0.3;
                const highlightY = planetSize + Math.sin(lightAngle) * planetSize * 0.3;
                const highlightGrad = textureCtx.createRadialGradient(highlightX, highlightY, 0, highlightX, highlightY, planetSize * 0.8);
                highlightGrad.addColorStop(0, `rgba(255, 255, 255, ${highlightIntensity})`);
                highlightGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                textureCtx.fillStyle = highlightGrad;
                textureCtx.fill();
                
                textureCtx.restore();
            }
        }

        // --- End of Planet class ---
    </script>
</head>
<body>

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>솔라 시스템 마블 - 태양계 학습 게임</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #00d4ff;
            --secondary-color: #ff6b35;
            --accent-color: #ffd700;
            --dark-bg: #0a0a15;
            --darker-bg: #050508;
            --card-bg: rgba(15, 25, 45, 0.95);
            --glass-bg: rgba(255, 255, 255, 0.1);
            --text-primary: #ffffff;
            --text-secondary: #b8c6db;
            --success-color: #4caf50;
            --warning-color: #ff9800;
            --danger-color: #f44336;
            --border-glow: rgba(0, 212, 255, 0.3);
            --shadow-glow: 0 0 30px rgba(0, 212, 255, 0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--dark-bg) 0%, var(--darker-bg) 100%);
            color: var(--text-primary);
            font-family: 'Noto Sans KR', sans-serif;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(120, 219, 255, 0.3) 0%, transparent 50%);
            animation: backgroundMove 20s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes backgroundMove {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(1deg); }
        }

        #gameCanvas {
            background: transparent;
            border: 2px solid var(--border-glow);
            border-radius: 16px;
            box-shadow: var(--shadow-glow), inset 0 0 20px rgba(0, 0, 0, 0.3);
            display: block;
            transition: all 0.3s ease;
        }

        #gameCanvas:hover {
            box-shadow: 0 0 50px rgba(0, 212, 255, 0.4), inset 0 0 20px rgba(0, 0, 0, 0.3);
        }

        .ui-panel {
            background: var(--card-bg);
            backdrop-filter: blur(15px);
            border: 1px solid var(--border-glow);
            border-radius: 16px;
            padding: 20px;
            box-shadow: var(--shadow-glow);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .ui-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            animation: shimmer 2s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        .ui-panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 40px rgba(0, 212, 255, 0.3);
        }

        #draftInfoPanel {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 420px;
            min-height: 140px;
            display: none;
            z-index: 100;
            animation: slideUpIn 0.3s ease-out;
        }

        @keyframes slideUpIn {
            from { transform: translateX(-50%) translateY(20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        #draftInfoPanel h3 {
            margin: 0 0 12px 0;
            color: var(--accent-color);
            font-size: 1.2em;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        #draftInfoPanel p {
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .stat-bar-container {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.8em;
        }

        .stat-bar-label {
            width: 50px;
            margin-right: 8px;
            color: var(--text-secondary);
            font-weight: 500;
            text-align: left;
        }

        .stat-bar {
            flex-grow: 1;
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }

        .stat-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
            animation: statShimmer 2s ease-in-out infinite;
        }

        @keyframes statShimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(200%); }
        }

        .stat-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success-color), #66bb6a);
            border-radius: 5px;
            transition: width 0.5s ease-out;
            position: relative;
            overflow: hidden;
        }

        .stat-bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: fillGlow 1.5s ease-in-out infinite;
        }

        @keyframes fillGlow {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        .stat-bar-value {
            width: 40px;
            text-align: right;
            margin-left: 8px;
            color: var(--text-primary);
            font-weight: 500;
        }

        #powerBarContainer {
            position: fixed;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            width: 280px;
            height: 36px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 18px;
            border: 2px solid var(--border-glow);
            padding: 4px;
            box-shadow: var(--shadow-glow);
            display: none;
            z-index: 100;
            animation: powerBarPulse 2s ease-in-out infinite alternate;
        }

        @keyframes powerBarPulse {
            from { box-shadow: 0 0 20px rgba(0, 212, 255, 0.3); }
            to { box-shadow: 0 0 30px rgba(0, 212, 255, 0.5); }
        }

        #powerBarFill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, var(--success-color), var(--warning-color), var(--danger-color));
            border-radius: 14px;
            transition: width 0.1s linear, box-shadow 0.1s linear;
            position: relative;
            overflow: hidden;
        }

        #powerBarFill::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: powerFillMove 1s ease-in-out infinite;
        }

        @keyframes powerFillMove {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        #powerBarText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--text-primary);
            font-size: 0.9em;
            font-weight: 700;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            font-family: 'Orbitron', monospace;
        }

        .game-ui-element {
            position: fixed;
            padding: 12px 18px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid var(--border-glow);
            box-shadow: var(--shadow-glow);
            font-size: 1em;
            z-index: 90;
            transition: all 0.3s ease;
        }

        .game-ui-element:hover {
            transform: scale(1.02);
            box-shadow: 0 0 25px rgba(0, 212, 255, 0.4);
        }

        #gameMessages {
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.1em;
            font-weight: 600;
            z-index: 120;
            text-align: center;
            min-width: 200px;
            animation: messageSlide 0.5s ease-out;
        }

        @keyframes messageSlide {
            from { transform: translateX(-50%) translateY(-20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        #turnIndicator {
            top: 20px;
            left: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: var(--accent-color);
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        #aliveCount {
            top: 70px;
            left: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 500;
        }

        #instructions {
            bottom: 20px;
            right: 20px;
            font-size: 0.8em;
            color: var(--text-secondary);
            text-align: right;
            max-width: 250px;
            line-height: 1.3;
        }

        .player-picks-ui {
            position: fixed;
            padding: 8px 12px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            border: 1px solid var(--border-glow);
            font-size: 0.9em;
            display: flex;
            align-items: center;
            z-index: 90;
            box-shadow: var(--shadow-glow);
            transition: all 0.3s ease;
        }

        .player-picks-ui:hover {
            transform: scale(1.05);
        }

        .player-picks-ui img {
            width: 28px;
            height: 28px;
            margin-left: 6px;
            border-radius: 50%;
            border: 2px solid var(--border-glow);
            transition: transform 0.2s ease;
        }

        .player-picks-ui img:hover {
            transform: scale(1.1);
        }

        #p1Picks { 
            left: 20px; 
            top: 120px;
            border-color: #ff6464;
            box-shadow: 0 0 15px rgba(255, 100, 100, 0.3);
        }

        #p2Picks { 
            right: 20px; 
            top: 20px;
            border-color: #6464ff;
            box-shadow: 0 0 15px rgba(100, 100, 255, 0.3);
        }

        .button {
            padding: 14px 28px;
            background: linear-gradient(135deg, var(--primary-color), #0099cc);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            margin: 12px;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            font-family: 'Noto Sans KR', sans-serif;
        }

        .button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .button:hover {
            background: linear-gradient(135deg, #00b4d8, var(--primary-color));
            box-shadow: 0 6px 25px rgba(0, 212, 255, 0.5);
            transform: translateY(-2px);
        }

        .button:hover::before {
            left: 100%;
        }

        .button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 212, 255, 0.3);
        }

        .button.secondary {
            background: linear-gradient(135deg, var(--secondary-color), #cc5500);
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
        }

        .button.secondary:hover {
            background: linear-gradient(135deg, #ff8a65, var(--secondary-color));
            box-shadow: 0 6px 25px rgba(255, 107, 53, 0.5);
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 200;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            justify-content: center;
            align-items: center;
            animation: modalFadeIn 0.3s ease-out;
        }

        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            margin: auto;
            padding: 30px;
            border: 2px solid var(--border-glow);
            border-radius: 20px;
            width: 90%;
            max-width: 700px;
            text-align: center;
            box-shadow: 0 10px 50px rgba(0, 212, 255, 0.3);
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from { transform: scale(0.7) translateY(50px); opacity: 0; }
            to { transform: scale(1) translateY(0); opacity: 1; }
        }

        .modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            animation: shimmer 2s ease-in-out infinite;
        }

        .modal-content h2 {
            color: var(--accent-color);
            margin-top: 0;
            margin-bottom: 20px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        .modal-content p {
            margin-bottom: 16px;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .close-button {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            font-size: 1.5em;
            color: var(--text-secondary);
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-button:hover {
            color: var(--danger-color);
        }

        .planet-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            text-align: left;
            margin-top: 20px;
        }

        .planet-info-item {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .planet-info-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .planet-info-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.2);
            border-color: var(--border-glow);
        }

        .planet-info-item:hover::before {
            opacity: 1;
        }

        .planet-info-item h4 {
            margin-top: 0;
            margin-bottom: 12px;
            color: var(--accent-color);
            font-family: 'Orbitron', sans-serif;
            font-weight: 600;
        }

        .planet-info-item p {
            font-size: 0.9em;
            margin-bottom: 6px;
            color: var(--text-secondary);
        }

        .planet-info-item .planet-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            float: right;
            margin-left: 15px;
            border: 2px solid var(--border-glow);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        .fun-fact {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 107, 53, 0.1));
            padding: 12px;
            border-radius: 10px;
            margin-top: 10px;
            border-left: 4px solid var(--accent-color);
            font-style: italic;
            color: var(--text-primary);
        }

        #startScreen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 150;
            width: 90%;
            max-width: 650px;
            text-align: center;
        }

        #startScreen h1 {
            color: var(--accent-color);
            font-size: 2.5em;
            margin-bottom: 15px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            animation: titleGlow 3s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            from { text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
            to { text-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
        }

        #startScreen p {
            color: var(--text-secondary);
            font-size: 1.1em;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        #modeSelectContainer {
            margin: 20px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            font-size: 1.1em;
            color: var(--text-primary);
            font-weight: 500;
        }

        #modeSelect {
            padding: 12px 16px;
            border-radius: 10px;
            border: 2px solid var(--border-glow);
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            color: var(--text-primary);
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Noto Sans KR', sans-serif;
        }

        #modeSelect:hover {
            border-color: var(--primary-color);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        #modeSelect option {
            background: var(--card-bg);
            color: var(--text-primary);
        }

        #modeDescription {
            margin: 15px 0 25px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.95em;
            color: var(--text-secondary);
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.4;
        }

        .tutorial-section {
            background: rgba(255, 255, 255, 0.03);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 4px solid var(--primary-color);
        }

        .tutorial-section h3 {
            color: var(--primary-color);
            margin-bottom: 12px;
            font-family: 'Orbitron', sans-serif;
        }

        .tutorial-step {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .tutorial-step-number {
            background: var(--primary-color);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 12px;
            font-size: 0.8em;
        }

        .comparison-chart {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .chart-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chart-item h5 {
            color: var(--accent-color);
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .chart-bar {
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 5px 0;
        }

        .chart-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            border-radius: 10px;
            transition: width 1s ease-out;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            #startScreen h1 { font-size: 2em; }
            .modal-content { padding: 20px; max-height: 80vh; }
            .planet-info-grid { grid-template-columns: 1fr; gap: 15px; }
            .game-ui-element { padding: 8px 12px; font-size: 0.9em; }
            #powerBarContainer { width: 220px; height: 32px; }
            #draftInfoPanel { max-width: 350px; bottom: 20px; }
            .comparison-chart { grid-template-columns: 1fr; }
            .tutorial-step { flex-direction: column; text-align: center; }
            .tutorial-step-number { margin: 0 0 8px 0; }
        }

        @media (max-width: 480px) {
            #startScreen h1 { font-size: 1.6em; }
            .modal-content { padding: 15px; }
            .button { padding: 10px 20px; font-size: 0.9em; }
            .game-ui-element { padding: 6px 10px; font-size: 0.8em; }
            #powerBarContainer { width: 180px; height: 28px; }
            .player-picks-ui img { width: 24px; height: 24px; }
        }

        /* Loading Animation */
        .loading-spinner {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #00b4d8;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="turnIndicator" class="game-ui-element" style="display: none;">
        <i class="fas fa-user"></i> P1의 턴
    </div>
    
    <div id="aliveCount" class="game-ui-element" style="display: none;">
        <i class="fas fa-chart-bar"></i> P1: 3 | P2: 3
    </div>
    
    <div id="instructions" class="game-ui-element" style="display: none;">
        <i class="fas fa-info-circle"></i> 행성 클릭 후 반대방향으로 드래그<br>
        <i class="fas fa-keyboard"></i> SPACE: 최대 파워 | R: 재시작<br>
        <i class="fas fa-question-circle"></i> H: 도움말
    </div>

    <div id="draftInfoPanel" class="ui-panel">
        <h3 id="draftPlanetName">
            <i class="fas fa-globe"></i> 행성 이름
        </h3>
        <p id="draftPlanetDesc">행성 설명이 여기에 표시됩니다.</p>
        <div class="stat-bar-container">
            <span class="stat-bar-label">크기:</span>
            <div class="stat-bar">
                <div id="draftStatSize" class="stat-bar-fill"></div>
            </div>
            <span id="draftStatSizeValue" class="stat-bar-value">0</span>
        </div>
        <div class="stat-bar-container">
            <span class="stat-bar-label">밀도:</span>
            <div class="stat-bar">
                <div id="draftStatDensity" class="stat-bar-fill" style="background: linear-gradient(90deg, #8A2BE2, #9932CC);"></div>
            </div>
            <span id="draftStatDensityValue" class="stat-bar-value">0</span>
        </div>
        <div class="stat-bar-container">
            <span class="stat-bar-label">중력:</span>
            <div class="stat-bar">
                <div id="draftStatGravity" class="stat-bar-fill" style="background: linear-gradient(90deg, #00BFFF, #1E90FF);"></div>
            </div>
            <span id="draftStatGravityValue" class="stat-bar-value">0</span>
        </div>
    </div>

    <div id="powerBarContainer">
        <div id="powerBarFill"></div>
        <div id="powerBarText">
            <i class="fas fa-bolt"></i> 파워: 0%
        </div>
    </div>

    <div id="gameMessages" class="game-ui-element" style="display: none;">
        <i class="fas fa-comment"></i> 게임 메시지
    </div>

    <div id="p1Picks" class="player-picks-ui" style="display:none;">
        <i class="fas fa-user" style="color: #ff6464;"></i> P1 선택:
    </div>
    
    <div id="p2Picks" class="player-picks-ui" style="display:none;">
        <i class="fas fa-user" style="color: #6464ff;"></i> P2 선택:
    </div>
    
    <!-- Game End Modal -->
    <div id="endGameModal" class="modal">
        <div class="modal-content">
            <button class="close-button" onclick="document.getElementById('endGameModal').style.display='none'">
                <i class="fas fa-times"></i>
            </button>
            <h2 id="winnerMessage">
                <i class="fas fa-trophy"></i> 승리 메시지
            </h2>
            <p id="congratsMessage">축하 메시지</p>
            <button id="restartButton" class="button">
                <i class="fas fa-redo"></i> 다시 플레이 (R)
            </button>
        </div>
    </div>

    <!-- Tutorial Modal -->
    <div id="tutorialModal" class="modal">
        <div class="modal-content">
            <button class="close-button" onclick="document.getElementById('tutorialModal').style.display='none'">
                <i class="fas fa-times"></i>
            </button>
            <h2><i class="fas fa-graduation-cap"></i> 게임 설명서</h2>
            
            <div class="tutorial-section">
                <h3><i class="fas fa-gamepad"></i> 게임 목표</h3>
                <p>태양계의 행성들을 이용해 상대방의 행성을 모두 맵 밖으로 밀어내거나, 컬링 모드에서 높은 점수를 획득하세요!</p>
            </div>

            <div class="tutorial-section">
                <h3><i class="fas fa-mouse"></i> 조작 방법</h3>
                <div class="tutorial-step">
                    <div class="tutorial-step-number">1</div>
                    <div>자신의 행성을 마우스로 클릭하여 선택</div>
                </div>
                <div class="tutorial-step">
                    <div class="tutorial-step-number">2</div>
                    <div>발사하고 싶은 반대 방향으로 드래그</div>
                </div>
                <div class="tutorial-step">
                    <div class="tutorial-step-number">3</div>
                    <div>마우스를 놓아서 행성 발사</div>
                </div>
                <div class="tutorial-step">
                    <div class="tutorial-step-number">4</div>
                    <div>SPACE 키로 최대 파워 설정 가능</div>
                </div>
            </div>

            <div class="tutorial-section">
                <h3><i class="fas fa-star"></i> 게임 모드</h3>
                <p><strong>알까기 모드:</strong> 상대방의 모든 행성을 맵 밖으로 밀어내면 승리</p>
                <p><strong>컬링 모드:</strong> 3라운드 동안 중앙 원에 가까이 행성을 위치시켜 점수 획득</p>
            </div>

            <div class="tutorial-section">
                <h3><i class="fas fa-lightbulb"></i> 전략 팁</h3>
                <p>• 큰 행성은 무겁고 강력하지만 움직이기 어려움</p>
                <p>• 작은 행성은 빠르게 움직이지만 충돌시 밀려남</p>
                <p>• 중력을 이용해 궤도를 활용하세요</p>
                <p>• 태양의 강한 중력을 전략적으로 활용</p>
            </div>

            <button class="button" onclick="document.getElementById('tutorialModal').style.display='none'">
                <i class="fas fa-check"></i> 이해했습니다
            </button>
        </div>
    </div>

    <!-- Planet Info Modal -->
    <div id="planetInfoModal" class="modal">
        <div class="modal-content">
            <button class="close-button" onclick="document.getElementById('planetInfoModal').style.display='none'">
                <i class="fas fa-times"></i>
            </button>
            <h2><i class="fas fa-globe-americas"></i> 태양계 행성 학습</h2>
            
            <div class="comparison-chart">
                <div class="chart-item">
                    <h5>크기 비교 (지구=1)</h5>
                    <div class="chart-bar">
                        <div class="chart-fill" style="width: 100%;" data-planet="earth"></div>
                    </div>
                    <small>지구 기준</small>
                </div>
                <div class="chart-item">
                    <h5>거리 비교 (AU)</h5>
                    <div class="chart-bar">
                        <div class="chart-fill" style="width: 100%;" data-planet="distance"></div>
                    </div>
                    <small>태양으로부터</small>
                </div>
            </div>

            <div id="planetInfoGrid" class="planet-info-grid"></div>
            
            <button id="closePlanetInfoBtn" class="button">
                <i class="fas fa-arrow-left"></i> 돌아가기
            </button>
        </div>
    </div>

    <!-- Quiz Modal -->
    <div id="quizModal" class="modal">
        <div class="modal-content">
            <button class="close-button" onclick="document.getElementById('quizModal').style.display='none'">
                <i class="fas fa-times"></i>
            </button>
            <h2><i class="fas fa-brain"></i> 태양계 퀴즈</h2>
            <div id="quizContent">
                <div id="quizQuestion"></div>
                <div id="quizOptions"></div>
                <div id="quizResult" style="display: none;"></div>
                <div id="quizScore">점수: <span id="currentScore">0</span> / <span id="totalQuestions">0</span></div>
                <button id="nextQuizBtn" class="button" style="display: none;" onclick="nextQuiz()">
                    <i class="fas fa-arrow-right"></i> 다음 문제
                </button>
                <button id="startQuizBtn" class="button" onclick="startQuiz()">
                    <i class="fas fa-play"></i> 퀴즈 시작
                </button>
            </div>
        </div>
    </div>

    <!-- Debug Panel -->
    <div id="debugPanel" style="display: none; position: fixed; top: 10px; right: 300px; background: rgba(0,0,0,0.8); color: white; padding: 10px; border-radius: 8px; font-family: monospace; font-size: 12px; z-index: 200; max-width: 250px;">
        <h4 style="margin: 0 0 8px 0; color: #00ff00;">🔧 디버그 모드</h4>
        <div id="debugInfo"></div>
        <button onclick="toggleDebugMode()" style="margin-top: 8px; padding: 4px 8px; background: #333; color: white; border: 1px solid #666; border-radius: 4px; cursor: pointer;">
            디버그 모드 끄기
        </button>
    </div>

    <!-- Learning Progress Tracker -->
    <div id="learningProgress" style="display: none; position: fixed; top: 20px; right: 20px; background: var(--card-bg); backdrop-filter: blur(15px); border: 1px solid var(--border-glow); border-radius: 12px; padding: 15px; color: white; z-index: 150; max-width: 250px;">
        <h4 style="margin: 0 0 10px 0; color: var(--accent-color);">📚 학습 진행도</h4>
        <div id="progressBars"></div>
        <div style="margin-top: 10px; font-size: 12px; color: var(--text-secondary);">
            총 플레이 시간: <span id="totalPlayTime">0분</span>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="ui-panel">
        <h1><i class="fas fa-rocket"></i> 태양계 알까기</h1>
        <p>우주를 배경으로 펼쳐지는 전략 시뮬레이션 게임!<br>
        실제 태양계 행성들의 물리 법칙을 체험하며 전략적 사고력을 기르세요.</p>
        
        <div id="modeSelectContainer">
            <label for="modeSelect">
                <i class="fas fa-cog"></i> 게임 모드:
            </label>
            <select id="modeSelect">
                <option value="alggagi" selected>🎯 알까기 모드</option>
                <option value="culling">🥌 컬링 모드</option>
            </select>
        </div>
        
        <div id="modeDescription">
            행성들을 이용해 상대방의 행성을 모두 맵 밖으로 밀어내세요.
        </div>
        
        <button id="startGameBtn" class="button">
            <i class="fas fa-play"></i> 게임 시작
        </button>
        
        <button id="learnPlanetsBtn" class="button secondary">
            <i class="fas fa-book"></i> 행성 학습
        </button>
        
        <button id="tutorialBtn" class="button secondary">
            <i class="fas fa-question-circle"></i> 게임 설명
        </button>
        
        <button id="quizBtn" class="button secondary">
            <i class="fas fa-brain"></i> 태양계 퀴즈
        </button>
        
        <button id="debugModeBtn" class="button secondary" style="font-size: 0.8em;">
            <i class="fas fa-bug"></i> 디버그 모드
        </button>
    </div>

    <script type="module">
        // Enhanced Solar System Educational Game
        // Improved with modern UI/UX, debugging, and educational content

        // --- Constants and Global Variables ---
        let canvas, ctx;
        let spaceBackground;
        let currentGameState = null;
        let gameRunningState = "menu";
        let isDragging = false;
        let dragJustStarted = false;
        let selectedPlanet = null;
        let startDragPos = { x: 0, y: 0 };
        let trajectoryPoints = [];
        let lastTime = 0;
        let powerAmount = 0;
        let isGameOver = false;
        let gameLoop = null;
        let draftState = null;
        let draftHandleClick = null;
        let draftHandleMouseMove = null;
        let draftHandleKeyDown = null;
        const pickedPlanets = { P1: [], P2: [] };
        let npcPlanets = [];
        let uiInstructions;
        let debugMode = false;

        // --- Educational Quiz System ---
        const quizQuestions = [
            {
                question: "태양계에서 가장 큰 행성은 무엇인가요?",
                options: ["지구", "목성", "토성", "해왕성"],
                correct: 1,
                explanation: "목성은 태양계에서 가장 큰 행성으로, 지구보다 11배나 큽니다!",
                category: "크기"
            },
            {
                question: "태양에서 가장 가까운 행성은?",
                options: ["금성", "수성", "지구", "화성"],
                correct: 1,
                explanation: "수성은 태양에서 가장 가까운 행성입니다. 하지만 금성이 더 뜨거워요!",
                category: "거리"
            },
            {
                question: "어떤 행성이 거꾸로 자전하나요?",
                options: ["지구", "화성", "금성", "목성"],
                correct: 2,
                explanation: "금성은 다른 행성들과 반대 방향으로 자전합니다. 태양이 서쪽에서 떠요!",
                category: "운동"
            },
            {
                question: "토성의 가장 특별한 특징은?",
                options: ["가장 크다", "아름다운 고리", "가장 빠르다", "가장 뜨겁다"],
                correct: 1,
                explanation: "토성은 아름다운 고리로 유명합니다. 수십억 개의 얼음과 바위 조각으로 이루어져 있어요!",
                category: "특징"
            },
            {
                question: "지구의 자전축은 몇 도 기울어져 있나요?",
                options: ["0도", "23.4도", "45도", "90도"],
                correct: 1,
                explanation: "지구의 자전축은 23.4도 기울어져 있어서 계절이 생깁니다!",
                category: "지구"
            }
        ];

        let currentQuiz = {
            questions: [],
            currentIndex: 0,
            score: 0,
            categories: {}
        };

        // --- Learning Progress Tracking ---
        let learningProgress = {
            startTime: null,
            totalPlayTime: 0,
            planetsLearned: new Set(),
            quizzesTaken: 0,
            correctAnswers: 0,
            gamesPlayed: 0,
            strategiesUsed: new Set()
        };

        // --- Enhanced Educational Planet Data ---
        const planets_data_template = [
            {
                "name": "태양", "color": '#FFFF00', "size": 60, "mass": 150, "id": "sun",
                "texture_colors": { base: '#FFD700', corona: ['#FFFACD', '#FFE4B5', '#FFDEAD'], spots: ['#FFA500', '#FF8C00']},
                "desc": "태양계의 중심에 있는 항성으로, 모든 행성들이 태양 주위를 공전합니다.",
                "type": "star", axialTiltDeg: 7.25, orbitalPeriod: 0, density: 1.41, surfaceGravity: 27.9, rotationPeriod: 0.0001,
                "distanceFromSun": 0, "temperature": 5778, "moons": 0,
                "funFact": "태양은 매초 400만 톤의 질량을 에너지로 변환합니다! 이는 핵융합 반응 때문입니다.",
                "educationalNote": "태양의 중력은 지구보다 28배나 강해서, 만약 태양에 떨어진다면 엄청난 속도로 가속됩니다.",
                "gameStrategy": "태양의 강력한 중력을 이용해 행성의 궤도를 바꿀 수 있습니다. 태양 근처로 행성을 보내면 중력 가속을 받아 더 빠르게 움직입니다."
            },
            {
                "name": "수성", "color": '#A9A9A9', "size": 10, "mass": 0.06, "id": "mercury",
                "texture_colors": { base: '#808080', craters_dark: '#606060', craters_light: '#A0A0A0'},
                "desc": "태양에 가장 가까운 행성으로 작고 빠르며, 표면은 크레이터로 가득합니다.",
                "type": "rocky_cratered", axialTiltDeg: 0.03, orbitalPeriod: 88, density: 5.43, surfaceGravity: 0.38, rotationPeriod: 0.005,
                "distanceFromSun": 0.39, "temperature": 167, "moons": 0,
                "funFact": "수성의 하루는 지구의 176일과 같습니다! 자전이 매우 느리기 때문입니다.",
                "educationalNote": "수성은 밀도가 높아서 작지만 무겁습니다. 이는 큰 철 핵을 가지고 있기 때문입니다.",
                "gameStrategy": "수성은 작지만 밀도가 높아 의외로 무겁습니다. 다른 행성을 밀어낼 때 생각보다 큰 힘을 발휘할 수 있어요."
            },
            {
                "name": "금성", "color": '#F5DEB3', "size": 20, "mass": 0.82, "id": "venus",
                "texture_colors": { base: '#EEDC82', clouds: ['#FFF8DC', '#FAF0E6', '#FFEBCD']},
                "desc": "두꺼운 황산 구름으로 덮여 있으며, 온실효과로 인해 태양계에서 가장 뜨거운 행성입니다.",
                "type": "rocky_cloudy", axialTiltDeg: 177.4, orbitalPeriod: 225, density: 5.24, surfaceGravity: 0.90, rotationPeriod: 0.01,
                "distanceFromSun": 0.72, "temperature": 464, "moons": 0,
                "funFact": "금성은 거꾸로 자전합니다! 태양이 서쪽에서 뜨고 동쪽으로 집니다.",
                "educationalNote": "금성의 대기압은 지구의 90배나 됩니다. 마치 깊은 바다 밑에 있는 것과 같죠!",
                "gameStrategy": "금성은 크기와 질량이 지구와 비슷해 균형 잡힌 플레이가 가능합니다. 공격과 수비 모두에 적합해요."
            },
            {
                "name": "지구", "color": '#6495ED', "size": 22, "mass": 1.0, "id": "earth",
                "texture_colors": { ocean: '#4682B4', land: ['#228B22', '#8FBC8F', '#D2B48C'], cloud: 'rgba(240,248,255,0.7)'},
                "desc": "우리가 살고 있는 행성으로, 액체 상태의 물과 생명체가 존재하는 유일한 행성입니다.",
                "type": "earth-like", axialTiltDeg: 23.44, orbitalPeriod: 365, density: 5.51, surfaceGravity: 1.00, rotationPeriod: 0.003,
                "distanceFromSun": 1.0, "temperature": 15, "moons": 1,
                "funFact": "지구는 초속 30km로 태양 주위를 돌고 있습니다. 1년 동안 9억 4천만 km를 여행해요!",
                "educationalNote": "지구의 자전축이 23.4도 기울어져 있어서 계절이 생깁니다.",
                "gameStrategy": "지구는 게임의 기준이 되는 행성입니다. 모든 스탯이 표준적이어서 초보자가 사용하기 좋아요."
            },
            {
                "name": "화성", "color": '#CD5C5C', "size": 15, "mass": 0.11, "id": "mars",
                "texture_colors": { base: '#BC8F8F', dust: ['#D2B48C', '#CD853F'], ice_caps: '#FFFFFF', craters: '#A0522D'},
                "desc": "붉은 행성이라 불리며, 극지방에 얼음이 있고 과거에 물이 흘렀던 흔적이 발견됩니다.",
                "type": "rocky_ice_caps", axialTiltDeg: 25.19, orbitalPeriod: 687, density: 3.93, surfaceGravity: 0.38, rotationPeriod: 0.0031,
                "distanceFromSun": 1.52, "temperature": -65, "moons": 2,
                "funFact": "화성의 하루는 지구와 거의 같아요! 24시간 37분입니다.",
                "educationalNote": "화성에서는 먼지 폭풍이 행성 전체를 덮을 수 있습니다. 몇 달 동안 지속되기도 해요!",
                "gameStrategy": "화성은 작고 가벼워서 빠르게 움직일 수 있습니다. 기습 공격이나 정밀한 조준에 적합해요."
            },
            {
                "name": "목성", "color": '#DEB887', "size": 45, "mass": 318, "id": "jupiter",
                "texture_colors": { base: '#D2B48C', bands_light: ['#F5DEB3', '#FFEBCD'], bands_dark: ['#A0522D', '#8B4513'], spot: '#C19A6B'},
                "desc": "태양계에서 가장 큰 가스 행성으로, 대적점이라는 거대한 폭풍이 수백 년째 지속되고 있습니다.",
                "type": "gas_giant_bands_spot", axialTiltDeg: 3.13, orbitalPeriod: 4333, density: 1.33, surfaceGravity: 2.53, rotationPeriod: 0.0015,
                "distanceFromSun": 5.2, "temperature": -110, "moons": 95,
                "funFact": "목성의 대적점은 지구 3개가 들어갈 만큼 큰 폭풍입니다!",
                "educationalNote": "목성은 태양계의 '청소부' 역할을 합니다. 강한 중력으로 소행성들을 끌어당겨 지구를 보호해요.",
                "gameStrategy": "목성은 가장 크고 무거운 행성입니다. 움직이기는 어렵지만 한 번 움직이면 막을 수 없는 파괴력을 가집니다!"
            },
            {
                "name": "토성", "color": '#F0E68C', "size": 40, "mass": 95, "id": "saturn",
                "texture_colors": { body: '#EEE8AA', rings: ['rgba(210,180,140,0.7)', 'rgba(240,220,190,0.6)', 'rgba(188,150,120,0.5)']},
                "desc": "아름다운 고리로 유명한 가스 행성입니다. 밀도가 낮아서 물에 뜰 수 있습니다.",
                "type": "gas_giant_rings", axialTiltDeg: 26.73, orbitalPeriod: 10759, density: 0.69, surfaceGravity: 1.07, rotationPeriod: 0.0016,
                "distanceFromSun": 9.5, "temperature": -140, "moons": 146,
                "funFact": "토성의 고리는 수십억 개의 얼음과 바위 조각으로 이루어져 있어요!",
                "educationalNote": "토성은 물보다 가볍습니다. 거대한 바다가 있다면 토성이 둥둥 떠다닐 거예요!",
                "gameStrategy": "토성은 크지만 밀도가 낮아 목성보다 가벼워요. 고리가 있어서 회전 효과가 독특합니다."
            },
            {
                "name": "천왕성", "color": '#AFEEEE', "size": 30, "mass": 14.5, "id": "uranus",
                "texture_colors": { body: '#ADD8E6', atmosphere: ['#B0E0E6', '#AFEEEE'], rings_faint: 'rgba(200,220,220,0.3)'},
                "desc": "옆으로 누워서 자전하는 독특한 얼음 행성입니다. 메탄 때문에 푸른빛을 띱니다.",
                "type": "ice_giant_rings", axialTiltDeg: 97.77, orbitalPeriod: 30687, density: 1.27, surfaceGravity: 0.89, rotationPeriod: 0.0025,
                "distanceFromSun": 19.2, "temperature": -195, "moons": 27,
                "funFact": "천왕성의 자전축은 98도 기울어져 있어서 옆으로 굴러다니는 것 같아요!",
                "educationalNote": "천왕성의 극지방은 42년 동안 계속 겨울이거나 여름입니다.",
                "gameStrategy": "천왕성은 특이한 자전축 때문에 예측하기 어려운 움직임을 보입니다. 고급 전략에 활용해보세요."
            },
            {
                "name": "해왕성", "color": '#6495ED', "size": 28, "mass": 17, "id": "neptune",
                "texture_colors": { body: '#4169E1', spots_clouds: ['#5F9EA0', '#000080', 'rgba(173,216,230,0.4)']},
                "desc": "태양계에서 가장 바람이 강한 행성으로, 시속 2000km의 바람이 불기도 합니다.",
                "type": "ice_giant_spot_clouds", axialTiltDeg: 28.32, orbitalPeriod: 60190, density: 1.64, surfaceGravity: 1.14, rotationPeriod: 0.0023,
                "distanceFromSun": 30.1, "temperature": -200, "moons": 16,
                "funFact": "해왕성에서는 다이아몬드 비가 내릴 수도 있어요! 높은 압력과 온도 때문입니다.",
                "educationalNote": "해왕성은 수학으로 발견된 첫 번째 행성입니다. 천왕성의 궤도 이상을 설명하려다 발견했어요!",
                "gameStrategy": "해왕성은 강한 바람을 가진 행성입니다. 게임에서는 충돌 후 더 멀리 튕겨나가는 특성이 있어요."
            }
        ];

        // --- Enhanced Physics Engine ---
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : {r:255, g:255, b:255};
        }

        class Particle {
            constructor(x, y, color, size = 2, life = 30, vxOverride = null, vyOverride = null) {
                this.x = x;
                this.y = y;
                this.vx = vxOverride !== null ? vxOverride : (Math.random() - 0.5) * 4;
                this.vy = vyOverride !== null ? vyOverride : (Math.random() - 0.5) * 4;
                this.color = color;
                this.baseSize = size;
                this.life = life;
                this.age = 0;
                this.maxLife = life;
                this.damping = 0.97;
            }

            update(deltaTime) {
                this.x += this.vx * (deltaTime * 60);
                this.y += this.vy * (deltaTime * 60);
                this.vx *= Math.pow(this.damping, deltaTime * 60);
                this.vy *= Math.pow(this.damping, deltaTime * 60);
                this.age++;
                return this.age < this.maxLife;
            }

            draw(context) {
                const progress = this.age / this.maxLife;
                const alpha = Math.max(0, 1 - progress * progress);
                const currentSize = Math.max(0.5, this.baseSize * (1 - progress * 0.7));

                if (currentSize < 0.5 || alpha <= 0) return;

                const rgb = hexToRgb(this.color);
                context.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
                context.beginPath();
                context.arc(this.x, this.y, currentSize, 0, Math.PI * 2);
                context.fill();
            }
        }

        function detectCollision(p1, p2) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const distSq = dx * dx + dy * dy;
            const minDist = p1.size + p2.size;
            return distSq < minDist * minDist;
        }

        function resolveCollision(p1, p2, dt) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            let dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist === 0) {
                dist = 0.1;
            }
            
            const nx = dx / dist;
            const ny = dy / dist;
            
            const overlap = (p1.size + p2.size) - dist;
            if (overlap > 0) {
                const m1 = Math.max(0.1, p1.mass);
                const m2 = Math.max(0.1, p2.mass);
                const totalMass = m1 + m2;
                
                const p1Ratio = m2 / totalMass;
                const p2Ratio = m1 / totalMass;
                
                p1.x -= nx * overlap * p1Ratio * 0.5;
                p1.y -= ny * overlap * p1Ratio * 0.5;
                p2.x += nx * overlap * p2Ratio * 0.5;
                p2.y += ny * overlap * p2Ratio * 0.5;
            }
            
            const m1 = Math.max(0.1, p1.mass);
            const m2 = Math.max(0.1, p2.mass);
            
            const tx = -ny;
            const ty = nx;
            
            const v1n = p1.vx * nx + p1.vy * ny;
            const v1t = p1.vx * tx + p1.vy * ty;
            const v2n = p2.vx * nx + p2.vy * ny;
            const v2t = p2.vx * tx + p2.vy * ty;
            
            const e = 0.8;
            
            let v1nAfter = ((m1 - e * m2) * v1n + (1 + e) * m2 * v2n) / (m1 + m2);
            let v2nAfter = ((m2 - e * m1) * v2n + (1 + e) * m1 * v1n) / (m1 + m2);
            
            p1.vx = v1nAfter * nx + v1t * tx;
            p1.vy = v1nAfter * ny + v1t * ty;
            p2.vx = v2nAfter * nx + v2t * ty;
            p2.vy = v2nAfter * ny + v2t * ty;
            
            return {
                x: p1.x + nx * p1.size,
                y: p1.y + ny * p1.size,
                energy: Math.abs(v1nAfter - v1n) + Math.abs(v2nAfter - v2n)
            };
        }

        function applyGravity(p1, p2, dt, G = 0.1) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const distSq = dx * dx + dy * dy;
            if (distSq === 0) return;
            const dist = Math.sqrt(distSq);
            const minGravDist = p1.size + p2.size + 2;
            
            if (dist > minGravDist) {
                let gravityMult = 1;
                if (p1.type === 'star') gravityMult *= 2.5;
                if (p2.type === 'star') gravityMult *= 2.5;

                let forceMagnitude = G * gravityMult * (p1.mass * p2.mass) / distSq;
                const maxForceAllowed = 30;
                forceMagnitude = Math.min(forceMagnitude, maxForceAllowed);
                
                const forceX = forceMagnitude * dx / dist;
                const forceY = forceMagnitude * dy / dist;

                if (p1.mass > 0) {
                    p1.vx += forceX / p1.mass * dt;
                    p1.vy += forceY / p1.mass * dt;
                }
                if (p2.mass > 0) {
                    p2.vx -= forceX / p2.mass * dt;
                    p2.vy -= forceY / p2.mass * dt;
                }
            }
        }

        function createCollisionParticles(x, y, energy, color1, color2) {
            const particles = [];
            const numParticles = Math.min(25, Math.max(8, Math.floor(energy * 2.5)));
            
            for (let i = 0; i < numParticles; i++) {
                const speed = Math.random() * 2.5 + (energy * 0.35);
                const angle = Math.random() * Math.PI * 2;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                
                const color = Math.random() < 0.5 ? color1 : color2;
                const size = Math.random() * 2.5 + 1.5 + (energy * 0.15);
                const life = Math.random() * 15 + 25 + (energy * 6);
                
                particles.push(new Particle(x, y, color, size, life, vx, vy));
            }
            return particles;
        }

        function isOutOfBounds(planet, mapWidth, mapHeight, boundaryData) {
            if (boundaryData.type === "circle") {
                const centerX = boundaryData.center ? boundaryData.center.x * mapWidth : mapWidth / 2;
                const centerY = boundaryData.center ? boundaryData.center.y * mapHeight : mapHeight / 2;
                const radius = boundaryData.radius || Math.min(mapWidth, mapHeight) / 2 - 20;
                const distFromCenter = Math.hypot(planet.x - centerX, planet.y - centerY);
                return distFromCenter > radius + planet.size;
            } else {
                const margin = planet.size * 0.5;
                return (
                    planet.x < -margin ||
                    planet.x > mapWidth + margin ||
                    planet.y < -margin ||
                    planet.y > mapHeight + margin
                );
            }
        }

        // --- Enhanced Planet Class ---
        class Planet {
            constructor(x, y, data, owner = null) {
                this.x = x;
                this.y = y;
                this.initialX = x;
                this.initialY = y;
                this.vx = 0;
                this.vy = 0;
                this.data = data;
                this.size = data.size;
                this.mass = data.mass;
                this.baseColor = data.color;
                this.owner = owner;
                this.selected = false;
                this.out = false;
                
                this.axialTilt = data.axialTiltDeg !== undefined ? data.axialTiltDeg * (Math.PI / 180) : (Math.random() * 45 - 22.5) * (Math.PI / 180);
                this.rotationPeriodFactor = data.rotationPeriod !== undefined ? data.rotationPeriod : Math.random() * 0.009 + 0.001;
                this.angle = Math.random() * Math.PI * 2;
                this.rotationSpeed = this.rotationPeriodFactor * (Math.random() < 0.5 ? 1 : -1);

                this.trails = [];
                this.particles = [];
                
                this.planetType = data.type || "rocky_cratered";
                this.textureColors = data.texture_colors;
                this.textureCanvas = this.buildTexture();
                this.ringCanvas = (this.planetType.includes("rings")) ? this.buildRings() : null;
            }

            _drawShadedCircle(textureCtx, planetSize, baseColorStr, lightAngle = Math.PI / 4, shadowIntensity = 0.3, highlightIntensity = 0.15) {
                textureCtx.save();
                textureCtx.beginPath();
                textureCtx.arc(planetSize, planetSize, planetSize, 0, Math.PI * 2);
                textureCtx.clip();

                const shadowX = planetSize + Math.cos(lightAngle + Math.PI) * planetSize * 0.5;
                const shadowY = planetSize + Math.sin(lightAngle + Math.PI) * planetSize * 0.5;
                const shadowGrad = textureCtx.createRadialGradient(shadowX, shadowY, planetSize * 0.3, shadowX, shadowY, planetSize * 1.5);
                
                shadowGrad.addColorStop(0, `rgba(0, 0, 0, ${shadowIntensity})`);
                shadowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                // Fill base color
                textureCtx.fillStyle = baseColorStr;
                textureCtx.fill();
                
                // Add shadow
                textureCtx.fillStyle = shadowGrad;
                textureCtx.fill();
                
                // Add highlight
                const highlightX = planetSize + Math.cos(lightAngle) * planetSize * 0.3;
                const highlightY = planetSize + Math.sin(lightAngle) * planetSize * 0.3;
                const highlightGrad = textureCtx.createRadialGradient(highlightX, highlightY, 0, highlightX, highlightY, planetSize * 0.8);
                highlightGrad.addColorStop(0, `rgba(255, 255, 255, ${highlightIntensity})`);
                highlightGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                textureCtx.fillStyle = highlightGrad;
                textureCtx.fill();
                
                textureCtx.restore();
            }
        }

        // --- End of Planet class ---
    </script>
</head>
<body>

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>솔라 시스템 마블 - 태양계 학습 게임</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #00d4ff;
            --secondary-color: #ff6b35;
            --accent-color: #ffd700;
            --dark-bg: #0a0a15;
            --darker-bg: #050508;
            --card-bg: rgba(15, 25, 45, 0.95);
            --glass-bg: rgba(255, 255, 255, 0.1);
            --text-primary: #ffffff;
            --text-secondary: #b8c6db;
            --success-color: #4caf50;
            --warning-color: #ff9800;
            --danger-color: #f44336;
            --border-glow: rgba(0, 212, 255, 0.3);
            --shadow-glow: 0 0 30px rgba(0, 212, 255, 0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--dark-bg) 0%, var(--darker-bg) 100%);
            color: var(--text-primary);
            font-family: 'Noto Sans KR', sans-serif;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(120, 219, 255, 0.3) 0%, transparent 50%);
            animation: backgroundMove 20s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes backgroundMove {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(1deg); }
        }

        #gameCanvas {
            background: transparent;
            border: 2px solid var(--border-glow);
            border-radius: 16px;
            box-shadow: var(--shadow-glow), inset 0 0 20px rgba(0, 0, 0, 0.3);
            display: block;
            transition: all 0.3s ease;
        }

        #gameCanvas:hover {
            box-shadow: 0 0 50px rgba(0, 212, 255, 0.4), inset 0 0 20px rgba(0, 0, 0, 0.3);
        }

        .ui-panel {
            background: var(--card-bg);
            backdrop-filter: blur(15px);
            border: 1px solid var(--border-glow);
            border-radius: 16px;
            padding: 20px;
            box-shadow: var(--shadow-glow);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .ui-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            animation: shimmer 2s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        .ui-panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 40px rgba(0, 212, 255, 0.3);
        }

        #draftInfoPanel {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 420px;
            min-height: 140px;
            display: none;
            z-index: 100;
            animation: slideUpIn 0.3s ease-out;
        }

        @keyframes slideUpIn {
            from { transform: translateX(-50%) translateY(20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        #draftInfoPanel h3 {
            margin: 0 0 12px 0;
            color: var(--accent-color);
            font-size: 1.2em;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        #draftInfoPanel p {
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .stat-bar-container {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.8em;
        }

        .stat-bar-label {
            width: 50px;
            margin-right: 8px;
            color: var(--text-secondary);
            font-weight: 500;
            text-align: left;
        }

        .stat-bar {
            flex-grow: 1;
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }

        .stat-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
            animation: statShimmer 2s ease-in-out infinite;
        }

        @keyframes statShimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(200%); }
        }

        .stat-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success-color), #66bb6a);
            border-radius: 5px;
            transition: width 0.5s ease-out;
            position: relative;
            overflow: hidden;
        }

        .stat-bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: fillGlow 1.5s ease-in-out infinite;
        }

        @keyframes fillGlow {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        .stat-bar-value {
            width: 40px;
            text-align: right;
            margin-left: 8px;
            color: var(--text-primary);
            font-weight: 500;
        }

        #powerBarContainer {
            position: fixed;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            width: 280px;
            height: 36px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 18px;
            border: 2px solid var(--border-glow);
            padding: 4px;
            box-shadow: var(--shadow-glow);
            display: none;
            z-index: 100;
            animation: powerBarPulse 2s ease-in-out infinite alternate;
        }

        @keyframes powerBarPulse {
            from { box-shadow: 0 0 20px rgba(0, 212, 255, 0.3); }
            to { box-shadow: 0 0 30px rgba(0, 212, 255, 0.5); }
        }

        #powerBarFill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, var(--success-color), var(--warning-color), var(--danger-color));
            border-radius: 14px;
            transition: width 0.1s linear, box-shadow 0.1s linear;
            position: relative;
            overflow: hidden;
        }

        #powerBarFill::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: powerFillMove 1s ease-in-out infinite;
        }

        @keyframes powerFillMove {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        #powerBarText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--text-primary);
            font-size: 0.9em;
            font-weight: 700;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            font-family: 'Orbitron', monospace;
        }

        .game-ui-element {
            position: fixed;
            padding: 12px 18px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid var(--border-glow);
            box-shadow: var(--shadow-glow);
            font-size: 1em;
            z-index: 90;
            transition: all 0.3s ease;
        }

        .game-ui-element:hover {
            transform: scale(1.02);
            box-shadow: 0 0 25px rgba(0, 212, 255, 0.4);
        }

        #gameMessages {
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.1em;
            font-weight: 600;
            z-index: 120;
            text-align: center;
            min-width: 200px;
            animation: messageSlide 0.5s ease-out;
        }

        @keyframes messageSlide {
            from { transform: translateX(-50%) translateY(-20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        #turnIndicator {
            top: 20px;
            left: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: var(--accent-color);
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        #aliveCount {
            top: 70px;
            left: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 500;
        }

        #instructions {
            bottom: 20px;
            right: 20px;
            font-size: 0.8em;
            color: var(--text-secondary);
            text-align: right;
            max-width: 250px;
            line-height: 1.3;
        }

        .player-picks-ui {
            position: fixed;
            padding: 8px 12px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            border: 1px solid var(--border-glow);
            font-size: 0.9em;
            display: flex;
            align-items: center;
            z-index: 90;
            box-shadow: var(--shadow-glow);
            transition: all 0.3s ease;
        }

        .player-picks-ui:hover {
            transform: scale(1.05);
        }

        .player-picks-ui img {
            width: 28px;
            height: 28px;
            margin-left: 6px;
            border-radius: 50%;
            border: 2px solid var(--border-glow);
            transition: transform 0.2s ease;
        }

        .player-picks-ui img:hover {
            transform: scale(1.1);
        }

        #p1Picks { 
            left: 20px; 
            top: 120px;
            border-color: #ff6464;
            box-shadow: 0 0 15px rgba(255, 100, 100, 0.3);
        }

        #p2Picks { 
            right: 20px; 
            top: 20px;
            border-color: #6464ff;
            box-shadow: 0 0 15px rgba(100, 100, 255, 0.3);
        }

        .button {
            padding: 14px 28px;
            background: linear-gradient(135deg, var(--primary-color), #0099cc);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            margin: 12px;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            font-family: 'Noto Sans KR', sans-serif;
        }

        .button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .button:hover {
            background: linear-gradient(135deg, #00b4d8, var(--primary-color));
            box-shadow: 0 6px 25px rgba(0, 212, 255, 0.5);
            transform: translateY(-2px);
        }

        .button:hover::before {
            left: 100%;
        }

        .button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 212, 255, 0.3);
        }

        .button.secondary {
            background: linear-gradient(135deg, var(--secondary-color), #cc5500);
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
        }

        .button.secondary:hover {
            background: linear-gradient(135deg, #ff8a65, var(--secondary-color));
            box-shadow: 0 6px 25px rgba(255, 107, 53, 0.5);
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 200;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            justify-content: center;
            align-items: center;
            animation: modalFadeIn 0.3s ease-out;
        }

        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            margin: auto;
            padding: 30px;
            border: 2px solid var(--border-glow);
            border-radius: 20px;
            width: 90%;
            max-width: 700px;
            text-align: center;
            box-shadow: 0 10px 50px rgba(0, 212, 255, 0.3);
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from { transform: scale(0.7) translateY(50px); opacity: 0; }
            to { transform: scale(1) translateY(0); opacity: 1; }
        }

        .modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            animation: shimmer 2s ease-in-out infinite;
        }

        .modal-content h2 {
            color: var(--accent-color);
            margin-top: 0;
            margin-bottom: 20px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        .modal-content p {
            margin-bottom: 16px;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .close-button {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            font-size: 1.5em;
            color: var(--text-secondary);
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-button:hover {
            color: var(--danger-color);
        }

        .planet-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            text-align: left;
            margin-top: 20px;
        }

        .planet-info-item {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .planet-info-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .planet-info-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.2);
            border-color: var(--border-glow);
        }

        .planet-info-item:hover::before {
            opacity: 1;
        }

        .planet-info-item h4 {
            margin-top: 0;
            margin-bottom: 12px;
            color: var(--accent-color);
            font-family: 'Orbitron', sans-serif;
            font-weight: 600;
        }

        .planet-info-item p {
            font-size: 0.9em;
            margin-bottom: 6px;
            color: var(--text-secondary);
        }

        .planet-info-item .planet-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            float: right;
            margin-left: 15px;
            border: 2px solid var(--border-glow);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        .fun-fact {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 107, 53, 0.1));
            padding: 12px;
            border-radius: 10px;
            margin-top: 10px;
            border-left: 4px solid var(--accent-color);
            font-style: italic;
            color: var(--text-primary);
        }

        #startScreen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 150;
            width: 90%;
            max-width: 650px;
            text-align: center;
        }

        #startScreen h1 {
            color: var(--accent-color);
            font-size: 2.5em;
            margin-bottom: 15px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            animation: titleGlow 3s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            from { text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
            to { text-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
        }

        #startScreen p {
            color: var(--text-secondary);
            font-size: 1.1em;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        #modeSelectContainer {
            margin: 20px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            font-size: 1.1em;
            color: var(--text-primary);
            font-weight: 500;
        }

        #modeSelect {
            padding: 12px 16px;
            border-radius: 10px;
            border: 2px solid var(--border-glow);
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            color: var(--text-primary);
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Noto Sans KR', sans-serif;
        }

        #modeSelect:hover {
            border-color: var(--primary-color);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        #modeSelect option {
            background: var(--card-bg);
            color: var(--text-primary);
        }

        #modeDescription {
            margin: 15px 0 25px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.95em;
            color: var(--text-secondary);
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.4;
        }

        .tutorial-section {
            background: rgba(255, 255, 255, 0.03);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 4px solid var(--primary-color);
        }

        .tutorial-section h3 {
            color: var(--primary-color);
            margin-bottom: 12px;
            font-family: 'Orbitron', sans-serif;
        }

        .tutorial-step {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .tutorial-step-number {
            background: var(--primary-color);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 12px;
            font-size: 0.8em;
        }

        .comparison-chart {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .chart-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chart-item h5 {
            color: var(--accent-color);
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .chart-bar {
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 5px 0;
        }

        .chart-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            border-radius: 10px;
            transition: width 1s ease-out;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            #startScreen h1 { font-size: 2em; }
            .modal-content { padding: 20px; max-height: 80vh; }
            .planet-info-grid { grid-template-columns: 1fr; gap: 15px; }
            .game-ui-element { padding: 8px 12px; font-size: 0.9em; }
            #powerBarContainer { width: 220px; height: 32px; }
            #draftInfoPanel { max-width: 350px; bottom: 20px; }
            .comparison-chart { grid-template-columns: 1fr; }
            .tutorial-step { flex-direction: column; text-align: center; }
            .tutorial-step-number { margin: 0 0 8px 0; }
        }

        @media (max-width: 480px) {
            #startScreen h1 { font-size: 1.6em; }
            .modal-content { padding: 15px; }
            .button { padding: 10px 20px; font-size: 0.9em; }
            .game-ui-element { padding: 6px 10px; font-size: 0.8em; }
            #powerBarContainer { width: 180px; height: 28px; }
            .player-picks-ui img { width: 24px; height: 24px; }
        }

        /* Loading Animation */
        .loading-spinner {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>솔라 시스템 마블 - 태양계 학습 게임</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #00d4ff;
            --secondary-color: #ff6b35;
            --accent-color: #ffd700;
            --dark-bg: #0a0a15;
            --darker-bg: #050508;
            --card-bg: rgba(15, 25, 45, 0.95);
            --glass-bg: rgba(255, 255, 255, 0.1);
            --text-primary: #ffffff;
            --text-secondary: #b8c6db;
            --success-color: #4caf50;
            --warning-color: #ff9800;
            --danger-color: #f44336;
            --border-glow: rgba(0, 212, 255, 0.3);
            --shadow-glow: 0 0 30px rgba(0, 212, 255, 0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--dark-bg) 0%, var(--darker-bg) 100%);
            color: var(--text-primary);
            font-family: 'Noto Sans KR', sans-serif;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(120, 219, 255, 0.3) 0%, transparent 50%);
            animation: backgroundMove 20s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes backgroundMove {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(1deg); }
        }

        #gameCanvas {
            background: transparent;
            border: 2px solid var(--border-glow);
            border-radius: 16px;
            box-shadow: var(--shadow-glow), inset 0 0 20px rgba(0, 0, 0, 0.3);
            display: block;
            transition: all 0.3s ease;
        }

        #gameCanvas:hover {
            box-shadow: 0 0 50px rgba(0, 212, 255, 0.4), inset 0 0 20px rgba(0, 0, 0, 0.3);
        }

        .ui-panel {
            background: var(--card-bg);
            backdrop-filter: blur(15px);
            border: 1px solid var(--border-glow);
            border-radius: 16px;
            padding: 20px;
            box-shadow: var(--shadow-glow);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .ui-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            animation: shimmer 2s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        .ui-panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 40px rgba(0, 212, 255, 0.3);
        }

        #draftInfoPanel {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 420px;
            min-height: 140px;
            display: none;
            z-index: 100;
            animation: slideUpIn 0.3s ease-out;
        }

        @keyframes slideUpIn {
            from { transform: translateX(-50%) translateY(20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        #draftInfoPanel h3 {
            margin: 0 0 12px 0;
            color: var(--accent-color);
            font-size: 1.2em;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        #draftInfoPanel p {
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .stat-bar-container {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.8em;
        }

        .stat-bar-label {
            width: 50px;
            margin-right: 8px;
            color: var(--text-secondary);
            font-weight: 500;
            text-align: left;
        }

        .stat-bar {
            flex-grow: 1;
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }

        .stat-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
            animation: statShimmer 2s ease-in-out infinite;
        }

        @keyframes statShimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(200%); }
        }

        .stat-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success-color), #66bb6a);
            border-radius: 5px;
            transition: width 0.5s ease-out;
            position: relative;
            overflow: hidden;
        }

        .stat-bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: fillGlow 1.5s ease-in-out infinite;
        }

        @keyframes fillGlow {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        .stat-bar-value {
            width: 40px;
            text-align: right;
            margin-left: 8px;
            color: var(--text-primary);
            font-weight: 500;
        }

        #powerBarContainer {
            position: fixed;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            width: 280px;
            height: 36px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 18px;
            border: 2px solid var(--border-glow);
            padding: 4px;
            box-shadow: var(--shadow-glow);
            display: none;
            z-index: 100;
            animation: powerBarPulse 2s ease-in-out infinite alternate;
        }

        @keyframes powerBarPulse {
            from { box-shadow: 0 0 20px rgba(0, 212, 255, 0.3); }
            to { box-shadow: 0 0 30px rgba(0, 212, 255, 0.5); }
        }

        #powerBarFill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, var(--success-color), var(--warning-color), var(--danger-color));
            border-radius: 14px;
            transition: width 0.1s linear, box-shadow 0.1s linear;
            position: relative;
            overflow: hidden;
        }

        #powerBarFill::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: powerFillMove 1s ease-in-out infinite;
        }

        @keyframes powerFillMove {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        #powerBarText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--text-primary);
            font-size: 0.9em;
            font-weight: 700;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            font-family: 'Orbitron', monospace;
        }

        .game-ui-element {
            position: fixed;
            padding: 12px 18px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid var(--border-glow);
            box-shadow: var(--shadow-glow);
            font-size: 1em;
            z-index: 90;
            transition: all 0.3s ease;
        }

        .game-ui-element:hover {
            transform: scale(1.02);
            box-shadow: 0 0 25px rgba(0, 212, 255, 0.4);
        }

        #gameMessages {
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.1em;
            font-weight: 600;
            z-index: 120;
            text-align: center;
            min-width: 200px;
            animation: messageSlide 0.5s ease-out;
        }

        @keyframes messageSlide {
            from { transform: translateX(-50%) translateY(-20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        #turnIndicator {
            top: 20px;
            left: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: var(--accent-color);
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        #aliveCount {
            top: 70px;
            left: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 500;
        }

        #instructions {
            bottom: 20px;
            right: 20px;
            font-size: 0.8em;
            color: var(--text-secondary);
            text-align: right;
            max-width: 250px;
            line-height: 1.3;
        }

        .player-picks-ui {
            position: fixed;
            padding: 8px 12px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            border: 1px solid var(--border-glow);
            font-size: 0.9em;
            display: flex;
            align-items: center;
            z-index: 90;
            box-shadow: var(--shadow-glow);
            transition: all 0.3s ease;
        }

        .player-picks-ui:hover {
            transform: scale(1.05);
        }

        .player-picks-ui img {
            width: 28px;
            height: 28px;
            margin-left: 6px;
            border-radius: 50%;
            border: 2px solid var(--border-glow);
            transition: transform 0.2s ease;
        }

        .player-picks-ui img:hover {
            transform: scale(1.1);
        }

        #p1Picks { 
            left: 20px; 
            top: 120px;
            border-color: #ff6464;
            box-shadow: 0 0 15px rgba(255, 100, 100, 0.3);
        }

        #p2Picks { 
            right: 20px; 
            top: 20px;
            border-color: #6464ff;
            box-shadow: 0 0 15px rgba(100, 100, 255, 0.3);
        }

        .button {
            padding: 14px 28px;
            background: linear-gradient(135deg, var(--primary-color), #0099cc);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            margin: 12px;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            font-family: 'Noto Sans KR', sans-serif;
        }

        .button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .button:hover {
            background: linear-gradient(135deg, #00b4d8, var(--primary-color));
            box-shadow: 0 6px 25px rgba(0, 212, 255, 0.5);
            transform: translateY(-2px);
        }

        .button:hover::before {
            left: 100%;
        }

        .button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 212, 255, 0.3);
        }

        .button.secondary {
            background: linear-gradient(135deg, var(--secondary-color), #cc5500);
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
        }

        .button.secondary:hover {
            background: linear-gradient(135deg, #ff8a65, var(--secondary-color));
            box-shadow: 0 6px 25px rgba(255, 107, 53, 0.5);
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 200;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            justify-content: center;
            align-items: center;
            animation: modalFadeIn 0.3s ease-out;
        }

        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            margin: auto;
            padding: 30px;
            border: 2px solid var(--border-glow);
            border-radius: 20px;
            width: 90%;
            max-width: 700px;
            text-align: center;
            box-shadow: 0 10px 50px rgba(0, 212, 255, 0.3);
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from { transform: scale(0.7) translateY(50px); opacity: 0; }
            to { transform: scale(1) translateY(0); opacity: 1; }
        }

        .modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            animation: shimmer 2s ease-in-out infinite;
        }

        .modal-content h2 {
            color: var(--accent-color);
            margin-top: 0;
            margin-bottom: 20px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        .modal-content p {
            margin-bottom: 16px;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .close-button {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            font-size: 1.5em;
            color: var(--text-secondary);
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-button:hover {
            color: var(--danger-color);
        }

        .planet-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            text-align: left;
            margin-top: 20px;
        }

        .planet-info-item {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .planet-info-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .planet-info-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.2);
            border-color: var(--border-glow);
        }

        .planet-info-item:hover::before {
            opacity: 1;
        }

        .planet-info-item h4 {
            margin-top: 0;
            margin-bottom: 12px;
            color: var(--accent-color);
            font-family: 'Orbitron', sans-serif;
            font-weight: 600;
        }

        .planet-info-item p {
            font-size: 0.9em;
            margin-bottom: 6px;
            color: var(--text-secondary);
        }

        .planet-info-item .planet-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            float: right;
            margin-left: 15px;
            border: 2px solid var(--border-glow);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        .fun-fact {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 107, 53, 0.1));
            padding: 12px;
            border-radius: 10px;
            margin-top: 10px;
            border-left: 4px solid var(--accent-color);
            font-style: italic;
            color: var(--text-primary);
        }

        #startScreen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 150;
            width: 90%;
            max-width: 650px;
            text-align: center;
        }

        #startScreen h1 {
            color: var(--accent-color);
            font-size: 2.5em;
            margin-bottom: 15px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            animation: titleGlow 3s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            from { text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
            to { text-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
        }

        #startScreen p {
            color: var(--text-secondary);
            font-size: 1.1em;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        #modeSelectContainer {
            margin: 20px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            font-size: 1.1em;
            color: var(--text-primary);
            font-weight: 500;
        }

        #modeSelect {
            padding: 12px 16px;
            border-radius: 10px;
            border: 2px solid var(--border-glow);
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            color: var(--text-primary);
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Noto Sans KR', sans-serif;
        }

        #modeSelect:hover {
            border-color: var(--primary-color);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        #modeSelect option {
            background: var(--card-bg);
            color: var(--text-primary);
        }

        #modeDescription {
            margin: 15px 0 25px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.95em;
            color: var(--text-secondary);
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.4;
        }

        .tutorial-section {
            background: rgba(255, 255, 255, 0.03);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 4px solid var(--primary-color);
        }

        .tutorial-section h3 {
            color: var(--primary-color);
            margin-bottom: 12px;
            font-family: 'Orbitron', sans-serif;
        }

        .tutorial-step {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .tutorial-step-number {
            background: var(--primary-color);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 12px;
            font-size: 0.8em;
        }

        .comparison-chart {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .chart-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chart-item h5 {
            color: var(--accent-color);
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .chart-bar {
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 5px 0;
        }

        .chart-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            border-radius: 10px;
            transition: width 1s ease-out;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            #startScreen h1 { font-size: 2em; }
            .modal-content { padding: 20px; max-height: 80vh; }
            .planet-info-grid { grid-template-columns: 1fr; gap: 15px; }
            .game-ui-element { padding: 8px 12px; font-size: 0.9em; }
            #powerBarContainer { width: 220px; height: 32px; }
            #draftInfoPanel { max-width: 350px; bottom: 20px; }
            .comparison-chart { grid-template-columns: 1fr; }
            .tutorial-step { flex-direction: column; text-align: center; }
            .tutorial-step-number { margin: 0 0 8px 0; }
        }

        @media (max-width: 480px) {
            #startScreen h1 { font-size: 1.6em; }
            .modal-content { padding: 15px; }
            .button { padding: 10px 20px; font-size: 0.9em; }
            .game-ui-element { padding: 6px 10px; font-size: 0.8em; }
            #powerBarContainer { width: 180px; height: 28px; }
            .player-picks-ui img { width: 24px; height: 24px; }
        }

        /* Loading Animation */
        .loading-spinner {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #00b4d8;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="turnIndicator" class="game-ui-element" style="display: none;">
        <i class="fas fa-user"></i> P1의 턴
    </div>
    
    <div id="aliveCount" class="game-ui-element" style="display: none;">
        <i class="fas fa-chart-bar"></i> P1: 3 | P2: 3
    </div>
    
    <div id="instructions" class="game-ui-element" style="display: none;">
        <i class="fas fa-info-circle"></i> 행성 클릭 후 반대방향으로 드래그<br>
        <i class="fas fa-keyboard"></i> SPACE: 최대 파워 | R: 재시작<br>
        <i class="fas fa-question-circle"></i> H: 도움말
    </div>

    <div id="draftInfoPanel" class="ui-panel">
        <h3 id="draftPlanetName">
            <i class="fas fa-globe"></i> 행성 이름
        </h3>
        <p id="draftPlanetDesc">행성 설명이 여기에 표시됩니다.</p>
        <div class="stat-bar-container">
            <span class="stat-bar-label">크기:</span>
            <div class="stat-bar">
                <div id="draftStatSize" class="stat-bar-fill"></div>
            </div>
            <span id="draftStatSizeValue" class="stat-bar-value">0</span>
        </div>
        <div class="stat-bar-container">
            <span class="stat-bar-label">밀도:</span>
            <div class="stat-bar">
                <div id="draftStatDensity" class="stat-bar-fill" style="background: linear-gradient(90deg, #8A2BE2, #9932CC);"></div>
            </div>
            <span id="draftStatDensityValue" class="stat-bar-value">0</span>
        </div>
        <div class="stat-bar-container">
            <span class="stat-bar-label">중력:</span>
            <div class="stat-bar">
                <div id="draftStatGravity" class="stat-bar-fill" style="background: linear-gradient(90deg, #00BFFF, #1E90FF);"></div>
            </div>
            <span id="draftStatGravityValue" class="stat-bar-value">0</span>
        </div>
    </div>

    <div id="powerBarContainer">
        <div id="powerBarFill"></div>
        <div id="powerBarText">
            <i class="fas fa-bolt"></i> 파워: 0%
        </div>
    </div>

    <div id="gameMessages" class="game-ui-element" style="display: none;">
        <i class="fas fa-comment"></i> 게임 메시지
    </div>

    <div id="p1Picks" class="player-picks-ui" style="display:none;">
        <i class="fas fa-user" style="color: #ff6464;"></i> P1 선택:
    </div>
    
    <div id="p2Picks" class="player-picks-ui" style="display:none;">
        <i class="fas fa-user" style="color: #6464ff;"></i> P2 선택:
    </div>
    
    <!-- Game End Modal -->
    <div id="endGameModal" class="modal">
        <div class="modal-content">
            <button class="close-button" onclick="document.getElementById('endGameModal').style.display='none'">
                <i class="fas fa-times"></i>
            </button>
            <h2 id="winnerMessage">
                <i class="fas fa-trophy"></i> 승리 메시지
            </h2>
            <p id="congratsMessage">축하 메시지</p>
            <button id="restartButton" class="button">
                <i class="fas fa-redo"></i> 다시 플레이 (R)
            </button>
        </div>
    </div>

    <!-- Tutorial Modal -->
    <div id="tutorialModal" class="modal">
        <div class="modal-content">
            <button class="close-button" onclick="document.getElementById('tutorialModal').style.display='none'">
                <i class="fas fa-times"></i>
            </button>
            <h2><i class="fas fa-graduation-cap"></i> 게임 설명서</h2>
            
            <div class="tutorial-section">
                <h3><i class="fas fa-gamepad"></i> 게임 목표</h3>
                <p>태양계의 행성들을 이용해 상대방의 행성을 모두 맵 밖으로 밀어내거나, 컬링 모드에서 높은 점수를 획득하세요!</p>
            </div>

            <div class="tutorial-section">
                <h3><i class="fas fa-mouse"></i> 조작 방법</h3>
                <div class="tutorial-step">
                    <div class="tutorial-step-number">1</div>
                    <div>자신의 행성을 마우스로 클릭하여 선택</div>
                </div>
                <div class="tutorial-step">
                    <div class="tutorial-step-number">2</div>
                    <div>발사하고 싶은 반대 방향으로 드래그</div>
                </div>
                <div class="tutorial-step">
                    <div class="tutorial-step-number">3</div>
                    <div>마우스를 놓아서 행성 발사</div>
                </div>
                <div class="tutorial-step">
                    <div class="tutorial-step-number">4</div>
                    <div>SPACE 키로 최대 파워 설정 가능</div>
                </div>
            </div>

            <div class="tutorial-section">
                <h3><i class="fas fa-star"></i> 게임 모드</h3>
                <p><strong>알까기 모드:</strong> 상대방의 모든 행성을 맵 밖으로 밀어내면 승리</p>
                <p><strong>컬링 모드:</strong> 3라운드 동안 중앙 원에 가까이 행성을 위치시켜 점수 획득</p>
            </div>

            <div class="tutorial-section">
                <h3><i class="fas fa-lightbulb"></i> 전략 팁</h3>
                <p>• 큰 행성은 무겁고 강력하지만 움직이기 어려움</p>
                <p>• 작은 행성은 빠르게 움직이지만 충돌시 밀려남</p>
                <p>• 중력을 이용해 궤도를 활용하세요</p>
                <p>• 태양의 강한 중력을 전략적으로 활용</p>
            </div>

            <button class="button" onclick="document.getElementById('tutorialModal').style.display='none'">
                <i class="fas fa-check"></i> 이해했습니다
            </button>
        </div>
    </div>

    <!-- Planet Info Modal -->
    <div id="planetInfoModal" class="modal">
        <div class="modal-content">
            <button class="close-button" onclick="document.getElementById('planetInfoModal').style.display='none'">
                <i class="fas fa-times"></i>
            </button>
            <h2><i class="fas fa-globe-americas"></i> 태양계 행성 학습</h2>
            
            <div class="comparison-chart">
                <div class="chart-item">
                    <h5>크기 비교 (지구=1)</h5>
                    <div class="chart-bar">
                        <div class="chart-fill" style="width: 100%;" data-planet="earth"></div>
                    </div>
                    <small>지구 기준</small>
                </div>
                <div class="chart-item">
                    <h5>거리 비교 (AU)</h5>
                    <div class="chart-bar">
                        <div class="chart-fill" style="width: 100%;" data-planet="distance"></div>
                    </div>
                    <small>태양으로부터</small>
                </div>
            </div>

            <div id="planetInfoGrid" class="planet-info-grid"></div>
            
            <button id="closePlanetInfoBtn" class="button">
                <i class="fas fa-arrow-left"></i> 돌아가기
            </button>
        </div>
    </div>

    <!-- Quiz Modal -->
    <div id="quizModal" class="modal">
        <div class="modal-content">
            <button class="close-button" onclick="document.getElementById('quizModal').style.display='none'">
                <i class="fas fa-times"></i>
            </button>
            <h2><i class="fas fa-brain"></i> 태양계 퀴즈</h2>
            <div id="quizContent">
                <div id="quizQuestion"></div>
                <div id="quizOptions"></div>
                <div id="quizResult" style="display: none;"></div>
                <div id="quizScore">점수: <span id="currentScore">0</span> / <span id="totalQuestions">0</span></div>
                <button id="nextQuizBtn" class="button" style="display: none;" onclick="nextQuiz()">
                    <i class="fas fa-arrow-right"></i> 다음 문제
                </button>
                <button id="startQuizBtn" class="button" onclick="startQuiz()">
                    <i class="fas fa-play"></i> 퀴즈 시작
                </button>
            </div>
        </div>
    </div>

    <!-- Debug Panel -->
    <div id="debugPanel" style="display: none; position: fixed; top: 10px; right: 300px; background: rgba(0,0,0,0.8); color: white; padding: 10px; border-radius: 8px; font-family: monospace; font-size: 12px; z-index: 200; max-width: 250px;">
        <h4 style="margin: 0 0 8px 0; color: #00ff00;">🔧 디버그 모드</h4>
        <div id="debugInfo"></div>
        <button onclick="toggleDebugMode()" style="margin-top: 8px; padding: 4px 8px; background: #333; color: white; border: 1px solid #666; border-radius: 4px; cursor: pointer;">
            디버그 모드 끄기
        </button>
    </div>

    <!-- Learning Progress Tracker -->
    <div id="learningProgress" style="display: none; position: fixed; top: 20px; right: 20px; background: var(--card-bg); backdrop-filter: blur(15px); border: 1px solid var(--border-glow); border-radius: 12px; padding: 15px; color: white; z-index: 150; max-width: 250px;">
        <h4 style="margin: 0 0 10px 0; color: var(--accent-color);">📚 학습 진행도</h4>
        <div id="progressBars"></div>
        <div style="margin-top: 10px; font-size: 12px; color: var(--text-secondary);">
            총 플레이 시간: <span id="totalPlayTime">0분</span>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="ui-panel">
        <h1><i class="fas fa-rocket"></i> 태양계 알까기</h1>
        <p>우주를 배경으로 펼쳐지는 전략 시뮬레이션 게임!<br>
        실제 태양계 행성들의 물리 법칙을 체험하며 전략적 사고력을 기르세요.</p>
        
        <div id="modeSelectContainer">
            <label for="modeSelect">
                <i class="fas fa-cog"></i> 게임 모드:
            </label>
            <select id="modeSelect">
                <option value="alggagi" selected>🎯 알까기 모드</option>
                <option value="culling">🥌 컬링 모드</option>
            </select>
        </div>
        
        <div id="modeDescription">
            행성들을 이용해 상대방의 행성을 모두 맵 밖으로 밀어내세요.
        </div>
        
        <button id="startGameBtn" class="button">
            <i class="fas fa-play"></i> 게임 시작
        </button>
        
        <button id="learnPlanetsBtn" class="button secondary">
            <i class="fas fa-book"></i> 행성 학습
        </button>
        
        <button id="tutorialBtn" class="button secondary">
            <i class="fas fa-question-circle"></i> 게임 설명
        </button>
        
        <button id="quizBtn" class="button secondary">
            <i class="fas fa-brain"></i> 태양계 퀴즈
        </button>
        
        <button id="debugModeBtn" class="button secondary" style="font-size: 0.8em;">
            <i class="fas fa-bug"></i> 디버그 모드
        </button>
    </div>

    <script type="module">
        // Enhanced Solar System Educational Game
        // Improved with modern UI/UX, debugging, and educational content

        // --- Constants and Global Variables ---
        let canvas, ctx;
        let spaceBackground;
        let currentGameState = null;
        let gameRunningState = "menu";
        let isDragging = false;
        let dragJustStarted = false;
        let selectedPlanet = null;
        let startDragPos = { x: 0, y: 0 };
        let trajectoryPoints = [];
        let lastTime = 0;
        let powerAmount = 0;
        let isGameOver = false;
        let gameLoop = null;
        let draftState = null;
        let draftHandleClick = null;
        let draftHandleMouseMove = null;
        let draftHandleKeyDown = null;
        const pickedPlanets = { P1: [], P2: [] };
        let npcPlanets = [];
        let uiInstructions;
        let debugMode = false;

        // --- Educational Quiz System ---
        const quizQuestions = [
            {
                question: "태양계에서 가장 큰 행성은 무엇인가요?",
                options: ["지구", "목성", "토성", "해왕성"],
                correct: 1,
                explanation: "목성은 태양계에서 가장 큰 행성으로, 지구보다 11배나 큽니다!",
                category: "크기"
            },
            {
                question: "태양에서 가장 가까운 행성은?",
                options: ["금성", "수성", "지구", "화성"],
                correct: 1,
                explanation: "수성은 태양에서 가장 가까운 행성입니다. 하지만 금성이 더 뜨거워요!",
                category: "거리"
            },
            {
                question: "어떤 행성이 거꾸로 자전하나요?",
                options: ["지구", "화성", "금성", "목성"],
                correct: 2,
                explanation: "금성은 다른 행성들과 반대 방향으로 자전합니다. 태양이 서쪽에서 떠요!",
                category: "운동"
            },
            {
                question: "토성의 가장 특별한 특징은?",
                options: ["가장 크다", "아름다운 고리", "가장 빠르다", "가장 뜨겁다"],
                correct: 1,
                explanation: "토성은 아름다운 고리로 유명합니다. 수십억 개의 얼음과 바위 조각으로 이루어져 있어요!",
                category: "특징"
            },
            {
                question: "지구의 자전축은 몇 도 기울어져 있나요?",
                options: ["0도", "23.4도", "45도", "90도"],
                correct: 1,
                explanation: "지구의 자전축은 23.4도 기울어져 있어서 계절이 생깁니다!",
                category: "지구"
            }
        ];

        let currentQuiz = {
            questions: [],
            currentIndex: 0,
            score: 0,
            categories: {}
        };

        // --- Learning Progress Tracking ---
        let learningProgress = {
            startTime: null,
            totalPlayTime: 0,
            planetsLearned: new Set(),
            quizzesTaken: 0,
            correctAnswers: 0,
            gamesPlayed: 0,
            strategiesUsed: new Set()
        };

        // --- Enhanced Educational Planet Data ---
        const planets_data_template = [
            {
                "name": "태양", "color": '#FFFF00', "size": 60, "mass": 150, "id": "sun",
                "texture_colors": { base: '#FFD700', corona: ['#FFFACD', '#FFE4B5', '#FFDEAD'], spots: ['#FFA500', '#FF8C00']},
                "desc": "태양계의 중심에 있는 항성으로, 모든 행성들이 태양 주위를 공전합니다.",
                "type": "star", axialTiltDeg: 7.25, orbitalPeriod: 0, density: 1.41, surfaceGravity: 27.9, rotationPeriod: 0.0001,
                "distanceFromSun": 0, "temperature": 5778, "moons": 0,
                "funFact": "태양은 매초 400만 톤의 질량을 에너지로 변환합니다! 이는 핵융합 반응 때문입니다.",
                "educationalNote": "태양의 중력은 지구보다 28배나 강해서, 만약 태양에 떨어진다면 엄청난 속도로 가속됩니다.",
                "gameStrategy": "태양의 강력한 중력을 이용해 행성의 궤도를 바꿀 수 있습니다. 태양 근처로 행성을 보내면 중력 가속을 받아 더 빠르게 움직입니다."
            },
            {
                "name": "수성", "color": '#A9A9A9', "size": 10, "mass": 0.06, "id": "mercury",
                "texture_colors": { base: '#808080', craters_dark: '#606060', craters_light: '#A0A0A0'},
                "desc": "태양에 가장 가까운 행성으로 작고 빠르며, 표면은 크레이터로 가득합니다.",
                "type": "rocky_cratered", axialTiltDeg: 0.03, orbitalPeriod: 88, density: 5.43, surfaceGravity: 0.38, rotationPeriod: 0.005,
                "distanceFromSun": 0.39, "temperature": 167, "moons": 0,
                "funFact": "수성의 하루는 지구의 176일과 같습니다! 자전이 매우 느리기 때문입니다.",
                "educationalNote": "수성은 밀도가 높아서 작지만 무겁습니다. 이는 큰 철 핵을 가지고 있기 때문입니다.",
                "gameStrategy": "수성은 작지만 밀도가 높아 의외로 무겁습니다. 다른 행성을 밀어낼 때 생각보다 큰 힘을 발휘할 수 있어요."
            },
            {
                "name": "금성", "color": '#F5DEB3', "size": 20, "mass": 0.82, "id": "venus",
                "texture_colors": { base: '#EEDC82', clouds: ['#FFF8DC', '#FAF0E6', '#FFEBCD']},
                "desc": "두꺼운 황산 구름으로 덮여 있으며, 온실효과로 인해 태양계에서 가장 뜨거운 행성입니다.",
                "type": "rocky_cloudy", axialTiltDeg: 177.4, orbitalPeriod: 225, density: 5.24, surfaceGravity: 0.90, rotationPeriod: 0.01,
                "distanceFromSun": 0.72, "temperature": 464, "moons": 0,
                "funFact": "금성은 거꾸로 자전합니다! 태양이 서쪽에서 뜨고 동쪽으로 집니다.",
                "educationalNote": "금성의 대기압은 지구의 90배나 됩니다. 마치 깊은 바다 밑에 있는 것과 같죠!",
                "gameStrategy": "금성은 크기와 질량이 지구와 비슷해 균형 잡힌 플레이가 가능합니다. 공격과 수비 모두에 적합해요."
            },
            {
                "name": "지구", "color": '#6495ED', "size": 22, "mass": 1.0, "id": "earth",
                "texture_colors": { ocean: '#4682B4', land: ['#228B22', '#8FBC8F', '#D2B48C'], cloud: 'rgba(240,248,255,0.7)'},
                "desc": "우리가 살고 있는 행성으로, 액체 상태의 물과 생명체가 존재하는 유일한 행성입니다.",
                "type": "earth-like", axialTiltDeg: 23.44, orbitalPeriod: 365, density: 5.51, surfaceGravity: 1.00, rotationPeriod: 0.003,
                "distanceFromSun": 1.0, "temperature": 15, "moons": 1,
                "funFact": "지구는 초속 30km로 태양 주위를 돌고 있습니다. 1년 동안 9억 4천만 km를 여행해요!",
                "educationalNote": "지구의 자전축이 23.4도 기울어져 있어서 계절이 생깁니다.",
                "gameStrategy": "지구는 게임의 기준이 되는 행성입니다. 모든 스탯이 표준적이어서 초보자가 사용하기 좋아요."
            },
            {
                "name": "화성", "color": '#CD5C5C', "size": 15, "mass": 0.11, "id": "mars",
                "texture_colors": { base: '#BC8F8F', dust: ['#D2B48C', '#CD853F'], ice_caps: '#FFFFFF', craters: '#A0522D'},
                "desc": "붉은 행성이라 불리며, 극지방에 얼음이 있고 과거에 물이 흘렀던 흔적이 발견됩니다.",
                "type": "rocky_ice_caps", axialTiltDeg: 25.19, orbitalPeriod: 687, density: 3.93, surfaceGravity: 0.38, rotationPeriod: 0.0031,
                "distanceFromSun": 1.52, "temperature": -65, "moons": 2,
                "funFact": "화성의 하루는 지구와 거의 같아요! 24시간 37분입니다.",
                "educationalNote": "화성에서는 먼지 폭풍이 행성 전체를 덮을 수 있습니다. 몇 달 동안 지속되기도 해요!",
                "gameStrategy": "화성은 작고 가벼워서 빠르게 움직일 수 있습니다. 기습 공격이나 정밀한 조준에 적합해요."
            },
            {
                "name": "목성", "color": '#DEB887', "size": 45, "mass": 318, "id": "jupiter",
                "texture_colors": { base: '#D2B48C', bands_light: ['#F5DEB3', '#FFEBCD'], bands_dark: ['#A0522D', '#8B4513'], spot: '#C19A6B'},
                "desc": "태양계에서 가장 큰 가스 행성으로, 대적점이라는 거대한 폭풍이 수백 년째 지속되고 있습니다.",
                "type": "gas_giant_bands_spot", axialTiltDeg: 3.13, orbitalPeriod: 4333, density: 1.33, surfaceGravity: 2.53, rotationPeriod: 0.0015,
                "distanceFromSun": 5.2, "temperature": -110, "moons": 95,
                "funFact": "목성의 대적점은 지구 3개가 들어갈 만큼 큰 폭풍입니다!",
                "educationalNote": "목성은 태양계의 '청소부' 역할을 합니다. 강한 중력으로 소행성들을 끌어당겨 지구를 보호해요.",
                "gameStrategy": "목성은 가장 크고 무거운 행성입니다. 움직이기는 어렵지만 한 번 움직이면 막을 수 없는 파괴력을 가집니다!"
            },
            {
                "name": "토성", "color": '#F0E68C', "size": 40, "mass": 95, "id": "saturn",
                "texture_colors": { body: '#EEE8AA', rings: ['rgba(210,180,140,0.7)', 'rgba(240,220,190,0.6)', 'rgba(188,150,120,0.5)']},
                "desc": "아름다운 고리로 유명한 가스 행성입니다. 밀도가 낮아서 물에 뜰 수 있습니다.",
                "type": "gas_giant_rings", axialTiltDeg: 26.73, orbitalPeriod: 10759, density: 0.69, surfaceGravity: 1.07, rotationPeriod: 0.0016,
                "distanceFromSun": 9.5, "temperature": -140, "moons": 146,
                "funFact": "토성의 고리는 수십억 개의 얼음과 바위 조각으로 이루어져 있어요!",
                "educationalNote": "토성은 물보다 가볍습니다. 거대한 바다가 있다면 토성이 둥둥 떠다닐 거예요!",
                "gameStrategy": "토성은 크지만 밀도가 낮아 목성보다 가벼워요. 고리가 있어서 회전 효과가 독특합니다."
            },
            {
                "name": "천왕성", "color": '#AFEEEE', "size": 30, "mass": 14.5, "id": "uranus",
                "texture_colors": { body: '#ADD8E6', atmosphere: ['#B0E0E6', '#AFEEEE'], rings_faint: 'rgba(200,220,220,0.3)'},
                "desc": "옆으로 누워서 자전하는 독특한 얼음 행성입니다. 메탄 때문에 푸른빛을 띱니다.",
                "type": "ice_giant_rings", axialTiltDeg: 97.77, orbitalPeriod: 30687, density: 1.27, surfaceGravity: 0.89, rotationPeriod: 0.0025,
                "distanceFromSun": 19.2, "temperature": -195, "moons": 27,
                "funFact": "천왕성의 자전축은 98도 기울어져 있어서 옆으로 굴러다니는 것 같아요!",
                "educationalNote": "천왕성의 극지방은 42년 동안 계속 겨울이거나 여름입니다.",
                "gameStrategy": "천왕성은 특이한 자전축 때문에 예측하기 어려운 움직임을 보입니다. 고급 전략에 활용해보세요."
            },
            {
                "name": "해왕성", "color": '#6495ED', "size": 28, "mass": 17, "id": "neptune",
                "texture_colors": { body: '#4169E1', spots_clouds: ['#5F9EA0', '#000080', 'rgba(173,216,230,0.4)']},
                "desc": "태양계에서 가장 바람이 강한 행성으로, 시속 2000km의 바람이 불기도 합니다.",
                "type": "ice_giant_spot_clouds", axialTiltDeg: 28.32, orbitalPeriod: 60190, density: 1.64, surfaceGravity: 1.14, rotationPeriod: 0.0023,
                "distanceFromSun": 30.1, "temperature": -200, "moons": 16,
                "funFact": "해왕성에서는 다이아몬드 비가 내릴 수도 있어요! 높은 압력과 온도 때문입니다.",
                "educationalNote": "해왕성은 수학으로 발견된 첫 번째 행성입니다. 천왕성의 궤도 이상을 설명하려다 발견했어요!",
                "gameStrategy": "해왕성은 강한 바람을 가진 행성입니다. 게임에서는 충돌 후 더 멀리 튕겨나가는 특성이 있어요."
            }
        ];

        // --- Enhanced Physics Engine ---
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : {r:255, g:255, b:255};
        }

        class Particle {
            constructor(x, y, color, size = 2, life = 30, vxOverride = null, vyOverride = null) {
                this.x = x;
                this.y = y;
                this.vx = vxOverride !== null ? vxOverride : (Math.random() - 0.5) * 4;
                this.vy = vyOverride !== null ? vyOverride : (Math.random() - 0.5) * 4;
                this.color = color;
                this.baseSize = size;
                this.life = life;
                this.age = 0;
                this.maxLife = life;
                this.damping = 0.97;
            }

            update(deltaTime) {
                this.x += this.vx * (deltaTime * 60);
                this.y += this.vy * (deltaTime * 60);
                this.vx *= Math.pow(this.damping, deltaTime * 60);
                this.vy *= Math.pow(this.damping, deltaTime * 60);
                this.age++;
                return this.age < this.maxLife;
            }

            draw(context) {
                const progress = this.age / this.maxLife;
                const alpha = Math.max(0, 1 - progress * progress);
                const currentSize = Math.max(0.5, this.baseSize * (1 - progress * 0.7));

                if (currentSize < 0.5 || alpha <= 0) return;

                const rgb = hexToRgb(this.color);
                context.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
                context.beginPath();
                context.arc(this.x, this.y, currentSize, 0, Math.PI * 2);
                context.fill();
            }
        }

        function detectCollision(p1, p2) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const distSq = dx * dx + dy * dy;
            const minDist = p1.size + p2.size;
            return distSq < minDist * minDist;
        }

        function resolveCollision(p1, p2, dt) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            let dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist === 0) {
                dist = 0.1;
            }
            
            const nx = dx / dist;
            const ny = dy / dist;
            
            const overlap = (p1.size + p2.size) - dist;
            if (overlap > 0) {
                const m1 = Math.max(0.1, p1.mass);
                const m2 = Math.max(0.1, p2.mass);
                const totalMass = m1 + m2;
                
                const p1Ratio = m2 / totalMass;
                const p2Ratio = m1 / totalMass;
                
                p1.x -= nx * overlap * p1Ratio * 0.5;
                p1.y -= ny * overlap * p1Ratio * 0.5;
                p2.x += nx * overlap * p2Ratio * 0.5;
                p2.y += ny * overlap * p2Ratio * 0.5;
            }
            
            const m1 = Math.max(0.1, p1.mass);
            const m2 = Math.max(0.1, p2.mass);
            
            const tx = -ny;
            const ty = nx;
            
            const v1n = p1.vx * nx + p1.vy * ny;
            const v1t = p1.vx * tx + p1.vy * ty;
            const v2n = p2.vx * nx + p2.vy * ny;
            const v2t = p2.vx * tx + p2.vy * ty;
            
            const e = 0.8;
            
            let v1nAfter = ((m1 - e * m2) * v1n + (1 + e) * m2 * v2n) / (m1 + m2);
            let v2nAfter = ((m2 - e * m1) * v2n + (1 + e) * m1 * v1n) / (m1 + m2);
            
            p1.vx = v1nAfter * nx + v1t * tx;
            p1.vy = v1nAfter * ny + v1t * ty;
            p2.vx = v2nAfter * nx + v2t * ty;
            p2.vy = v2nAfter * ny + v2t * ty;
            
            return {
                x: p1.x + nx * p1.size,
                y: p1.y + ny * p1.size,
                energy: Math.abs(v1nAfter - v1n) + Math.abs(v2nAfter - v2n)
            };
        }

        function applyGravity(p1, p2, dt, G = 0.1) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const distSq = dx * dx + dy * dy;
            if (distSq === 0) return;
            const dist = Math.sqrt(distSq);
            const minGravDist = p1.size + p2.size + 2;
            
            if (dist > minGravDist) {
                let gravityMult = 1;
                if (p1.type === 'star') gravityMult *= 2.5;
                if (p2.type === 'star') gravityMult *= 2.5;

                let forceMagnitude = G * gravityMult * (p1.mass * p2.mass) / distSq;
                const maxForceAllowed = 30;
                forceMagnitude = Math.min(forceMagnitude, maxForceAllowed);
                
                const forceX = forceMagnitude * dx / dist;
                const forceY = forceMagnitude * dy / dist;

                if (p1.mass > 0) {
                    p1.vx += forceX / p1.mass * dt;
                    p1.vy += forceY / p1.mass * dt;
                }
                if (p2.mass > 0) {
                    p2.vx -= forceX / p2.mass * dt;
                    p2.vy -= forceY / p2.mass * dt;
                }
            }
        }

        function createCollisionParticles(x, y, energy, color1, color2) {
            const particles = [];
            const numParticles = Math.min(25, Math.max(8, Math.floor(energy * 2.5)));
            
            for (let i = 0; i < numParticles; i++) {
                const speed = Math.random() * 2.5 + (energy * 0.35);
                const angle = Math.random() * Math.PI * 2;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                
                const color = Math.random() < 0.5 ? color1 : color2;
                const size = Math.random() * 2.5 + 1.5 + (energy * 0.15);
                const life = Math.random() * 15 + 25 + (energy * 6);
                
                particles.push(new Particle(x, y, color, size, life, vx, vy));
            }
            return particles;
        }

        function isOutOfBounds(planet, mapWidth, mapHeight, boundaryData) {
            if (boundaryData.type === "circle") {
                const centerX = boundaryData.center ? boundaryData.center.x * mapWidth : mapWidth / 2;
                const centerY = boundaryData.center ? boundaryData.center.y * mapHeight : mapHeight / 2;
                const radius = boundaryData.radius || Math.min(mapWidth, mapHeight) / 2 - 20;
                const distFromCenter = Math.hypot(planet.x - centerX, planet.y - centerY);
                return distFromCenter > radius + planet.size;
            } else {
                const margin = planet.size * 0.5;
                return (
                    planet.x < -margin ||
                    planet.x > mapWidth + margin ||
                    planet.y < -margin ||
                    planet.y > mapHeight + margin
                );
            }
        }

        // --- Enhanced Planet Class ---
        class Planet {
            constructor(x, y, data, owner = null) {
                this.x = x;
                this.y = y;
                this.initialX = x;
                this.initialY = y;
                this.vx = 0;
                this.vy = 0;
                this.data = data;
                this.size = data.size;
                this.mass = data.mass;
                this.baseColor = data.color;
                this.owner = owner;
                this.selected = false;
                this.out = false;
                
                this.axialTilt = data.axialTiltDeg !== undefined ? data.axialTiltDeg * (Math.PI / 180) : (Math.random() * 45 - 22.5) * (Math.PI / 180);
                this.rotationPeriodFactor = data.rotationPeriod !== undefined ? data.rotationPeriod : Math.random() * 0.009 + 0.001;
                this.angle = Math.random() * Math.PI * 2;
                this.rotationSpeed = this.rotationPeriodFactor * (Math.random() < 0.5 ? 1 : -1);

                this.trails = [];
                this.particles = [];
                
                this.planetType = data.type || "rocky_cratered";
                this.textureColors = data.texture_colors;
                this.textureCanvas = this.buildTexture();
                this.ringCanvas = (this.planetType.includes("rings")) ? this.buildRings() : null;
            }

            _drawShadedCircle(textureCtx, planetSize, baseColorStr, lightAngle = Math.PI / 4, shadowIntensity = 0.3, highlightIntensity = 0.15) {
                textureCtx.save();
                textureCtx.beginPath();
                textureCtx.arc(planetSize, planetSize, planetSize, 0, Math.PI * 2);
                textureCtx.clip();

                const shadowX = planetSize + Math.cos(lightAngle + Math.PI) * planetSize * 0.5;
                const shadowY = planetSize + Math.sin(lightAngle + Math.PI) * planetSize * 0.5;
                const shadowGrad = textureCtx.createRadialGradient(shadowX, shadowY, planetSize * 0.3, shadowX, shadowY, planetSize * 1.5);
                
                shadowGrad.addColorStop(0, `rgba(0, 0, 0, ${shadowIntensity})`);
                shadowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                // Fill base color
                textureCtx.fillStyle = baseColorStr;
                textureCtx.fill();
                
                // Add shadow
                textureCtx.fillStyle = shadowGrad;
                textureCtx.fill();
                
                // Add highlight
                const highlightX = planetSize + Math.cos(lightAngle) * planetSize * 0.3;
                const highlightY = planetSize + Math.sin(lightAngle) * planetSize * 0.3;
                const highlightGrad = textureCtx.createRadialGradient(highlightX, highlightY, 0, highlightX, highlightY, planetSize * 0.8);
                highlightGrad.addColorStop(0, `rgba(255, 255, 255, ${highlightIntensity})`);
                highlightGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                textureCtx.fillStyle = highlightGrad;
                textureCtx.fill();
                
                textureCtx.restore();
            }
        }

        // --- End of Planet class ---
    </script>
</head>
<body>

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>솔라 시스템 마블 - 태양계 학습 게임</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #00d4ff;
            --secondary-color: #ff6b35;
            --accent-color: #ffd700;
            --dark-bg: #0a0a15;
            --darker-bg: #050508;
            --card-bg: rgba(15, 25, 45, 0.95);
            --glass-bg: rgba(255, 255, 255, 0.1);
            --text-primary: #ffffff;
            --text-secondary: #b8c6db;
            --success-color: #4caf50;
            --warning-color: #ff9800;
            --danger-color: #f44336;
            --border-glow: rgba(0, 212, 255, 0.3);
            --shadow-glow: 0 0 30px rgba(0, 212, 255, 0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--dark-bg) 0%, var(--darker-bg) 100%);
            color: var(--text-primary);
            font-family: 'Noto Sans KR', sans-serif;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(120, 219, 255, 0.3) 0%, transparent 50%);
            animation: backgroundMove 20s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes backgroundMove {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(1deg); }
        }

        #gameCanvas {
            background: transparent;
            border: 2px solid var(--border-glow);
            border-radius: 16px;
            box-shadow: var(--shadow-glow), inset 0 0 20px rgba(0, 0, 0, 0.3);
            display: block;
            transition: all 0.3s ease;
        }

        #gameCanvas:hover {
            box-shadow: 0 0 50px rgba(0, 212, 255, 0.4), inset 0 0 20px rgba(0, 0, 0, 0.3);
        }

        .ui-panel {
            background: var(--card-bg);
            backdrop-filter: blur(15px);
            border: 1px solid var(--border-glow);
            border-radius: 16px;
            padding: 20px;
            box-shadow: var(--shadow-glow);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .ui-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            animation: shimmer 2s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        .ui-panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 40px rgba(0, 212, 255, 0.3);
        }

        #draftInfoPanel {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 420px;
            min-height: 140px;
            display: none;
            z-index: 100;
            animation: slideUpIn 0.3s ease-out;
        }

        @keyframes slideUpIn {
            from { transform: translateX(-50%) translateY(20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        #draftInfoPanel h3 {
            margin: 0 0 12px 0;
            color: var(--accent-color);
            font-size: 1.2em;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        #draftInfoPanel p {
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .stat-bar-container {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.8em;
        }

        .stat-bar-label {
            width: 50px;
            margin-right: 8px;
            color: var(--text-secondary);
            font-weight: 500;
            text-align: left;
        }

        .stat-bar {
            flex-grow: 1;
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }

        .stat-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
            animation: statShimmer 2s ease-in-out infinite;
        }

        @keyframes statShimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(200%); }
        }

        .stat-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success-color), #66bb6a);
            border-radius: 5px;
            transition: width 0.5s ease-out;
            position: relative;
            overflow: hidden;
        }

        .stat-bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: fillGlow 1.5s ease-in-out infinite;
        }

        @keyframes fillGlow {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        .stat-bar-value {
            width: 40px;
            text-align: right;
            margin-left: 8px;
            color: var(--text-primary);
            font-weight: 500;
        }

        #powerBarContainer {
            position: fixed;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            width: 280px;
            height: 36px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 18px;
            border: 2px solid var(--border-glow);
            padding: 4px;
            box-shadow: var(--shadow-glow);
            display: none;
            z-index: 100;
            animation: powerBarPulse 2s ease-in-out infinite alternate;
        }

        @keyframes powerBarPulse {
            from { box-shadow: 0 0 20px rgba(0, 212, 255, 0.3); }
            to { box-shadow: 0 0 30px rgba(0, 212, 255, 0.5); }
        }

        #powerBarFill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, var(--success-color), var(--warning-color), var(--danger-color));
            border-radius: 14px;
            transition: width 0.1s linear, box-shadow 0.1s linear;
            position: relative;
            overflow: hidden;
        }

        #powerBarFill::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: powerFillMove 1s ease-in-out infinite;
        }

        @keyframes powerFillMove {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        #powerBarText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--text-primary);
            font-size: 0.9em;
            font-weight: 700;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            font-family: 'Orbitron', monospace;
        }

        .game-ui-element {
            position: fixed;
            padding: 12px 18px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid var(--border-glow);
            box-shadow: var(--shadow-glow);
            font-size: 1em;
            z-index: 90;
            transition: all 0.3s ease;
        }

        .game-ui-element:hover {
            transform: scale(1.02);
            box-shadow: 0 0 25px rgba(0, 212, 255, 0.4);
        }

        #gameMessages {
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.1em;
            font-weight: 600;
            z-index: 120;
            text-align: center;
            min-width: 200px;
            animation: messageSlide 0.5s ease-out;
        }

        @keyframes messageSlide {
            from { transform: translateX(-50%) translateY(-20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        #turnIndicator {
            top: 20px;
            left: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: var(--accent-color);
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        #aliveCount {
            top: 70px;
            left: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 500;
        }

        #instructions {
            bottom: 20px;
            right: 20px;
            font-size: 0.8em;
            color: var(--text-secondary);
            text-align: right;
            max-width: 250px;
            line-height: 1.3;
        }

        .player-picks-ui {
            position: fixed;
            padding: 8px 12px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            border: 1px solid var(--border-glow);
            font-size: 0.9em;
            display: flex;
            align-items: center;
            z-index: 90;
            box-shadow: var(--shadow-glow);
            transition: all 0.3s ease;
        }

        .player-picks-ui:hover {
            transform: scale(1.05);
        }

        .player-picks-ui img {
            width: 28px;
            height: 28px;
            margin-left: 6px;
            border-radius: 50%;
            border: 2px solid var(--border-glow);
            transition: transform 0.2s ease;
        }

        .player-picks-ui img:hover {
            transform: scale(1.1);
        }

        #p1Picks { 
            left: 20px; 
            top: 120px;
            border-color: #ff6464;
            box-shadow: 0 0 15px rgba(255, 100, 100, 0.3);
        }

        #p2Picks { 
            right: 20px; 
            top: 20px;
            border-color: #6464ff;
            box-shadow: 0 0 15px rgba(100, 100, 255, 0.3);
        }

        .button {
            padding: 14px 28px;
            background: linear-gradient(135deg, var(--primary-color), #0099cc);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            margin: 12px;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            font-family: 'Noto Sans KR', sans-serif;
        }

        .button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .button:hover {
            background: linear-gradient(135deg, #00b4d8, var(--primary-color));
            box-shadow: 0 6px 25px rgba(0, 212, 255, 0.5);
            transform: translateY(-2px);
        }

        .button:hover::before {
            left: 100%;
        }

        .button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 212, 255, 0.3);
        }

        .button.secondary {
            background: linear-gradient(135deg, var(--secondary-color), #cc5500);
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
        }

        .button.secondary:hover {
            background: linear-gradient(135deg, #ff8a65, var(--secondary-color));
            box-shadow: 0 6px 25px rgba(255, 107, 53, 0.5);
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 200;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            justify-content: center;
            align-items: center;
            animation: modalFadeIn 0.3s ease-out;
        }

        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            margin: auto;
            padding: 30px;
            border: 2px solid var(--border-glow);
            border-radius: 20px;
            width: 90%;
            max-width: 700px;
            text-align: center;
            box-shadow: 0 10px 50px rgba(0, 212, 255, 0.3);
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from { transform: scale(0.7) translateY(50px); opacity: 0; }
            to { transform: scale(1) translateY(0); opacity: 1; }
        }

        .modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            animation: shimmer 2s ease-in-out infinite;
        }

        .modal-content h2 {
            color: var(--accent-color);
            margin-top: 0;
            margin-bottom: 20px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        .modal-content p {
            margin-bottom: 16px;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .close-button {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            font-size: 1.5em;
            color: var(--text-secondary);
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-button:hover {
            color: var(--danger-color);
        }

        .planet-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            text-align: left;
            margin-top: 20px;
        }

        .planet-info-item {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .planet-info-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .planet-info-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.2);
            border-color: var(--border-glow);
        }

        .planet-info-item:hover::before {
            opacity: 1;
        }

        .planet-info-item h4 {
            margin-top: 0;
            margin-bottom: 12px;
            color: var(--accent-color);
            font-family: 'Orbitron', sans-serif;
            font-weight: 600;
        }

        .planet-info-item p {
            font-size: 0.9em;
            margin-bottom: 6px;
            color: var(--text-secondary);
        }

        .planet-info-item .planet-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            float: right;
            margin-left: 15px;
            border: 2px solid var(--border-glow);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        .fun-fact {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 107, 53, 0.1));
            padding: 12px;
            border-radius: 10px;
            margin-top: 10px;
            border-left: 4px solid var(--accent-color);
            font-style: italic;
            color: var(--text-primary);
        }

        #startScreen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 150;
            width: 90%;
            max-width: 650px;
            text-align: center;
        }

        #startScreen h1 {
            color: var(--accent-color);
            font-size: 2.5em;
            margin-bottom: 15px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            animation: titleGlow 3s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            from { text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
            to { text-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
        }

        #startScreen p {
            color: var(--text-secondary);
            font-size: 1.1em;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        #modeSelectContainer {
            margin: 20px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            font-size: 1.1em;
            color: var(--text-primary);
            font-weight: 500;
        }

        #modeSelect {
            padding: 12px 16px;
            border-radius: 10px;
            border: 2px solid var(--border-glow);
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            color: var(--text-primary);
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Noto Sans KR', sans-serif;
        }

        #modeSelect:hover {
            border-color: var(--primary-color);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        #modeSelect option {
            background: var(--card-bg);
            color: var(--text-primary);
        }

        #modeDescription {
            margin: 15px 0 25px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.95em;
            color: var(--text-secondary);
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.4;
        }

        .tutorial-section {
            background: rgba(255, 255, 255, 0.03);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 4px solid var(--primary-color);
        }

        .tutorial-section h3 {
            color: var(--primary-color);
            margin-bottom: 12px;
            font-family: 'Orbitron', sans-serif;
        }

        .tutorial-step {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .tutorial-step-number {
            background: var(--primary-color);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 12px;
            font-size: 0.8em;
        }

        .comparison-chart {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .chart-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chart-item h5 {
            color: var(--accent-color);
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .chart-bar {
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 5px 0;
        }

        .chart-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            border-radius: 10px;
            transition: width 1s ease-out;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            #startScreen h1 { font-size: 2em; }
            .modal-content { padding: 20px; max-height: 80vh; }
            .planet-info-grid { grid-template-columns: 1fr; gap: 15px; }
            .game-ui-element { padding: 8px 12px; font-size: 0.9em; }
            #powerBarContainer { width: 220px; height: 32px; }
            #draftInfoPanel { max-width: 350px; bottom: 20px; }
            .comparison-chart { grid-template-columns: 1fr; }
            .tutorial-step { flex-direction: column; text-align: center; }
            .tutorial-step-number { margin: 0 0 8px 0; }
        }

        @media (max-width: 480px) {
            #startScreen h1 { font-size: 1.6em; }
            .modal-content { padding: 15px; }
            .button { padding: 10px 20px; font-size: 0.9em; }
            .game-ui-element { padding: 6px 10px; font-size: 0.8em; }
            #powerBarContainer { width: 180px; height: 28px; }
            .player-picks-ui img { width: 24px; height: 24px; }
        }

        /* Loading Animation */
        .loading-spinner {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #00b4d8;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="turnIndicator" class="game-ui-element" style="display: none;">
        <i class="fas fa-user"></i> P1의 턴
    </div>
    
    <div id="aliveCount" class="game-ui-element" style="display: none;">
        <i class="fas fa-chart-bar"></i> P1: 3 | P2: 3
    </div>
    
    <div id="instructions" class="game-ui-element" style="display: none;">
        <i class="fas fa-info-circle"></i> 행성 클릭 후 반대방향으로 드래그<br>
        <i class="fas fa-keyboard"></i> SPACE: 최대 파워 | R: 재시작<br>
        <i class="fas fa-question-circle"></i> H: 도움말
    </div>

    <div id="draftInfoPanel" class="ui-panel">
        <h3 id="draftPlanetName">
            <i class="fas fa-globe"></i> 행성 이름
        </h3>
        <p id="draftPlanetDesc">행성 설명이 여기에 표시됩니다.</p>
        <div class="stat-bar-container">
            <span class="stat-bar-label">크기:</span>
            <div class="stat-bar">
                <div id="draftStatSize" class="stat-bar-fill"></div>
            </div>
            <span id="draftStatSizeValue" class="stat-bar-value">0</span>
        </div>
        <div class="stat-bar-container">
            <span class="stat-bar-label">밀도:</span>
            <div class="stat-bar">
                <div id="draftStatDensity" class="stat-bar-fill" style="background: linear-gradient(90deg, #8A2BE2, #9932CC);"></div>
            </div>
            <span id="draftStatDensityValue" class="stat-bar-value">0</span>
        </div>
        <div class="stat-bar-container">
            <span class="stat-bar-label">중력:</span>
            <div class="stat-bar">
                <div id="draftStatGravity" class="stat-bar-fill" style="background: linear-gradient(90deg, #00BFFF, #1E90FF);"></div>
            </div>
            <span id="draftStatGravityValue" class="stat-bar-value">0</span>
        </div>
    </div>

    <div id="powerBarContainer">
        <div id="powerBarFill"></div>
        <div id="powerBarText">
            <i class="fas fa-bolt"></i> 파워: 0%
        </div>
    </div>

    <div id="gameMessages" class="game-ui-element" style="display: none;">
        <i class="fas fa-comment"></i> 게임 메시지
    </div>

    <div id="p1Picks" class="player-picks-ui" style="display:none;">
        <i class="fas fa-user" style="color: #ff6464;"></i> P1 선택:
    </div>
    
    <div id="p2Picks" class="player-picks-ui" style="display:none;">
        <i class="fas fa-user" style="color: #6464ff;"></i> P2 선택:
    </div>
    
    <!-- Game End Modal -->
    <div id="endGameModal" class="modal">
        <div class="modal-content">
            <button class="close-button" onclick="document.getElementById('endGameModal').style.display='none'">
                <i class="fas fa-times"></i>
            </button>
            <h2 id="winnerMessage">
                <i class="fas fa-trophy"></i> 승리 메시지
            </h2>
            <p id="congratsMessage">축하 메시지</p>
            <button id="restartButton" class="button">
                <i class="fas fa-redo"></i> 다시 플레이 (R)
            </button>
        </div>
    </div>

    <!-- Tutorial Modal -->
    <div id="tutorialModal" class="modal">
        <div class="modal-content">
            <button class="close-button" onclick="document.getElementById('tutorialModal').style.display='none'">
                <i class="fas fa-times"></i>
            </button>
            <h2><i class="fas fa-graduation-cap"></i> 게임 설명서</h2>
            
            <div class="tutorial-section">
                <h3><i class="fas fa-gamepad"></i> 게임 목표</h3>
                <p>태양계의 행성들을 이용해 상대방의 행성을 모두 맵 밖으로 밀어내거나, 컬링 모드에서 높은 점수를 획득하세요!</p>
            </div>

            <div class="tutorial-section">
                <h3><i class="fas fa-mouse"></i> 조작 방법</h3>
                <div class="tutorial-step">
                    <div class="tutorial-step-number">1</div>
                    <div>자신의 행성을 마우스로 클릭하여 선택</div>
                </div>
                <div class="tutorial-step">
                    <div class="tutorial-step-number">2</div>
                    <div>발사하고 싶은 반대 방향으로 드래그</div>
                </div>
                <div class="tutorial-step">
                    <div class="tutorial-step-number">3</div>
                    <div>마우스를 놓아서 행성 발사</div>
                </div>
                <div class="tutorial-step">
                    <div class="tutorial-step-number">4</div>
                    <div>SPACE 키로 최대 파워 설정 가능</div>
                </div>
            </div>

            <div class="tutorial-section">
                <h3><i class="fas fa-star"></i> 게임 모드</h3>
                <p><strong>알까기 모드:</strong> 상대방의 모든 행성을 맵 밖으로 밀어내면 승리</p>
                <p><strong>컬링 모드:</strong> 3라운드 동안 중앙 원에 가까이 행성을 위치시켜 점수 획득</p>
            </div>

            <div class="tutorial-section">
                <h3><i class="fas fa-lightbulb"></i> 전략 팁</h3>
                <p>• 큰 행성은 무겁고 강력하지만 움직이기 어려움</p>
                <p>• 작은 행성은 빠르게 움직이지만 충돌시 밀려남</p>
                <p>• 중력을 이용해 궤도를 활용하세요</p>
                <p>• 태양의 강한 중력을 전략적으로 활용</p>
            </div>

            <button class="button" onclick="document.getElementById('tutorialModal').style.display='none'">
                <i class="fas fa-check"></i> 이해했습니다
            </button>
        </div>
    </div>

    <!-- Planet Info Modal -->
    <div id="planetInfoModal" class="modal">
        <div class="modal-content">
            <button class="close-button" onclick="document.getElementById('planetInfoModal').style.display='none'">
                <i class="fas fa-times"></i>
            </button>
            <h2><i class="fas fa-globe-americas"></i> 태양계 행성 학습</h2>
            
            <div class="comparison-chart">
                <div class="chart-item">
                    <h5>크기 비교 (지구=1)</h5>
                    <div class="chart-bar">
                        <div class="chart-fill" style="width: 100%;" data-planet="earth"></div>
                    </div>
                    <small>지구 기준</small>
                </div>
                <div class="chart-item">
                    <h5>거리 비교 (AU)</h5>
                    <div class="chart-bar">
                        <div class="chart-fill" style="width: 100%;" data-planet="distance"></div>
                    </div>
                    <small>태양으로부터</small>
                </div>
            </div>

            <div id="planetInfoGrid" class="planet-info-grid"></div>
            
            <button id="closePlanetInfoBtn" class="button">
                <i class="fas fa-arrow-left"></i> 돌아가기
            </button>
        </div>
    </div>

    <!-- Quiz Modal -->
    <div id="quizModal" class="modal">
        <div class="modal-content">
            <button class="close-button" onclick="document.getElementById('quizModal').style.display='none'">
                <i class="fas fa-times"></i>
            </button>
            <h2><i class="fas fa-brain"></i> 태양계 퀴즈</h2>
            <div id="quizContent">
                <div id="quizQuestion"></div>
                <div id="quizOptions"></div>
                <div id="quizResult" style="display: none;"></div>
                <div id="quizScore">점수: <span id="currentScore">0</span> / <span id="totalQuestions">0</span></div>
                <button id="nextQuizBtn" class="button" style="display: none;" onclick="nextQuiz()">
                    <i class="fas fa-arrow-right"></i> 다음 문제
                </button>
                <button id="startQuizBtn" class="button" onclick="startQuiz()">
                    <i class="fas fa-play"></i> 퀴즈 시작
                </button>
            </div>
        </div>
    </div>

    <!-- Debug Panel -->
    <div id="debugPanel" style="display: none; position: fixed; top: 10px; right: 300px; background: rgba(0,0,0,0.8); color: white; padding: 10px; border-radius: 8px; font-family: monospace; font-size: 12px; z-index: 200; max-width: 250px;">
        <h4 style="margin: 0 0 8px 0; color: #00ff00;">🔧 디버그 모드</h4>
        <div id="debugInfo"></div>
        <button onclick="toggleDebugMode()" style="margin-top: 8px; padding: 4px 8px; background: #333; color: white; border: 1px solid #666; border-radius: 4px; cursor: pointer;">
            디버그 모드 끄기
        </button>
    </div>

    <!-- Learning Progress Tracker -->
    <div id="learningProgress" style="display: none; position: fixed; top: 20px; right: 20px; background: var(--card-bg); backdrop-filter: blur(15px); border: 1px solid var(--border-glow); border-radius: 12px; padding: 15px; color: white; z-index: 150; max-width: 250px;">
        <h4 style="margin: 0 0 10px 0; color: var(--accent-color);">📚 학습 진행도</h4>
        <div id="progressBars"></div>
        <div style="margin-top: 10px; font-size: 12px; color: var(--text-secondary);">
            총 플레이 시간: <span id="totalPlayTime">0분</span>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="ui-panel">
        <h1><i class="fas fa-rocket"></i> 태양계 알까기</h1>
        <p>우주를 배경으로 펼쳐지는 전략 시뮬레이션 게임!<br>
        실제 태양계 행성들의 물리 법칙을 체험하며 전략적 사고력을 기르세요.</p>
        
        <div id="modeSelectContainer">
            <label for="modeSelect">
                <i class="fas fa-cog"></i> 게임 모드:
            </label>
            <select id="modeSelect">
                <option value="alggagi" selected>🎯 알까기 모드</option>
                <option value="culling">🥌 컬링 모드</option>
            </select>
        </div>
        
        <div id="modeDescription">
            행성들을 이용해 상대방의 행성을 모두 맵 밖으로 밀어내세요.
        </div>
        
        <button id="startGameBtn" class="button">
            <i class="fas fa-play"></i> 게임 시작
        </button>
        
        <button id="learnPlanetsBtn" class="button secondary">
            <i class="fas fa-book"></i> 행성 학습
        </button>
        
        <button id="tutorialBtn" class="button secondary">
            <i class="fas fa-question-circle"></i> 게임 설명
        </button>
        
        <button id="quizBtn" class="button secondary">
            <i class="fas fa-brain"></i> 태양계 퀴즈
        </button>
        
        <button id="debugModeBtn" class="button secondary" style="font-size: 0.8em;">
            <i class="fas fa-bug"></i> 디버그 모드
        </button>
    </div>

    <script type="module">
        // Enhanced Solar System Educational Game
        // Improved with modern UI/UX, debugging, and educational content

        // --- Constants and Global Variables ---
        let canvas, ctx;
        let spaceBackground;
        let currentGameState = null;
        let gameRunningState = "menu";
        let isDragging = false;
        let dragJustStarted = false;
        let selectedPlanet = null;
        let startDragPos = { x: 0, y: 0 };
        let trajectoryPoints = [];
        let lastTime = 0;
        let powerAmount = 0;
        let isGameOver = false;
        let gameLoop = null;
        let draftState = null;
        let draftHandleClick = null;
        let draftHandleMouseMove = null;
        let draftHandleKeyDown = null;
        const pickedPlanets = { P1: [], P2: [] };
        let npcPlanets = [];
        let uiInstructions;
        let debugMode = false;

        // --- Educational Quiz System ---
        const quizQuestions = [
            {
                question: "태양계에서 가장 큰 행성은 무엇인가요?",
                options: ["지구", "목성", "토성", "해왕성"],
                correct: 1,
                explanation: "목성은 태양계에서 가장 큰 행성으로, 지구보다 11배나 큽니다!",
                category: "크기"
            },
            {
                question: "태양에서 가장 가까운 행성은?",
                options: ["금성", "수성", "지구", "화성"],
                correct: 1,
                explanation: "수성은 태양에서 가장 가까운 행성입니다. 하지만 금성이 더 뜨거워요!",
                category: "거리"
            },
            {
                question: "어떤 행성이 거꾸로 자전하나요?",
                options: ["지구", "화성", "금성", "목성"],
                correct: 2,
                explanation: "금성은 다른 행성들과 반대 방향으로 자전합니다. 태양이 서쪽에서 떠요!",
                category: "운동"
            },
            {
                question: "토성의 가장 특별한 특징은?",
                options: ["가장 크다", "아름다운 고리", "가장 빠르다", "가장 뜨겁다"],
                correct: 1,
                explanation: "토성은 아름다운 고리로 유명합니다. 수십억 개의 얼음과 바위 조각으로 이루어져 있어요!",
                category: "특징"
            },
            {
                question: "지구의 자전축은 몇 도 기울어져 있나요?",
                options: ["0도", "23.4도", "45도", "90도"],
                correct: 1,
                explanation: "지구의 자전축은 23.4도 기울어져 있어서 계절이 생깁니다!",
                category: "지구"
            }
        ];

        let currentQuiz = {
            questions: [],
            currentIndex: 0,
            score: 0,
            categories: {}
        };

        // --- Learning Progress Tracking ---
        let learningProgress = {
            startTime: null,
            totalPlayTime: 0,
            planetsLearned: new Set(),
            quizzesTaken: 0,
            correctAnswers: 0,
            gamesPlayed: 0,
            strategiesUsed: new Set()
        };

        // --- Enhanced Educational Planet Data ---
        const planets_data_template = [
            {
                "name": "태양", "color": '#FFFF00', "size": 60, "mass": 150, "id": "sun",
                "texture_colors": { base: '#FFD700', corona: ['#FFFACD', '#FFE4B5', '#FFDEAD'], spots: ['#FFA500', '#FF8C00']},
                "desc": "태양계의 중심에 있는 항성으로, 모든 행성들이 태양 주위를 공전합니다.",
                "type": "star", axialTiltDeg: 7.25, orbitalPeriod: 0, density: 1.41, surfaceGravity: 27.9, rotationPeriod: 0.0001,
                "distanceFromSun": 0, "temperature": 5778, "moons": 0,
                "funFact": "태양은 매초 400만 톤의 질량을 에너지로 변환합니다! 이는 핵융합 반응 때문입니다.",
                "educationalNote": "태양의 중력은 지구보다 28배나 강해서, 만약 태양에 떨어진다면 엄청난 속도로 가속됩니다.",
                "gameStrategy": "태양의 강력한 중력을 이용해 행성의 궤도를 바꿀 수 있습니다. 태양 근처로 행성을 보내면 중력 가속을 받아 더 빠르게 움직입니다."
            },
            {
                "name": "수성", "color": '#A9A9A9', "size": 10, "mass": 0.06, "id": "mercury",
                "texture_colors": { base: '#808080', craters_dark: '#606060', craters_light: '#A0A0A0'},
                "desc": "태양에 가장 가까운 행성으로 작고 빠르며, 표면은 크레이터로 가득합니다.",
                "type": "rocky_cratered", axialTiltDeg: 0.03, orbitalPeriod: 88, density: 5.43, surfaceGravity: 0.38, rotationPeriod: 0.005,
                "distanceFromSun": 0.39, "temperature": 167, "moons": 0,
                "funFact": "수성의 하루는 지구의 176일과 같습니다! 자전이 매우 느리기 때문입니다.",
                "educationalNote": "수성은 밀도가 높아서 작지만 무겁습니다. 이는 큰 철 핵을 가지고 있기 때문입니다.",
                "gameStrategy": "수성은 작지만 밀도가 높아 의외로 무겁습니다. 다른 행성을 밀어낼 때 생각보다 큰 힘을 발휘할 수 있어요."
            },
            {
                "name": "금성", "color": '#F5DEB3', "size": 20, "mass": 0.82, "id": "venus",
                "texture_colors": { base: '#EEDC82', clouds: ['#FFF8DC', '#FAF0E6', '#FFEBCD']},
                "desc": "두꺼운 황산 구름으로 덮여 있으며, 온실효과로 인해 태양계에서 가장 뜨거운 행성입니다.",
                "type": "rocky_cloudy", axialTiltDeg: 177.4, orbitalPeriod: 225, density: 5.24, surfaceGravity: 0.90, rotationPeriod: 0.01,
                "distanceFromSun": 0.72, "temperature": 464, "moons": 0,
                "funFact": "금성은 거꾸로 자전합니다! 태양이 서쪽에서 뜨고 동쪽으로 집니다.",
                "educationalNote": "금성의 대기압은 지구의 90배나 됩니다. 마치 깊은 바다 밑에 있는 것과 같죠!",
                "gameStrategy": "금성은 크기와 질량이 지구와 비슷해 균형 잡힌 플레이가 가능합니다. 공격과 수비 모두에 적합해요."
            },
            {
                "name": "지구", "color": '#6495ED', "size": 22, "mass": 1.0, "id": "earth",
                "texture_colors": { ocean: '#4682B4', land: ['#228B22', '#8FBC8F', '#D2B48C'], cloud: 'rgba(240,248,255,0.7)'},
                "desc": "우리가 살고 있는 행성으로, 액체 상태의 물과 생명체가 존재하는 유일한 행성입니다.",
                "type": "earth-like", axialTiltDeg: 23.44, orbitalPeriod: 365, density: 5.51, surfaceGravity: 1.00, rotationPeriod: 0.003,
                "distanceFromSun": 1.0, "temperature": 15, "moons": 1,
                "funFact": "지구는 초속 30km로 태양 주위를 돌고 있습니다. 1년 동안 9억 4천만 km를 여행해요!",
                "educationalNote": "지구의 자전축이 23.4도 기울어져 있어서 계절이 생깁니다.",
                "gameStrategy": "지구는 게임의 기준이 되는 행성입니다. 모든 스탯이 표준적이어서 초보자가 사용하기 좋아요."
            },
            {
                "name": "화성", "color": '#CD5C5C', "size": 15, "mass": 0.11, "id": "mars",
                "texture_colors": { base: '#BC8F8F', dust: ['#D2B48C', '#CD853F'], ice_caps: '#FFFFFF', craters: '#A0522D'},
                "desc": "붉은 행성이라 불리며, 극지방에 얼음이 있고 과거에 물이 흘렀던 흔적이 발견됩니다.",
                "type": "rocky_ice_caps", axialTiltDeg: 25.19, orbitalPeriod: 687, density: 3.93, surfaceGravity: 0.38, rotationPeriod: 0.0031,
                "distanceFromSun": 1.52, "temperature": -65, "moons": 2,
                "funFact": "화성의 하루는 지구와 거의 같아요! 24시간 37분입니다.",
                "educationalNote": "화성에서는 먼지 폭풍이 행성 전체를 덮을 수 있습니다. 몇 달 동안 지속되기도 해요!",
                "gameStrategy": "화성은 작고 가벼워서 빠르게 움직일 수 있습니다. 기습 공격이나 정밀한 조준에 적합해요."
            },
            {
                "name": "목성", "color": '#DEB887', "size": 45, "mass": 318, "id": "jupiter",
                "texture_colors": { base: '#D2B48C', bands_light: ['#F5DEB3', '#FFEBCD'], bands_dark: ['#A0522D', '#8B4513'], spot: '#C19A6B'},
                "desc": "태양계에서 가장 큰 가스 행성으로, 대적점이라는 거대한 폭풍이 수백 년째 지속되고 있습니다.",
                "type": "gas_giant_bands_spot", axialTiltDeg: 3.13, orbitalPeriod: 4333, density: 1.33, surfaceGravity: 2.53, rotationPeriod: 0.0015,
                "distanceFromSun": 5.2, "temperature": -110, "moons": 95,
                "funFact": "목성의 대적점은 지구 3개가 들어갈 만큼 큰 폭풍입니다!",
                "educationalNote": "목성은 태양계의 '청소부' 역할을 합니다. 강한 중력으로 소행성들을 끌어당겨 지구를 보호해요.",
                "gameStrategy": "목성은 가장 크고 무거운 행성입니다. 움직이기는 어렵지만 한 번 움직이면 막을 수 없는 파괴력을 가집니다!"
            },
            {
                "name": "토성", "color": '#F0E68C', "size": 40, "mass": 95, "id": "saturn",
                "texture_colors": { body: '#EEE8AA', rings: ['rgba(210,180,140,0.7)', 'rgba(240,220,190,0.6)', 'rgba(188,150,120,0.5)']},
                "desc": "아름다운 고리로 유명한 가스 행성입니다. 밀도가 낮아서 물에 뜰 수 있습니다.",
                "type": "gas_giant_rings", axialTiltDeg: 26.73, orbitalPeriod: 10759, density: 0.69, surfaceGravity: 1.07, rotationPeriod: 0.0016,
                "distanceFromSun": 9.5, "temperature": -140, "moons": 146,
                "funFact": "토성의 고리는 수십억 개의 얼음과 바위 조각으로 이루어져 있어요!",
                "educationalNote": "토성은 물보다 가볍습니다. 거대한 바다가 있다면 토성이 둥둥 떠다닐 거예요!",
                "gameStrategy": "토성은 크지만 밀도가 낮아 목성보다 가벼워요. 고리가 있어서 회전 효과가 독특합니다."
            },
            {
                "name": "천왕성", "color": '#AFEEEE', "size": 30, "mass": 14.5, "id": "uranus",
                "texture_colors": { body: '#ADD8E6', atmosphere: ['#B0E0E6', '#AFEEEE'], rings_faint: 'rgba(200,220,220,0.3)'},
                "desc": "옆으로 누워서 자전하는 독특한 얼음 행성입니다. 메탄 때문에 푸른빛을 띱니다.",
                "type": "ice_giant_rings", axialTiltDeg: 97.77, orbitalPeriod: 30687, density: 1.27, surfaceGravity: 0.89, rotationPeriod: 0.0025,
                "distanceFromSun": 19.2, "temperature": -195, "moons": 27,
                "funFact": "천왕성의 자전축은 98도 기울어져 있어서 옆으로 굴러다니는 것 같아요!",
                "educationalNote": "천왕성의 극지방은 42년 동안 계속 겨울이거나 여름입니다.",
                "gameStrategy": "천왕성은 특이한 자전축 때문에 예측하기 어려운 움직임을 보입니다. 고급 전략에 활용해보세요."
            },
            {
                "name": "해왕성", "color": '#6495ED', "size": 28, "mass": 17, "id": "neptune",
                "texture_colors": { body: '#4169E1', spots_clouds: ['#5F9EA0', '#000080', 'rgba(173,216,230,0.4)']},
                "desc": "태양계에서 가장 바람이 강한 행성으로, 시속 2000km의 바람이 불기도 합니다.",
                "type": "ice_giant_spot_clouds", axialTiltDeg: 28.32, orbitalPeriod: 60190, density: 1.64, surfaceGravity: 1.14, rotationPeriod: 0.0023,
                "distanceFromSun": 30.1, "temperature": -200, "moons": 16,
                "funFact": "해왕성에서는 다이아몬드 비가 내릴 수도 있어요! 높은 압력과 온도 때문입니다.",
                "educationalNote": "해왕성은 수학으로 발견된 첫 번째 행성입니다. 천왕성의 궤도 이상을 설명하려다 발견했어요!",
                "gameStrategy": "해왕성은 강한 바람을 가진 행성입니다. 게임에서는 충돌 후 더 멀리 튕겨나가는 특성이 있어요."
            }
        ];

        // --- Enhanced Physics Engine ---
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : {r:255, g:255, b:255};
        }

        class Particle {
            constructor(x, y, color, size = 2, life = 30, vxOverride = null, vyOverride = null) {
                this.x = x;
                this.y = y;
                this.vx = vxOverride !== null ? vxOverride : (Math.random() - 0.5) * 4;
                this.vy = vyOverride !== null ? vyOverride : (Math.random() - 0.5) * 4;
                this.color = color;
                this.baseSize = size;
                this.life = life;
                this.age = 0;
                this.maxLife = life;
                this.damping = 0.97;
            }

            update(deltaTime) {
                this.x += this.vx * (deltaTime * 60);
                this.y += this.vy * (deltaTime * 60);
                this.vx *= Math.pow(this.damping, deltaTime * 60);
                this.vy *= Math.pow(this.damping, deltaTime * 60);
                this.age++;
                return this.age < this.maxLife;
            }

            draw(context) {
                const progress = this.age / this.maxLife;
                const alpha = Math.max(0, 1 - progress * progress);
                const currentSize = Math.max(0.5, this.baseSize * (1 - progress * 0.7));

                if (currentSize < 0.5 || alpha <= 0) return;

                const rgb = hexToRgb(this.color);
                context.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
                context.beginPath();
                context.arc(this.x, this.y, currentSize, 0, Math.PI * 2);
                context.fill();
            }
        }

        function detectCollision(p1, p2) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const distSq = dx * dx + dy * dy;
            const minDist = p1.size + p2.size;
            return distSq < minDist * minDist;
        }

        function resolveCollision(p1, p2, dt) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            let dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist === 0) {
                dist = 0.1;
            }
            
            const nx = dx / dist;
            const ny = dy / dist;
            
            const overlap = (p1.size + p2.size) - dist;
            if (overlap > 0) {
                const m1 = Math.max(0.1, p1.mass);
                const m2 = Math.max(0.1, p2.mass);
                const totalMass = m1 + m2;
                
                const p1Ratio = m2 / totalMass;
                const p2Ratio = m1 / totalMass;
                
                p1.x -= nx * overlap * p1Ratio * 0.5;
                p1.y -= ny * overlap * p1Ratio * 0.5;
                p2.x += nx * overlap * p2Ratio * 0.5;
                p2.y += ny * overlap * p2Ratio * 0.5;
            }
            
            const m1 = Math.max(0.1, p1.mass);
            const m2 = Math.max(0.1, p2.mass);
            
            const tx = -ny;
            const ty = nx;
            
            const v1n = p1.vx * nx + p1.vy * ny;
            const v1t = p1.vx * tx + p1.vy * ty;
            const v2n = p2.vx * nx + p2.vy * ny;
            const v2t = p2.vx * tx + p2.vy * ty;
            
            const e = 0.8;
            
            let v1nAfter = ((m1 - e * m2) * v1n + (1 + e) * m2 * v2n) / (m1 + m2);
            let v2nAfter = ((m2 - e * m1) * v2n + (1 + e) * m1 * v1n) / (m1 + m2);
            
            p1.vx = v1nAfter * nx + v1t * tx;
            p1.vy = v1nAfter * ny + v1t * ty;
            p2.vx = v2nAfter * nx + v2t * ty;
            p2.vy = v2nAfter * ny + v2t * ty;
            
            return {
                x: p1.x + nx * p1.size,
                y: p1.y + ny * p1.size,
                energy: Math.abs(v1nAfter - v1n) + Math.abs(v2nAfter - v2n)
            };
        }

        function applyGravity(p1, p2, dt, G = 0.1) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const distSq = dx * dx + dy * dy;
            if (distSq === 0) return;
            const dist = Math.sqrt(distSq);
            const minGravDist = p1.size + p2.size + 2;
            
            if (dist > minGravDist) {
                let gravityMult = 1;
                if (p1.type === 'star') gravityMult *= 2.5;
                if (p2.type === 'star') gravityMult *= 2.5;

                let forceMagnitude = G * gravityMult * (p1.mass * p2.mass) / distSq;
                const maxForceAllowed = 30;
                forceMagnitude = Math.min(forceMagnitude, maxForceAllowed);
                
                const forceX = forceMagnitude * dx / dist;
                const forceY = forceMagnitude * dy / dist;

                if (p1.mass > 0) {
                    p1.vx += forceX / p1.mass * dt;
                    p1.vy += forceY / p1.mass * dt;
                }
                if (p2.mass > 0) {
                    p2.vx -= forceX / p2.mass * dt;
                    p2.vy -= forceY / p2.mass * dt;
                }
            }
        }

        function createCollisionParticles(x, y, energy, color1, color2) {
            const particles = [];
            const numParticles = Math.min(25, Math.max(8, Math.floor(energy * 2.5)));
            
            for (let i = 0; i < numParticles; i++) {
                const speed = Math.random() * 2.5 + (energy * 0.35);
                const angle = Math.random() * Math.PI * 2;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                
                const color = Math.random() < 0.5 ? color1 : color2;
                const size = Math.random() * 2.5 + 1.5 + (energy * 0.15);
                const life = Math.random() * 15 + 25 + (energy * 6);
                
                particles.push(new Particle(x, y, color, size, life, vx, vy));
            }
            return particles;
        }

        function isOutOfBounds(planet, mapWidth, mapHeight, boundaryData) {
            if (boundaryData.type === "circle") {
                const centerX = boundaryData.center ? boundaryData.center.x * mapWidth : mapWidth / 2;
                const centerY = boundaryData.center ? boundaryData.center.y * mapHeight : mapHeight / 2;
                const radius = boundaryData.radius || Math.min(mapWidth, mapHeight) / 2 - 20;
                const distFromCenter = Math.hypot(planet.x - centerX, planet.y - centerY);
                return distFromCenter > radius + planet.size;
            } else {
                const margin = planet.size * 0.5;
                return (
                    planet.x < -margin ||
                    planet.x > mapWidth + margin ||
                    planet.y < -margin ||
                    planet.y > mapHeight + margin
                );
            }
        }

        // --- Enhanced Planet Class ---
        class Planet {
            constructor(x, y, data, owner = null) {
                this.x = x;
                this.y = y;
                this.initialX = x;
                this.initialY = y;
                this.vx = 0;
                this.vy = 0;
                this.data = data;
                this.size = data.size;
                this.mass = data.mass;
                this.baseColor = data.color;
                this.owner = owner;
                this.selected = false;
                this.out = false;
                
                this.axialTilt = data.axialTiltDeg !== undefined ? data.axialTiltDeg * (Math.PI / 180) : (Math.random() * 45 - 22.5) * (Math.PI / 180);
                this.rotationPeriodFactor = data.rotationPeriod !== undefined ? data.rotationPeriod : Math.random() * 0.009 + 0.001;
                this.angle = Math.random() * Math.PI * 2;
                this.rotationSpeed = this.rotationPeriodFactor * (Math.random() < 0.5 ? 1 : -1);

                this.trails = [];
                this.particles = [];
                
                this.planetType = data.type || "rocky_cratered";
                this.textureColors = data.texture_colors;
                this.textureCanvas = this.buildTexture();
                this.ringCanvas = (this.planetType.includes("rings")) ? this.buildRings() : null;
            }

            _drawShadedCircle(textureCtx, planetSize, baseColorStr, lightAngle = Math.PI / 4, shadowIntensity = 0.3, highlightIntensity = 0.15) {
                textureCtx.save();
                textureCtx.beginPath();
                textureCtx.arc(planetSize, planetSize, planetSize, 0, Math.PI * 2);
                textureCtx.clip();

                const shadowX = planetSize + Math.cos(lightAngle + Math.PI) * planetSize * 0.5;
                const shadowY = planetSize + Math.sin(lightAngle + Math.PI) * planetSize * 0.5;
                const shadowGrad = textureCtx.createRadialGradient(shadowX, shadowY, planetSize * 0.3, shadowX, shadowY, planetSize * 1.5);
                
                shadowGrad.addColorStop(0, `rgba(0, 0, 0, ${shadowIntensity})`);
                shadowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                // Fill base color
                textureCtx.fillStyle = baseColorStr;
                textureCtx.fill();
                
                // Add shadow
                textureCtx.fillStyle = shadowGrad;
                textureCtx.fill();
                
                // Add highlight
                const highlightX = planetSize + Math.cos(lightAngle) * planetSize * 0.3;
                const highlightY = planetSize + Math.sin(lightAngle) * planetSize * 0.3;
                const highlightGrad = textureCtx.createRadialGradient(highlightX, highlightY, 0, highlightX, highlightY, planetSize * 0.8);
                highlightGrad.addColorStop(0, `rgba(255, 255, 255, ${highlightIntensity})`);
                highlightGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                textureCtx.fillStyle = highlightGrad;
                textureCtx.fill();
                
                textureCtx.restore();
            }
        }

        // --- End of Planet class ---
    </script>
</head>
<body>

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>솔라 시스템 마블 - 태양계 학습 게임</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #00d4ff;
            --secondary-color: #ff6b35;
            --accent-color: #ffd700;
            --dark-bg: #0a0a15;
            --darker-bg: #050508;
            --card-bg: rgba(15, 25, 45, 0.95);
            --glass-bg: rgba(255, 255, 255, 0.1);
            --text-primary: #ffffff;
            --text-secondary: #b8c6db;
            --success-color: #4caf50;
            --warning-color: #ff9800;
            --danger-color: #f44336;
            --border-glow: rgba(0, 212, 255, 0.3);
            --shadow-glow: 0 0 30px rgba(0, 212, 255, 0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--dark-bg) 0%, var(--darker-bg) 100%);
            color: var(--text-primary);
            font-family: 'Noto Sans KR', sans-serif;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(120, 219, 255, 0.3) 0%, transparent 50%);
            animation: backgroundMove 20s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes backgroundMove {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(1deg); }
        }

        #gameCanvas {
            background: transparent;
            border: 2px solid var(--border-glow);
            border-radius: 16px;
            box-shadow: var(--shadow-glow), inset 0 0 20px rgba(0, 0, 0, 0.3);
            display: block;
            transition: all 0.3s ease;
        }

        #gameCanvas:hover {
            box-shadow: 0 0 50px rgba(0, 212, 255, 0.4), inset 0 0 20px rgba(0, 0, 0, 0.3);
        }

        .ui-panel {
            background: var(--card-bg);
            backdrop-filter: blur(15px);
            border: 1px solid var(--border-glow);
            border-radius: 16px;
            padding: 20px;
            box-shadow: var(--shadow-glow);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .ui-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            animation: shimmer 2s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        .ui-panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 40px rgba(0, 212, 255, 0.3);
        }

        #draftInfoPanel {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 420px;
            min-height: 140px;
            display: none;
            z-index: 100;
            animation: slideUpIn 0.3s ease-out;
        }

        @keyframes slideUpIn {
            from { transform: translateX(-50%) translateY(20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        #draftInfoPanel h3 {
            margin: 0 0 12px 0;
            color: var(--accent-color);
            font-size: 1.2em;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        #draftInfoPanel p {
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .stat-bar-container {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.8em;
        }

        .stat-bar-label {
            width: 50px;
            margin-right: 8px;
            color: var(--text-secondary);
            font-weight: 500;
            text-align: left;
        }

        .stat-bar {
            flex-grow: 1;
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }

        .stat-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
            animation: statShimmer 2s ease-in-out infinite;
        }

        @keyframes statShimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(200%); }
        }

        .stat-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success-color), #66bb6a);
            border-radius: 5px;
            transition: width 0.5s ease-out;
            position: relative;
            overflow: hidden;
        }

        .stat-bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: fillGlow 1.5s ease-in-out infinite;
        }

        @keyframes fillGlow {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        .stat-bar-value {
            width: 40px;
            text-align: right;
            margin-left: 8px;
            color: var(--text-primary);
            font-weight: 500;
        }

        #powerBarContainer {
            position: fixed;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            width: 280px;
            height: 36px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 18px;
            border: 2px solid var(--border-glow);
            padding: 4px;
            box-shadow: var(--shadow-glow);
            display: none;
            z-index: 100;
            animation: powerBarPulse 2s ease-in-out infinite alternate;
        }

        @keyframes powerBarPulse {
            from { box-shadow: 0 0 20px rgba(0, 212, 255, 0.3); }
            to { box-shadow: 0 0 30px rgba(0, 212, 255, 0.5); }
        }

        #powerBarFill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, var(--success-color), var(--warning-color), var(--danger-color));
            border-radius: 14px;
            transition: width 0.1s linear, box-shadow 0.1s linear;
            position: relative;
            overflow: hidden;
        }

        #powerBarFill::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: powerFillMove 1s ease-in-out infinite;
        }

        @keyframes powerFillMove {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        #powerBarText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--text-primary);
            font-size: 0.9em;
            font-weight: 700;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            font-family: 'Orbitron', monospace;
        }

        .game-ui-element {
            position: fixed;
            padding: 12px 18px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid var(--border-glow);
            box-shadow: var(--shadow-glow);
            font-size: 1em;
            z-index: 90;
            transition: all 0.3s ease;
        }

        .game-ui-element:hover {
            transform: scale(1.02);
            box-shadow: 0 0 25px rgba(0, 212, 255, 0.4);
        }

        #gameMessages {
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.1em;
            font-weight: 600;
            z-index: 120;
            text-align: center;
            min-width: 200px;
            animation: messageSlide 0.5s ease-out;
        }

        @keyframes messageSlide {
            from { transform: translateX(-50%) translateY(-20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        #turnIndicator {
            top: 20px;
            left: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: var(--accent-color);
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        #aliveCount {
            top: 70px;
            left: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 500;
        }

        #instructions {
            bottom: 20px;
            right: 20px;
            font-size: 0.8em;
            color: var(--text-secondary);
            text-align: right;
            max-width: 250px;
            line-height: 1.3;
        }

        .player-picks-ui {
            position: fixed;
            padding: 8px 12px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            border: 1px solid var(--border-glow);
            font-size: 0.9em;
            display: flex;
            align-items: center;
            z-index: 90;
            box-shadow: var(--shadow-glow);
            transition: all 0.3s ease;
        }

        .player-picks-ui:hover {
            transform: scale(1.05);
        }

        .player-picks-ui img {
            width: 28px;
            height: 28px;
            margin-left: 6px;
            border-radius: 50%;
            border: 2px solid var(--border-glow);
            transition: transform 0.2s ease;
        }

        .player-picks-ui img:hover {
            transform: scale(1.1);
        }

        #p1Picks { 
            left: 20px; 
            top: 120px;
            border-color: #ff6464;
            box-shadow: 0 0 15px rgba(255, 100, 100, 0.3);
        }

        #p2Picks { 
            right: 20px; 
            top: 20px;
            border-color: #6464ff;
            box-shadow: 0 0 15px rgba(100, 100, 255, 0.3);
        }

        .button {
            padding: 14px 28px;
            background: linear-gradient(135deg, var(--primary-color), #0099cc);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            margin: 12px;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            font-family: 'Noto Sans KR', sans-serif;
        }

        .button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .button:hover {
            background: linear-gradient(135deg, #00b4d8, var(--primary-color));
            box-shadow: 0 6px 25px rgba(0, 212, 255, 0.5);
            transform: translateY(-2px);
        }

        .button:hover::before {
            left: 100%;
        }

        .button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 212, 255, 0.3);
        }

        .button.secondary {
            background: linear-gradient(135deg, var(--secondary-color), #cc5500);
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
        }

        .button.secondary:hover {
            background: linear-gradient(135deg, #ff8a65, var(--secondary-color));
            box-shadow: 0 6px 25px rgba(255, 107, 53, 0.5);
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 200;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            justify-content: center;
            align-items: center;
            animation: modalFadeIn 0.3s ease-out;
        }

        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            margin: auto;
            padding: 30px;
            border: 2px solid var(--border-glow);
            border-radius: 20px;
            width: 90%;
            max-width: 700px;
            text-align: center;
            box-shadow: 0 10px 50px rgba(0, 212, 255, 0.3);
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from { transform: scale(0.7) translateY(50px); opacity: 0; }
            to { transform: scale(1) translateY(0); opacity: 1; }
        }

        .modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            animation: shimmer 2s ease-in-out infinite;
        }

        .modal-content h2 {
            color: var(--accent-color);
            margin-top: 0;
            margin-bottom: 20px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        .modal-content p {
            margin-bottom: 16px;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .close-button {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            font-size: 1.5em;
            color: var(--text-secondary);
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-button:hover {
            color: var(--danger-color);
        }

        .planet-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            text-align: left;
            margin-top: 20px;
        }

        .planet-info-item {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .planet-info-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .planet-info-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.2);
            border-color: var(--border-glow);
        }

        .planet-info-item:hover::before {
            opacity: 1;
        }

        .planet-info-item h4 {
            margin-top: 0;
            margin-bottom: 12px;
            color: var(--accent-color);
            font-family: 'Orbitron', sans-serif;
            font-weight: 600;
        }

        .planet-info-item p {
            font-size: 0.9em;
            margin-bottom: 6px;
            color: var(--text-secondary);
        }

        .planet-info-item .planet-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            float: right;
            margin-left: 15px;
            border: 2px solid var(--border-glow);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        .fun-fact {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 107, 53, 0.1));
            padding: 12px;
            border-radius: 10px;
            margin-top: 10px;
            border-left: 4px solid var(--accent-color);
            font-style: italic;
            color: var(--text-primary);
        }

        #startScreen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 150;
            width: 90%;
            max-width: 650px;
            text-align: center;
        }

        #startScreen h1 {
            color: var(--accent-color);
            font-size: 2.5em;
            margin-bottom: 15px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            animation: titleGlow 3s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            from { text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
            to { text-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
        }

        #startScreen p {
            color: var(--text-secondary);
            font-size: 1.1em;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        #modeSelectContainer {
            margin: 20px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            font-size: 1.1em;
            color: var(--text-primary);
            font-weight: 500;
        }

        #modeSelect {
            padding: 12px 16px;
            border-radius: 10px;
            border: 2px solid var(--border-glow);
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            color: var(--text-primary);
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Noto Sans KR', sans-serif;
        }

        #modeSelect:hover {
            border-color: var(--primary-color);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        #modeSelect option {
            background: var(--card-bg);
            color: var(--text-primary);
        }

        #modeDescription {
            margin: 15px 0 25px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.95em;
            color: var(--text-secondary);
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.4;
        }

        .tutorial-section {
            background: rgba(255, 255, 255, 0.03);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 4px solid var(--primary-color);
        }

        .tutorial-section h3 {
            color: var(--primary-color);
            margin-bottom: 12px;
            font-family: 'Orbitron', sans-serif;
        }

        .tutorial-step {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .tutorial-step-number {
            background: var(--primary-color);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 12px;
            font-size: 0.8em;
        }

        .comparison-chart {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .chart-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chart-item h5 {
            color: var(--accent-color);
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .chart-bar {
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 5px 0;
        }

        .chart-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            border-radius: 10px;
            transition: width 1s ease-out;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            #startScreen h1 { font-size: 2em; }
            .modal-content { padding: 20px; max-height: 80vh; }
            .planet-info-grid { grid-template-columns: 1fr; gap: 15px; }
            .game-ui-element { padding: 8px 12px; font-size: 0.9em; }
            #powerBarContainer { width: 220px; height: 32px; }
            #draftInfoPanel { max-width: 350px; bottom: 20px; }
            .comparison-chart { grid-template-columns: 1fr; }
            .tutorial-step { flex-direction: column; text-align: center; }
            .tutorial-step-number { margin: 0 0 8px 0; }
        }

        @media (max-width: 480px) {
            #startScreen h1 { font-size: 1.6em; }
            .modal-content { padding: 15px; }
            .button { padding: 10px 20px; font-size: 0.9em; }
            .game-ui-element { padding: 6px 10px; font-size: 0.8em; }
            #powerBarContainer { width: 180px; height: 28px; }
            .player-picks-ui img { width: 24px; height: 24px; }
        }

        /* Loading Animation */
        .loading-spinner {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #00b4d8;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="turnIndicator" class="game-ui-element" style="display: none;">
        <i class="fas fa-user"></i> P1의 턴
    </div>
    
    <div id="aliveCount" class="game-ui-element" style="display: none;">
        <i class="fas fa-chart-bar"></i> P1: 3 | P2: 3
    </div>
    
    <div id="instructions" class="game-ui-element" style="display: none;">
        <i class="fas fa-info-circle"></i> 행성 클릭 후 반대방향으로 드래그<br>
        <i class="fas fa-keyboard"></i> SPACE: 최대 파워 | R: 재시작<br>
        <i class="fas fa-question-circle"></i> H: 도움말
    </div>

    <div id="draftInfoPanel" class="ui-panel">
        <h3 id="draftPlanetName">
            <i class="fas fa-globe"></i> 행성 이름
        </h3>
        <p id="draftPlanetDesc">행성 설명이 여기에 표시됩니다.</p>
        <div class="stat-bar-container">
            <span class="stat-bar-label">크기:</span>
            <div class="stat-bar">
                <div id="draftStatSize" class="stat-bar-fill"></div>
            </div>
            <span id="draftStatSizeValue" class="stat-bar-value">0</span>
        </div>
        <div class="stat-bar-container">
            <span class="stat-bar-label">밀도:</span>
            <div class="stat-bar">
                <div id="draftStatDensity" class="stat-bar-fill" style="background: linear-gradient(90deg, #8A2BE2, #9932CC);"></div>
            </div>
            <span id="draftStatDensityValue" class="stat-bar-value">0</span>
        </div>
        <div class="stat-bar-container">
            <span class="stat-bar-label">중력:</span>
            <div class="stat-bar">
                <div id="draftStatGravity" class="stat-bar-fill" style="background: linear-gradient(90deg, #00BFFF, #1E90FF);"></div>
            </div>
            <span id="draftStatGravityValue" class="stat-bar-value">0</span>
        </div>
    </div>

    <div id="powerBarContainer">
        <div id="powerBarFill"></div>
        <div id="powerBarText">
            <i class="fas fa-bolt"></i> 파워: 0%
        </div>
    </div>

    <div id="gameMessages" class="game-ui-element" style="display: none;">
        <i class="fas fa-comment"></i> 게임 메시지
    </div>

    <div id="p1Picks" class="player-picks-ui" style="display:none;">
        <i class="fas fa-user" style="color: #ff6464;"></i> P1 선택:
    </div>
    
    <div id="p2Picks" class="player-picks-ui" style="display:none;">
        <i class="fas fa-user" style="color: #6464ff;"></i> P2 선택:
    </div>
    
    <!-- Game End Modal -->
    <div id="endGameModal" class="modal">
        <div class="modal-content">
            <button class="close-button" onclick="document.getElementById('endGameModal').style.display='none'">
                <i class="fas fa-times"></i>
            </button>
            <h2 id="winnerMessage">
                <i class="fas fa-trophy"></i> 승리 메시지
            </h2>
            <p id="congratsMessage">축하 메시지</p>
            <button id="restartButton" class="button">
                <i class="fas fa-redo"></i> 다시 플레이 (R)
            </button>
        </div>
    </div>

    <!-- Tutorial Modal -->
    <div id="tutorialModal" class="modal">
        <div class="modal-content">
            <button class="close-button" onclick="document.getElementById('tutorialModal').style.display='none'">
                <i class="fas fa-times"></i>
            </button>
            <h2><i class="fas fa-graduation-cap"></i> 게임 설명서</h2>
            
            <div class="tutorial-section">
                <h3><i class="fas fa-gamepad"></i> 게임 목표</h3>
                <p>태양계의 행성들을 이용해 상대방의 행성을 모두 맵 밖으로 밀어내거나, 컬링 모드에서 높은 점수를 획득하세요!</p>
            </div>

            <div class="tutorial-section">
                <h3><i class="fas fa-mouse"></i> 조작 방법</h3>
                <div class="tutorial-step">
                    <div class="tutorial-step-number">1</div>
                    <div>자신의 행성을 마우스로 클릭하여 선택</div>
                </div>
                <div class="tutorial-step">
                    <div class="tutorial-step-number">2</div>
                    <div>발사하고 싶은 반대 방향으로 드래그</div>
                </div>
                <div class="tutorial-step">
                    <div class="tutorial-step-number">3</div>
                    <div>마우스를 놓아서 행성 발사</div>
                </div>
                <div class="tutorial-step">
                    <div class="tutorial-step-number">4</div>
                    <div>SPACE 키로 최대 파워 설정 가능</div>
                </div>
            </div>

            <div class="tutorial-section">
                <h3><i class="fas fa-star"></i> 게임 모드</h3>
                <p><strong>알까기 모드:</strong> 상대방의 모든 행성을 맵 밖으로 밀어내면 승리</p>
                <p><strong>컬링 모드:</strong> 3라운드 동안 중앙 원에 가까이 행성을 위치시켜 점수 획득</p>
            </div>

            <div class="tutorial-section">
                <h3><i class="fas fa-lightbulb"></i> 전략 팁</h3>
                <p>• 큰 행성은 무겁고 강력하지만 움직이기 어려움</p>
                <p>• 작은 행성은 빠르게 움직이지만 충돌시 밀려남</p>
                <p>• 중력을 이용해 궤도를 활용하세요</p>
                <p>• 태양의 강한 중력을 전략적으로 활용</p>
            </div>

            <button class="button" onclick="document.getElementById('tutorialModal').style.display='none'">
                <i class="fas fa-check"></i> 이해했습니다
            </button>
        </div>
    </div>

    <!-- Planet Info Modal -->
    <div id="planetInfoModal" class="modal">
        <div class="modal-content">
            <button class="close-button" onclick="document.getElementById('planetInfoModal').style.display='none'">
                <i class="fas fa-times"></i>
            </button>
            <h2><i class="fas fa-globe-americas"></i> 태양계 행성 학습</h2>
            
            <div class="comparison-chart">
                <div class="chart-item">
                    <h5>크기 비교 (지구=1)</h5>
                    <div class="chart-bar">
                        <div class="chart-fill" style="width: 100%;" data-planet="earth"></div>
                    </div>
                    <small>지구 기준</small>
                </div>
                <div class="chart-item">
                    <h5>거리 비교 (AU)</h5>
                    <div class="chart-bar">
                        <div class="chart-fill" style="width: 100%;" data-planet="distance"></div>
                    </div>
                    <small>태양으로부터</small>
                </div>
            </div>

            <div id="planetInfoGrid" class="planet-info-grid"></div>
            
            <button id="closePlanetInfoBtn" class="button">
                <i class="fas fa-arrow-left"></i> 돌아가기
            </button>
        </div>
    </div>

    <!-- Quiz Modal -->
    <div id="quizModal" class="modal">
        <div class="modal-content">
            <button class="close-button" onclick="document.getElementById('quizModal').style.display='none'">
                <i class="fas fa-times"></i>
            </button>
            <h2><i class="fas fa-brain"></i> 태양계 퀴즈</h2>
            <div id="quizContent">
                <div id="quizQuestion"></div>
                <div id="quizOptions"></div>
                <div id="quizResult" style="display: none;"></div>
                <div id="quizScore">점수: <span id="currentScore">0</span> / <span id="totalQuestions">0</span></div>
                <button id="nextQuizBtn" class="button" style="display: none;" onclick="nextQuiz()">
                    <i class="fas fa-arrow-right"></i> 다음 문제
                </button>
                <button id="startQuizBtn" class="button" onclick="startQuiz()">
                    <i class="fas fa-play"></i> 퀴즈 시작
                </button>
            </div>
        </div>
    </div>

    <!-- Debug Panel -->
    <div id="debugPanel" style="display: none; position: fixed; top: 10px; right: 300px; background: rgba(0,0,0,0.8); color: white; padding: 10px; border-radius: 8px; font-family: monospace; font-size: 12px; z-index: 200; max-width: 250px;">
        <h4 style="margin: 0 0 8px 0; color: #00ff00;">🔧 디버그 모드</h4>
        <div id="debugInfo"></div>
        <button onclick="toggleDebugMode()" style="margin-top: 8px; padding: 4px 8px; background: #333; color: white; border: 1px solid #666; border-radius: 4px; cursor: pointer;">
            디버그 모드 끄기
        </button>
    </div>

    <!-- Learning Progress Tracker -->
    <div id="learningProgress" style="display: none; position: fixed; top: 20px; right: 20px; background: var(--card-bg); backdrop-filter: blur(15px); border: 1px solid var(--border-glow); border-radius: 12px; padding: 15px; color: white; z-index: 150; max-width: 250px;">
        <h4 style="margin: 0 0 10px 0; color: var(--accent-color);">📚 학습 진행도</h4>
        <div id="progressBars"></div>
        <div style="margin-top: 10px; font-size: 12px; color: var(--text-secondary);">
            총 플레이 시간: <span id="totalPlayTime">0분</span>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="ui-panel">
        <h1><i class="fas fa-rocket"></i> 태양계 알까기</h1>
        <p>우주를 배경으로 펼쳐지는 전략 시뮬레이션 게임!<br>
        실제 태양계 행성들의 물리 법칙을 체험하며 전략적 사고력을 기르세요.</p>
        
        <div id="modeSelectContainer">
            <label for="modeSelect">
                <i class="fas fa-cog"></i> 게임 모드:
            </label>
            <select id="modeSelect">
                <option value="alggagi" selected>🎯 알까기 모드</option>
                <option value="culling">🥌 컬링 모드</option>
            </select>
        </div>
        
        <div id="modeDescription">
            행성들을 이용해 상대방의 행성을 모두 맵 밖으로 밀어내세요.
        </div>
        
        <button id="startGameBtn" class="button">
            <i class="fas fa-play"></i> 게임 시작
        </button>
        
        <button id="learnPlanetsBtn" class="button secondary">
            <i class="fas fa-book"></i> 행성 학습
        </button>
        
        <button id="tutorialBtn" class="button secondary">
            <i class="fas fa-question-circle"></i> 게임 설명
        </button>
        
        <button id="quizBtn" class="button secondary">
            <i class="fas fa-brain"></i> 태양계 퀴즈
        </button>
        
        <button id="debugModeBtn" class="button secondary" style="font-size: 0.8em;">
            <i class="fas fa-bug"></i> 디버그 모드
        </button>
    </div>

    <script type="module">
        // Enhanced Solar System Educational Game
        // Improved with modern UI/UX, debugging, and educational content

        // --- Constants and Global Variables ---
        let canvas, ctx;
        let spaceBackground;
        let currentGameState = null;
        let gameRunningState = "menu";
        let isDragging = false;
        let dragJustStarted = false;
        let selectedPlanet = null;
        let startDragPos = { x: 0, y: 0 };
        let trajectoryPoints = [];
        let lastTime = 0;
        let powerAmount = 0;
        let isGameOver = false;
        let gameLoop = null;
        let draftState = null;
        let draftHandleClick = null;
        let draftHandleMouseMove = null;
        let draftHandleKeyDown = null;
        const pickedPlanets = { P1: [], P2: [] };
        let npcPlanets = [];
        let uiInstructions;
        let debugMode = false;

        // --- Educational Quiz System ---
        const quizQuestions = [
            {
                question: "태양계에서 가장 큰 행성은 무엇인가요?",
                options: ["지구", "목성", "토성", "해왕성"],
                correct: 1,
                explanation: "목성은 태양계에서 가장 큰 행성으로, 지구보다 11배나 큽니다!",
                category: "크기"
            },
            {
                question: "태양에서 가장 가까운 행성은?",
                options: ["금성", "수성", "지구", "화성"],
                correct: 1,
                explanation: "수성은 태양에서 가장 가까운 행성입니다. 하지만 금성이 더 뜨거워요!",
                category: "거리"
            },
            {
                question: "어떤 행성이 거꾸로 자전하나요?",
                options: ["지구", "화성", "금성", "목성"],
                correct: 2,
                explanation: "금성은 다른 행성들과 반대 방향으로 자전합니다. 태양이 서쪽에서 떠요!",
                category: "운동"
            },
            {
                question: "토성의 가장 특별한 특징은?",
                options: ["가장 크다", "아름다운 고리", "가장 빠르다", "가장 뜨겁다"],
                correct: 1,
                explanation: "토성은 아름다운 고리로 유명합니다. 수십억 개의 얼음과 바위 조각으로 이루어져 있어요!",
                category: "특징"
            },
            {
                question: "지구의 자전축은 몇 도 기울어져 있나요?",
                options: ["0도", "23.4도", "45도", "90도"],
                correct: 1,
                explanation: "지구의 자전축은 23.4도 기울어져 있어서 계절이 생깁니다!",
                category: "지구"
            }
        ];

        let currentQuiz = {
            questions: [],
            currentIndex: 0,
            score: 0,
            categories: {}
        };

        // --- Learning Progress Tracking ---
        let learningProgress = {
            startTime: null,
            totalPlayTime: 0,
            planetsLearned: new Set(),
            quizzesTaken: 0,
            correctAnswers: 0,
            gamesPlayed: 0,
            strategiesUsed: new Set()
        };

        // --- Enhanced Educational Planet Data ---
        const planets_data_template = [
            {
                "name": "태양", "color": '#FFFF00', "size": 60, "mass": 150, "id": "sun",
                "texture_colors": { base: '#FFD700', corona: ['#FFFACD', '#FFE4B5', '#FFDEAD'], spots: ['#FFA500', '#FF8C00']},
                "desc": "태양계의 중심에 있는 항성으로, 모든 행성들이 태양 주위를 공전합니다.",
                "type": "star", axialTiltDeg: 7.25, orbitalPeriod: 0, density: 1.41, surfaceGravity: 27.9, rotationPeriod: 0.0001,
                "distanceFromSun": 0, "temperature": 5778, "moons": 0,
                "funFact": "태양은 매초 400만 톤의 질량을 에너지로 변환합니다! 이는 핵융합 반응 때문입니다.",
                "educationalNote": "태양의 중력은 지구보다 28배나 강해서, 만약 태양에 떨어진다면 엄청난 속도로 가속됩니다.",
                "gameStrategy": "태양의 강력한 중력을 이용해 행성의 궤도를 바꿀 수 있습니다. 태양 근처로 행성을 보내면 중력 가속을 받아 더 빠르게 움직입니다."
            },
            {
                "name": "수성", "color": '#A9A9A9', "size": 10, "mass": 0.06, "id": "mercury",
                "texture_colors": { base: '#808080', craters_dark: '#606060', craters_light: '#A0A0A0'},
                "desc": "태양에 가장 가까운 행성으로 작고 빠르며, 표면은 크레이터로 가득합니다.",
                "type": "rocky_cratered", axialTiltDeg: 0.03, orbitalPeriod: 88, density: 5.43, surfaceGravity: 0.38, rotationPeriod: 0.005,
                "distanceFromSun": 0.39, "temperature": 167, "moons": 0,
                "funFact": "수성의 하루는 지구의 176일과 같습니다! 자전이 매우 느리기 때문입니다.",
                "educationalNote": "수성은 밀도가 높아서 작지만 무겁습니다. 이는 큰 철 핵을 가지고 있기 때문입니다.",
                "gameStrategy": "수성은 작지만 밀도가 높아 의외로 무겁습니다. 다른 행성을 밀어낼 때 생각보다 큰 힘을 발휘할 수 있어요."
            },
            {
                "name": "금성", "color": '#F5DEB3', "size": 20, "mass": 0.82, "id": "venus",
                "texture_colors": { base: '#EEDC82', clouds: ['#FFF8DC', '#FAF0E6', '#FFEBCD']},
                "desc": "두꺼운 황산 구름으로 덮여 있으며, 온실효과로 인해 태양계에서 가장 뜨거운 행성입니다.",
                "type": "rocky_cloudy", axialTiltDeg: 177.4, orbitalPeriod: 225, density: 5.24, surfaceGravity: 0.90, rotationPeriod: 0.01,
                "distanceFromSun": 0.72, "temperature": 464, "moons": 0,
                "funFact": "금성은 거꾸로 자전합니다! 태양이 서쪽에서 뜨고 동쪽으로 집니다.",
                "educationalNote": "금성의 대기압은 지구의 90배나 됩니다. 마치 깊은 바다 밑에 있는 것과 같죠!",
                "gameStrategy": "금성은 크기와 질량이 지구와 비슷해 균형 잡힌 플레이가 가능합니다. 공격과 수비 모두에 적합해요."
            },
            {
                "name": "지구", "color": '#6495ED', "size": 22, "mass": 1.0, "id": "earth",
                "texture_colors": { ocean: '#4682B4', land: ['#228B22', '#8FBC8F', '#D2B48C'], cloud: 'rgba(240,248,255,0.7)'},
                "desc": "우리가 살고 있는 행성으로, 액체 상태의 물과 생명체가 존재하는 유일한 행성입니다.",
                "type": "earth-like", axialTiltDeg: 23.44, orbitalPeriod: 365, density: 5.51, surfaceGravity: 1.00, rotationPeriod: 0.003,
                "distanceFromSun": 1.0, "temperature": 15, "moons": 1,
                "funFact": "지구는 초속 30km로 태양 주위를 돌고 있습니다. 1년 동안 9억 4천만 km를 여행해요!",
                "educationalNote": "지구의 자전축이 23.4도 기울어져 있어서 계절이 생깁니다.",
                "gameStrategy": "지구는 게임의 기준이 되는 행성입니다. 모든 스탯이 표준적이어서 초보자가 사용하기 좋아요."
            },
            {
                "name": "화성", "color": '#CD5C5C', "size": 15, "mass": 0.11, "id": "mars",
                "texture_colors": { base: '#BC8F8F', dust: ['#D2B48C', '#CD853F'], ice_caps: '#FFFFFF', craters: '#A0522D'},
                "desc": "붉은 행성이라 불리며, 극지방에 얼음이 있고 과거에 물이 흘렀던 흔적이 발견됩니다.",
                "type": "rocky_ice_caps", axialTiltDeg: 25.19, orbitalPeriod: 687, density: 3.93, surfaceGravity: 0.38, rotationPeriod: 0.0031,
                "distanceFromSun": 1.52, "temperature": -65, "moons": 2,
                "funFact": "화성의 하루는 지구와 거의 같아요! 24시간 37분입니다.",
                "educationalNote": "화성에서는 먼지 폭풍이 행성 전체를 덮을 수 있습니다. 몇 달 동안 지속되기도 해요!",
                "gameStrategy": "화성은 작고 가벼워서 빠르게 움직일 수 있습니다. 기습 공격이나 정밀한 조준에 적합해요."
            },
            {
                "name": "목성", "color": '#DEB887', "size": 45, "mass": 318, "id": "jupiter",
                "texture_colors": { base: '#D2B48C', bands_light: ['#F5DEB3', '#FFEBCD'], bands_dark: ['#A0522D', '#8B4513'], spot: '#C19A6B'},
                "desc": "태양계에서 가장 큰 가스 행성으로, 대적점이라는 거대한 폭풍이 수백 년째 지속되고 있습니다.",
                "type": "gas_giant_bands_spot", axialTiltDeg: 3.13, orbitalPeriod: 4333, density: 1.33, surfaceGravity: 2.53, rotationPeriod: 0.0015,
                "distanceFromSun": 5.2, "temperature": -110, "moons": 95,
                "funFact": "목성의 대적점은 지구 3개가 들어갈 만큼 큰 폭풍입니다!",
                "educationalNote": "목성은 태양계의 '청소부' 역할을 합니다. 강한 중력으로 소행성들을 끌어당겨 지구를 보호해요.",
                "gameStrategy": "목성은 가장 크고 무거운 행성입니다. 움직이기는 어렵지만 한 번 움직이면 막을 수 없는 파괴력을 가집니다!"
            },
            {
                "name": "토성", "color": '#F0E68C', "size": 40, "mass": 95, "id": "saturn",
                "texture_colors": { body: '#EEE8AA', rings: ['rgba(210,180,140,0.7)', 'rgba(240,220,190,0.6)', 'rgba(188,150,120,0.5)']},
                "desc": "아름다운 고리로 유명한 가스 행성입니다. 밀도가 낮아서 물에 뜰 수 있습니다.",
                "type": "gas_giant_rings", axialTiltDeg: 26.73, orbitalPeriod: 10759, density: 0.69, surfaceGravity: 1.07, rotationPeriod: 0.0016,
                "distanceFromSun": 9.5, "temperature": -140, "moons": 146,
                "funFact": "토성의 고리는 수십억 개의 얼음과 바위 조각으로 이루어져 있어요!",
                "educationalNote": "토성은 물보다 가볍습니다. 거대한 바다가 있다면 토성이 둥둥 떠다닐 거예요!",
                "gameStrategy": "토성은 크지만 밀도가 낮아 목성보다 가벼워요. 고리가 있어서 회전 효과가 독특합니다."
            },
            {
                "name": "천왕성", "color": '#AFEEEE', "size": 30, "mass": 14.5, "id": "uranus",
                "texture_colors": { body: '#ADD8E6', atmosphere: ['#B0E0E6', '#AFEEEE'], rings_faint: 'rgba(200,220,220,0.3)'},
                "desc": "옆으로 누워서 자전하는 독특한 얼음 행성입니다. 메탄 때문에 푸른빛을 띱니다.",
                "type": "ice_giant_rings", axialTiltDeg: 97.77, orbitalPeriod: 30687, density: 1.27, surfaceGravity: 0.89, rotationPeriod: 0.0025,
                "distanceFromSun": 19.2, "temperature": -195, "moons": 27,
                "funFact": "천왕성의 자전축은 98도 기울어져 있어서 옆으로 굴러다니는 것 같아요!",
                "educationalNote": "천왕성의 극지방은 42년 동안 계속 겨울이거나 여름입니다.",
                "gameStrategy": "천왕성은 특이한 자전축 때문에 예측하기 어려운 움직임을 보입니다. 고급 전략에 활용해보세요."
            },
            {
                "name": "해왕성", "color": '#6495ED', "size": 28, "mass": 17, "id": "neptune",
                "texture_colors": { body: '#4169E1', spots_clouds: ['#5F9EA0', '#000080', 'rgba(173,216,230,0.4)']},
                "desc": "태양계에서 가장 바람이 강한 행성으로, 시속 2000km의 바람이 불기도 합니다.",
                "type": "ice_giant_spot_clouds", axialTiltDeg: 28.32, orbitalPeriod: 60190, density: 1.64, surfaceGravity: 1.14, rotationPeriod: 0.0023,
                "distanceFromSun": 30.1, "temperature": -200, "moons": 16,
                "funFact": "해왕성에서는 다이아몬드 비가 내릴 수도 있어요! 높은 압력과 온도 때문입니다.",
                "educationalNote": "해왕성은 수학으로 발견된 첫 번째 행성입니다. 천왕성의 궤도 이상을 설명하려다 발견했어요!",
                "gameStrategy": "해왕성은 강한 바람을 가진 행성입니다. 게임에서는 충돌 후 더 멀리 튕겨나가는 특성이 있어요."
            }
        ];

        // --- Enhanced Physics Engine ---
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : {r:255, g:255, b:255};
        }

        class Particle {
            constructor(x, y, color, size = 2, life = 30, vxOverride = null, vyOverride = null) {
                this.x = x;
                this.y = y;
                this.vx = vxOverride !== null ? vxOverride : (Math.random() - 0.5) * 4;
                this.vy = vyOverride !== null ? vyOverride : (Math.random() - 0.5) * 4;
                this.color = color;
                this.baseSize = size;
                this.life = life;
                this.age = 0;
                this.maxLife = life;
                this.damping = 0.97;
            }

            update(deltaTime) {
                this.x += this.vx * (deltaTime * 60);
                this.y += this.vy * (deltaTime * 60);
                this.vx *= Math.pow(this.damping, deltaTime * 60);
                this.vy *= Math.pow(this.damping, deltaTime * 60);
                this.age++;
                return this.age < this.maxLife;
            }

            draw(context) {
                const progress = this.age / this.maxLife;
                const alpha = Math.max(0, 1 - progress * progress);
                const currentSize = Math.max(0.5, this.baseSize * (1 - progress * 0.7));

                if (currentSize < 0.5 || alpha <= 0) return;

                const rgb = hexToRgb(this.color);
                context.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
                context.beginPath();
                context.arc(this.x, this.y, currentSize, 0, Math.PI * 2);
                context.fill();
            }
        }

        function detectCollision(p1, p2) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const distSq = dx * dx + dy * dy;
            const minDist = p1.size + p2.size;
            return distSq < minDist * minDist;
        }

        function resolveCollision(p1, p2, dt) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            let dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist === 0) {
                dist = 0.1;
            }
            
            const nx = dx / dist;
            const ny = dy / dist;
            
            const overlap = (p1.size + p2.size) - dist;
            if (overlap > 0) {
                const m1 = Math.max(0.1, p1.mass);
                const m2 = Math.max(0.1, p2.mass);
                const totalMass = m1 + m2;
                
                const p1Ratio = m2 / totalMass;
                const p2Ratio = m1 / totalMass;
                
                p1.x -= nx * overlap * p1Ratio * 0.5;
                p1.y -= ny * overlap * p1Ratio * 0.5;
                p2.x += nx * overlap * p2Ratio * 0.5;
                p2.y += ny * overlap * p2Ratio * 0.5;
            }
            
            const m1 = Math.max(0.1, p1.mass);
            const m2 = Math.max(0.1, p2.mass);
            
            const tx = -ny;
            const ty = nx;
            
            const v1n = p1.vx * nx + p1.vy * ny;
            const v1t = p1.vx * tx + p1.vy * ty;
            const v2n = p2.vx * nx + p2.vy * ny;
            const v2t = p2.vx * tx + p2.vy * ty;
            
            const e = 0.8;
            
            let v1nAfter = ((m1 - e * m2) * v1n + (1 + e) * m2 * v2n) / (m1 + m2);
            let v2nAfter = ((m2 - e * m1) * v2n + (1 + e) * m1 * v1n) / (m1 + m2);
            
            p1.vx = v1nAfter * nx + v1t * tx;
            p1.vy = v1nAfter * ny + v1t * ty;
            p2.vx = v2nAfter * nx + v2t * ty;
            p2.vy = v2nAfter * ny + v2t * ty;
            
            return {
                x: p1.x + nx * p1.size,
                y: p1.y + ny * p1.size,
                energy: Math.abs(v1nAfter - v1n) + Math.abs(v2nAfter - v2n)
            };
        }

        function applyGravity(p1, p2, dt, G = 0.1) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const distSq = dx * dx + dy * dy;
            if (distSq === 0) return;
            const dist = Math.sqrt(distSq);
            const minGravDist = p1.size + p2.size + 2;
            
            if (dist > minGravDist) {
                let gravityMult = 1;
                if (p1.type === 'star') gravityMult *= 2.5;
                if (p2.type === 'star') gravityMult *= 2.5;

                let forceMagnitude = G * gravityMult * (p1.mass * p2.mass) / distSq;
                const maxForceAllowed = 30;
                forceMagnitude = Math.min(forceMagnitude, maxForceAllowed);
                
                const forceX = forceMagnitude * dx / dist;
                const forceY = forceMagnitude * dy / dist;

                if (p1.mass > 0) {
                    p1.vx += forceX / p1.mass * dt;
                    p1.vy += forceY / p1.mass * dt;
                }
                if (p2.mass > 0) {
                    p2.vx -= forceX / p2.mass * dt;
                    p2.vy -= forceY / p2.mass * dt;
                }
            }
        }

        function createCollisionParticles(x, y, energy, color1, color2) {
            const particles = [];
            const numParticles = Math.min(25, Math.max(8, Math.floor(energy * 2.5)));
            
            for (let i = 0; i < numParticles; i++) {
                const speed = Math.random() * 2.5 + (energy * 0.35);
                const angle = Math.random() * Math.PI * 2;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                
                const color = Math.random() < 0.5 ? color1 : color2;
                const size = Math.random() * 2.5 + 1.5 + (energy * 0.15);
                const life = Math.random() * 15 + 25 + (energy * 6);
                
                particles.push(new Particle(x, y, color, size, life, vx, vy));
            }
            return particles;
        }

        function isOutOfBounds(planet, mapWidth, mapHeight, boundaryData) {
            if (boundaryData.type === "circle") {
                const centerX = boundaryData.center ? boundaryData.center.x * mapWidth : mapWidth / 2;
                const centerY = boundaryData.center ? boundaryData.center.y * mapHeight : mapHeight / 2;
                const radius = boundaryData.radius || Math.min(mapWidth, mapHeight) / 2 - 20;
                const distFromCenter = Math.hypot(planet.x - centerX, planet.y - centerY);
                return distFromCenter > radius + planet.size;
            } else {
                const margin = planet.size * 0.5;
                return (
                    planet.x < -margin ||
                    planet.x > mapWidth + margin ||
                    planet.y < -margin ||
                    planet.y > mapHeight + margin
                );
            }
        }

        // --- Enhanced Planet Class ---
        class Planet {
            constructor(x, y, data, owner = null) {
                this.x = x;
                this.y = y;
                this.initialX = x;
                this.initialY = y;
                this.vx = 0;
                this.vy = 0;
                this.data = data;
                this.size = data.size;
                this.mass = data.mass;
                this.baseColor = data.color;
                this.owner = owner;
                this.selected = false;
                this.out = false;
                
                this.axialTilt = data.axialTiltDeg !== undefined ? data.axialTiltDeg * (Math.PI / 180) : (Math.random() * 45 - 22.5) * (Math.PI / 180);
                this.rotationPeriodFactor = data.rotationPeriod !== undefined ? data.rotationPeriod : Math.random() * 0.009 + 0.001;
                this.angle = Math.random() * Math.PI * 2;
                this.rotationSpeed = this.rotationPeriodFactor * (Math.random() < 0.5 ? 1 : -1);

                this.trails = [];
                this.particles = [];
                
                this.planetType = data.type || "rocky_cratered";
                this.textureColors = data.texture_colors;
                this.textureCanvas = this.buildTexture();
                this.ringCanvas = (this.planetType.includes("rings")) ? this.buildRings() : null;
            }

            _drawShadedCircle(textureCtx, planetSize, baseColorStr, lightAngle = Math.PI / 4, shadowIntensity = 0.3, highlightIntensity = 0.15) {
                textureCtx.save();
                textureCtx.beginPath();
                textureCtx.arc(planetSize, planetSize, planetSize, 0, Math.PI * 2);
                textureCtx.clip();

                const shadowX = planetSize + Math.cos(lightAngle + Math.PI) * planetSize * 0.5;
                const shadowY = planetSize + Math.sin(lightAngle + Math.PI) * planetSize * 0.5;
                const shadowGrad = textureCtx.createRadialGradient(shadowX, shadowY, planetSize * 0.3, shadowX, shadowY, planetSize * 1.5);
                
                shadowGrad.addColorStop(0, `rgba(0, 0, 0, ${shadowIntensity})`);
                shadowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                // Fill base color
                textureCtx.fillStyle = baseColorStr;
                textureCtx.fill();
                
                // Add shadow
                textureCtx.fillStyle = shadowGrad;
                textureCtx.fill();
                
                // Add highlight
                const highlightX = planetSize + Math.cos(lightAngle) * planetSize * 0.3;
                const highlightY = planetSize + Math.sin(lightAngle) * planetSize * 0.3;
                const highlightGrad = textureCtx.createRadialGradient(highlightX, highlightY, 0, highlightX, highlightY, planetSize * 0.8);
                highlightGrad.addColorStop(0, `rgba(255, 255, 255, ${highlightIntensity})`);
                highlightGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                textureCtx.fillStyle = highlightGrad;
                textureCtx.fill();
                
                textureCtx.restore();
            }

            buildTexture() {
                const d = this.size * 2;
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = d;
                tempCanvas.height = d;
                const texCtx = tempCanvas.getContext('2d');
                const lightAngleForShading = Math.random() * Math.PI * 2;

                texCtx.fillStyle = this.baseColor;
                texCtx.beginPath();
                texCtx.arc(this.size, this.size, this.size, 0, Math.PI * 2);
                texCtx.fill();

                switch (this.planetType) {
                    case "star": this._createSunTexture(texCtx); break;
                    case "earth-like":
                        this._createEarthTexture(texCtx);
                        this._drawShadedCircle(texCtx, this.size, this.textureColors.ocean, lightAngleForShading, 0.4, 0.2);
                        break;
                    case "gas_giant_bands_spot": this._createGasGiantTexture(texCtx, lightAngleForShading); break;
                    case "rocky_cratered": case "rocky_cloudy": case "rocky_ice_caps":
                        this._createRockyPlanetTexture(texCtx, lightAngleForShading);
                        break;
                    case "ice_giant_spot_clouds":
                    case "ice_giant_rings":
                        this._createIceGiantTexture(texCtx, lightAngleForShading);
                        break;
                    default: this._drawShadedCircle(texCtx, this.size, this.baseColor, lightAngleForShading); break;
                }
                return tempCanvas;
            }

            _createSunTexture(texCtx) {
                texCtx.save();
                texCtx.beginPath();
                texCtx.arc(this.size, this.size, this.size, 0, Math.PI * 2);
                texCtx.clip();
                texCtx.fillStyle = this.textureColors.base;
                texCtx.fill();

                for (let i = 0; i < 5 + Math.random() * 5; i++) {
                    const coronaColor = this.textureColors.corona[Math.floor(Math.random() * this.textureColors.corona.length)];
                    const alpha = Math.random() * 0.3 + 0.1;
                    const currentRadius = this.size * (1.1 + i * 0.08 + Math.sin(Date.now() * 0.0005 + i) * 0.05);
                    const rgb = hexToRgb(coronaColor);
                    texCtx.fillStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},${alpha})`;
                    texCtx.beginPath();
                    texCtx.arc(this.size, this.size, currentRadius, 0, Math.PI * 2);
                    texCtx.fill();
                }
                for (let i = 0; i < 50 + Math.random() * 50; i++) {
                    const spotColor = this.textureColors.spots[Math.floor(Math.random() * this.textureColors.spots.length)];
                    const spotAlpha = Math.random() * 0.4 + 0.2;
                    const spotR = this.size * (Math.random() * 0.08 + 0.02);
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * this.size * 0.9;
                    const spotX = this.size + Math.cos(angle) * dist;
                    const spotY = this.size + Math.sin(angle) * dist;
                    const rgbSpot = hexToRgb(spotColor);
                    texCtx.fillStyle = `rgba(${rgbSpot.r},${rgbSpot.g},${rgbSpot.b},${spotAlpha})`;
                    texCtx.beginPath();
                    texCtx.arc(spotX, spotY, spotR, 0, Math.PI * 2);
                    texCtx.fill();
                }
                texCtx.restore();
            }

            _createEarthTexture(texCtx) {
                texCtx.fillStyle = this.textureColors.ocean;
                texCtx.beginPath();
                texCtx.arc(this.size, this.size, this.size, 0, Math.PI * 2);
                texCtx.fill();
                for (let i = 0; i < Math.random() * 3 + 4; i++) {
                    texCtx.fillStyle = this.textureColors.land[Math.floor(Math.random() * this.textureColors.land.length)];
                    texCtx.beginPath();
                    const startAngle = Math.random() * Math.PI * 2;
                    const continentSize = Math.random() * 0.5 + 0.3;
                    for (let j = 0; j < 7; j++) {
                        const angle = startAngle + (j / 7) * Math.PI * 2 + (Math.random() - 0.5) * 0.8;
                        const dist = this.size * (Math.random() * 0.4 * continentSize + 0.5 * continentSize);
                        const px = this.size + Math.cos(angle) * dist;
                        const py = this.size + Math.sin(angle) * dist;
                        if (j === 0) texCtx.moveTo(px, py); else texCtx.lineTo(px, py);
                    }
                    texCtx.closePath();
                    texCtx.fill();
                }
                const d = this.size * 2;
                for (let i = 0; i < Math.random() * 10 + 10; i++) {
                    const cloudX = Math.random() * d;
                    const cloudY = Math.random() * d;
                    const cloudW = this.size * (Math.random() * 0.6 + 0.2);
                    const cloudH = this.size * (Math.random() * 0.3 + 0.1);
                    if (Math.hypot(cloudX - this.size, cloudY - this.size) < this.size * 0.9) {
                        texCtx.fillStyle = this.textureColors.cloud;
                        texCtx.save();
                        texCtx.translate(cloudX, cloudY);
                        texCtx.rotate(Math.random() * Math.PI * 2);
                        texCtx.beginPath();
                        texCtx.ellipse(0, 0, cloudW / 2, cloudH / 2, 0, 0, Math.PI * 2);
                        texCtx.fill();
                        texCtx.restore();
                    }
                }
            }

            _createGasGiantTexture(texCtx, lightAngleForShading) {
                texCtx.fillStyle = this.textureColors.base;
                texCtx.beginPath();
                texCtx.arc(this.size, this.size, this.size, 0, Math.PI * 2);
                texCtx.fill();
                const numBands = Math.floor(Math.random() * 5) + 5;
                const d = this.size * 2;
                for (let i = 0; i < numBands; i++) {
                    const bandY = (i / numBands) * d + (Math.random() - 0.5) * (d / numBands) * 0.5;
                    const bandH = this.size * (Math.random() * 0.15 + 0.1);
                    const bandColorLight = this.textureColors.bands_light[Math.floor(Math.random()*this.textureColors.bands_light.length)];
                    const bandColorDark = this.textureColors.bands_dark[Math.floor(Math.random()*this.textureColors.bands_dark.length)];
                    const bandColor = Math.random() < 0.6 ? bandColorLight : bandColorDark;
                    const alpha = Math.random() * 0.3 + 0.4;
                    const rgbBand = hexToRgb(bandColor);
                    texCtx.fillStyle = `rgba(${rgbBand.r},${rgbBand.g},${rgbBand.b},${alpha})`;
                    texCtx.save();
                    texCtx.beginPath();
                    texCtx.arc(this.size, this.size, this.size, 0, Math.PI*2);
                    texCtx.clip();
                    texCtx.beginPath();
                    texCtx.ellipse(this.size, bandY, this.size * 1.1, bandH, 0, 0, Math.PI * 2);
                    texCtx.fill();
                    texCtx.restore();
                }
                const spotW = this.size * (Math.random() * 0.2 + 0.3);
                const spotH = this.size * (Math.random() * 0.1 + 0.2);
                const spotX = this.size + (Math.random() - 0.5) * this.size * 0.4;
                const spotY = this.size + (Math.random() - 0.5) * this.size * 0.6;
                texCtx.fillStyle = this.textureColors.spot;
                texCtx.beginPath();
                texCtx.ellipse(spotX, spotY, spotW / 2, spotH / 2, Math.random() * 0.2 - 0.1, 0, Math.PI * 2);
                texCtx.fill();
                this._drawShadedCircle(texCtx, this.size, this.textureColors.base, lightAngleForShading, 0.5, 0.25);
            }

            _createRockyPlanetTexture(texCtx, lightAngleForShading) {
                texCtx.fillStyle = this.textureColors.base;
                texCtx.beginPath();
                texCtx.arc(this.size, this.size, this.size, 0, Math.PI * 2);
                texCtx.fill();
                const numCraters = (this.planetType === "rocky_cratered") ? (Math.random() * 20 + 20) : (Math.random() * 10 + 5);
                for (let i = 0; i < numCraters; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * this.size * 0.9;
                    const r = this.size * (Math.random() * 0.1 + 0.05);
                    const cx = this.size + Math.cos(angle) * dist;
                    const cy = this.size + Math.sin(angle) * dist;
                    const baseRgb = hexToRgb(this.textureColors.base);
                    const craterDarkColor = this.textureColors.craters_dark || `rgb(${Math.max(0,baseRgb.r-40)},${Math.max(0,baseRgb.g-40)},${Math.max(0,baseRgb.b-40)})`;
                    const craterLightColor = this.textureColors.craters_light || `rgb(${Math.min(255,baseRgb.r+30)},${Math.min(255,baseRgb.g+30)},${Math.min(255,baseRgb.b+30)})`;
                    texCtx.fillStyle = craterDarkColor;
                    texCtx.beginPath();
                    texCtx.arc(cx, cy, r, 0, Math.PI * 2);
                    texCtx.fill();
                    texCtx.fillStyle = craterLightColor;
                    texCtx.beginPath();
                    texCtx.arc(cx - r*0.2, cy - r*0.2, r*0.8, 0, Math.PI * 2);
                    texCtx.fill();
                }
                if (this.planetType === "rocky_cloudy" && this.textureColors.clouds) {
                    for (let i = 0; i < 20 + Math.random() * 10; i++) {
                        const cX = this.size + (Math.random() - 0.5) * (this.size * 2) * 0.8;
                        const cY = this.size + (Math.random() - 0.5) * (this.size * 2) * 0.8;
                        const cW = this.size * (Math.random() * 0.8 + 0.4);
                        const cH = this.size * (Math.random() * 0.5 + 0.2);
                        const cCol = this.textureColors.clouds[Math.floor(Math.random() * this.textureColors.clouds.length)];
                        const cAlpha = Math.random()*0.3 + 0.2;
                        const rgbCloud = hexToRgb(cCol);
                        texCtx.fillStyle = `rgba(${rgbCloud.r},${rgbCloud.g},${rgbCloud.b},${cAlpha})`;
                        texCtx.save();
                        texCtx.translate(cX, cY);
                        texCtx.rotate(Math.random() * Math.PI * 2);
                        texCtx.beginPath();
                        texCtx.ellipse(0, 0, cW/2, cH/2, 0, 0, Math.PI * 2);
                        texCtx.fill();
                        texCtx.filter = 'none';
                        texCtx.restore();
                    }
                }
                if (this.planetType === "rocky_ice_caps" && this.textureColors.ice_caps) {
                    texCtx.fillStyle = this.textureColors.ice_caps;
                    const capSize = this.size * (Math.random() * 0.15 + 0.2);
                    texCtx.beginPath();
                    texCtx.arc(this.size, this.size * 0.2, capSize, 0, Math.PI * 2);
                    texCtx.fill();
                    texCtx.beginPath();
                    texCtx.arc(this.size, (this.size * 2) - this.size * 0.2, capSize, 0, Math.PI * 2);
                    texCtx.fill();
                }
                this._drawShadedCircle(texCtx, this.size, this.textureColors.base, lightAngleForShading, 0.35, 0.18);
            }

            _createIceGiantTexture(texCtx, lightAngleForShading) {
                texCtx.fillStyle = this.textureColors.body;
                texCtx.beginPath();
                texCtx.arc(this.size, this.size, this.size, 0, Math.PI * 2);
                texCtx.fill();
                const numFeatures = Math.floor(Math.random() * 5) + 8;
                for (let i = 0; i < numFeatures; i++) {
                    const featureColorData = this.textureColors.spots_clouds || this.textureColors.atmosphere || [this.baseColor];
                    const featureColor = featureColorData[Math.floor(Math.random() * featureColorData.length)];
                    const alpha = Math.random() * 0.2 + 0.1;
                    const r = this.size * (Math.random() * 0.3 + 0.1);
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * this.size * 0.7;
                    const fx = this.size + Math.cos(angle) * dist;
                    const fy = this.size + Math.sin(angle) * dist;
                    let finalFeatureColor;
                    if (featureColor.startsWith('rgba')) {
                        finalFeatureColor = featureColor.replace(/,\s*\d(\.\d+)?\)/, `,${alpha})`);
                    } else {
                        const rgbFeat = hexToRgb(featureColor);
                        finalFeatureColor = `rgba(${rgbFeat.r},${rgbFeat.g},${rgbFeat.b},${alpha})`;
                    }
                    texCtx.fillStyle = finalFeatureColor;
                    texCtx.filter = 'blur(1px)';
                    texCtx.beginPath();
                    texCtx.arc(fx, fy, r, 0, Math.PI * 2);
                    texCtx.fill();
                    texCtx.filter = 'none';
                }
                this._drawShadedCircle(texCtx, this.size, this.textureColors.body, lightAngleForShading, 0.4, 0.2);
            }

            buildRings() {
                const ringWidth = this.size * 2.8;
                const ringHeight = this.size * 0.8;
                const tempRingCanvas = document.createElement('canvas');
                tempRingCanvas.width = ringWidth;
                tempRingCanvas.height = ringHeight;
                const ringCtx = tempRingCanvas.getContext('2d');
                const centerX = ringWidth / 2;
                const centerY = ringHeight / 2;
                const ringColors = this.planetType === "gas_giant_rings" ? this.textureColors.rings : (this.textureColors.rings_faint ? [this.textureColors.rings_faint] : ['rgba(200,200,200,0.3)']);
                const numRingBands = Math.floor(Math.random() * 3) + 3;
                for (let i = 0; i < numRingBands; i++) {
                    const bandColor = ringColors[Math.floor(Math.random() * ringColors.length)];
                    const outerR_W = centerX * (1 - i * 0.12);
                    const outerR_H = centerY * (1 - i * 0.12);
                    const innerR_W = outerR_W * (0.85 - i * 0.05);
                    const innerR_H = outerR_H * (0.85 - i * 0.05);
                    if (outerR_W <= 0 || outerR_H <= 0) continue;
                    ringCtx.fillStyle = bandColor;
                    ringCtx.beginPath();
                    ringCtx.ellipse(centerX, centerY, outerR_W, outerR_H, 0, 0, Math.PI * 2);
                    if (innerR_W > 0 && innerR_H > 0) {
                        ringCtx.ellipse(centerX, centerY, innerR_W, innerR_H, 0, Math.PI * 2, 0, true);
                    }
                    ringCtx.fill();
                }
                return tempRingCanvas;
            }

            draw(context) {
                this.trails.forEach((trail, index) => {
                    const alpha = 0.6 * trail.alpha;
                    const trailRadius = Math.max(0.5, 1 + (this.size * 0.1) * (1 - (index / this.trails.length)));
                    if (trailRadius < 0.5 || alpha < 0.05) return;
                    const rgbBase = hexToRgb(this.baseColor);
                    context.fillStyle = `rgba(${rgbBase.r},${rgbBase.g},${rgbBase.b},${alpha})`;
                    context.beginPath();
                    context.arc(trail.x, trail.y, trailRadius, 0, Math.PI * 2);
                    context.fill();
                });

                context.save();
                context.translate(this.x, this.y);
                context.rotate(this.axialTilt);

                if (this.ringCanvas) {
                    context.save();
                    context.rotate(this.angle * 0.6);
                    context.drawImage(this.ringCanvas, -this.ringCanvas.width / 2, -this.ringCanvas.height / 2);
                    context.restore();
                }
                
                context.rotate(this.angle);
                context.drawImage(this.textureCanvas, -this.size, -this.size);
                context.restore();

                if (this.owner && this.owner !== "NPC" && this.owner !== "SYSTEM") {
                    context.fillStyle = this.owner === "P1" ? '#FF6464' : '#6464FF';
                    const gameWorldWidth = currentGameState && currentGameState.map ? currentGameState.map.width : 1200;
                    const gameWorldHeight = currentGameState && currentGameState.map ? currentGameState.map.height : 800;
                    const scale = Math.min(canvas.width / gameWorldWidth, canvas.height / gameWorldHeight);
                    const fontSize = Math.max(10, this.size * 0.4) / scale;

                    context.font = `${fontSize}px 'Orbitron', monospace`;
                    context.textAlign = "center";
                    context.fillText(this.owner, this.x, this.y + this.size + (Math.max(12, this.size * 0.5) + 2) );
                }
                if (this.selected) {
                    const pulseFactor = (1 + Math.sin(Date.now() * 0.008)) / 2;
                    const pulseSizeAdd = 2 + 3 * pulseFactor;
                    const pulseAlpha = 0.5 + 0.5 * pulseFactor;
                    context.strokeStyle = `rgba(0, 212, 255, ${pulseAlpha})`;
                    context.lineWidth = (2 + pulseFactor);
                    context.beginPath();
                    context.arc(this.x, this.y, this.size + pulseSizeAdd, 0, Math.PI * 2);
                    context.stroke();
                }
                this.particles.forEach(p => p.draw(context));

                // Debug mode: show additional info
                if (debugMode && this.owner && this.owner !== "NPC") {
                    context.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    context.font = '10px monospace';
                    context.textAlign = 'left';
                    context.fillText(`v: ${Math.hypot(this.vx, this.vy).toFixed(1)}`, this.x - this.size, this.y - this.size - 20);
                    context.fillText(`m: ${this.mass}`, this.x - this.size, this.y - this.size - 10);
                }
            }

            update(deltaTime) {
                this.angle = (this.angle + this.rotationSpeed * (deltaTime * 60)) % (Math.PI * 2);
                const dampingFactor = 0.97;
                this.vx *= Math.pow(dampingFactor, deltaTime * 60);
                this.vy *= Math.pow(dampingFactor, deltaTime * 60);

                const prevX = this.x;
                const prevY = this.y;
                this.x += this.vx * (deltaTime * 60);
                this.y += this.vy * (deltaTime * 60);

                if (Math.hypot(this.vx, this.vy) > 0.15) {
                    this.trails.push({ x: prevX, y: prevY, alpha: 1.0 });
                }
                this.trails = this.trails
                    .map(t => ({ ...t, alpha: t.alpha - 0.03 * (deltaTime*60) }))
                    .filter(t => t.alpha > 0.05);
                if (this.trails.length > 15) {
                    this.trails.shift();
                }
                this.particles = this.particles.filter(p => p.update(deltaTime));
            }
        }

        // --- Enhanced Maps and Game Modes ---
        const maps = [
            {
                id: "basic", name: "기본 맵", description: "넓은 우주에서 행성들을 자유롭게 충돌시켜보세요.",
                width: 1200, height: 800, boundaries: { type: "rectangle", padding: 0 },
                spawnPoints: {
                    p1: [{ x: 0.2, y: 0.3 }, { x: 0.2, y: 0.5 }, { x: 0.2, y: 0.7 }],
                    p2: [{ x: 0.8, y: 0.3 }, { x: 0.8, y: 0.5 }, { x: 0.8, y: 0.7 }]
                }, obstacles: []
            }
        ];
        
        function getMapById(id) { 
            try {
                return maps.find(map => map.id === id) || maps[0];
            } catch (error) {
                console.error("Error getting map by ID:", error);
                return maps[0];
            }
        }
        
        function setupMapSelection(mapThumbContainer, modeSelect, modeDescription, onMapSelectCallback) {
            try {
                if (onMapSelectCallback) onMapSelectCallback(maps[0]);
                if(modeSelect && modeDescription) {
                    modeSelect.addEventListener('change', () => {
                        if (modeSelect.value === 'alggagi') {
                            modeDescription.innerHTML = `
                                <div style="display: flex; align-items: center; margin-bottom: 8px;">
                                    <i class="fas fa-target" style="color: var(--primary-color); margin-right: 8px;"></i>
                                    <strong style="color: var(--primary-color);">🎯 알까기 모드</strong>
                                </div>
                                <p style="margin: 0; color: var(--text-secondary); line-height: 1.4;">
                                    상대방의 모든 행성을 맵 밖으로 밀어내면 승리! 전략적으로 행성을 발사하여 상대를 제거하세요.
                                </p>
                            `;
                        } else if (modeSelect.value === 'culling') {
                            modeDescription.innerHTML = `
                                <div style="display: flex; align-items: center; margin-bottom: 8px;">
                                    <i class="fas fa-bullseye" style="color: var(--accent-color); margin-right: 8px;"></i>
                                    <strong style="color: var(--accent-color);">🥌 컬링 모드</strong>
                                </div>
                                <div style="color: var(--text-secondary); line-height: 1.4;">
                                    <p style="margin: 0 0 8px 0;">
                                        중앙의 <span style="color: var(--accent-color); font-weight: bold;">컬링 하우스</span>에 행성을 최대한 가깝게 보내세요!
                                    </p>
                                    <div style="background: rgba(255, 215, 0, 0.1); padding: 8px; border-radius: 6px; border-left: 3px solid var(--accent-color); font-size: 0.9em;">
                                        <div style="margin-bottom: 4px;">🎯 <strong>점수 체계:</strong> 중심에서 가까운 순서대로 10→7→5→3→1점</div>
                                        <div style="margin-bottom: 4px;">🏆 <strong>컬링 룰:</strong> 가장 가까운 행성의 소유자만 점수 획득</div>
                                        <div>📊 <strong>승부:</strong> 3라운드 후 총점으로 승부 결정</div>
                                    </div>
                                </div>
                            `;
                        }
                    });
                    modeSelect.dispatchEvent(new Event('change'));
                }
            } catch (error) {
                console.error("Error in setupMapSelection:", error);
            }
        }

        function initializeMapObjects(map, gameMode, width, height) {
            return { mapObjects: [] };
        }
        
        // --- Enhanced Game Modes ---
        const GAME_MODES = { ALGGAGI: 'alggagi', CULLING: 'culling' };
        
        class AlggagiMode {
            constructor() { 
                this.name = GAME_MODES.ALGGAGI; 
                this.p1PlanetsCount = 0; 
                this.p2PlanetsCount = 0; 
                this.ui = { aliveCount: null }; 
            }
            
            initialize(planets, ui) { 
                try {
                    this.ui.aliveCount = ui.aliveCount; 
                    this.updatePlanetCounts(planets); 
                } catch (error) {
                    console.error("Error initializing AlggagiMode:", error);
                }
            }
            
            updatePlanetCounts(planets) {
                try {
                    this.p1PlanetsCount = planets.filter(p => p.owner === 'P1' && !p.out).length;
                    this.p2PlanetsCount = planets.filter(p => p.owner === 'P2' && !p.out).length;
                    if (this.ui.aliveCount) {
                        if (currentGameState && currentGameState.gameMode.name === GAME_MODES.CULLING) {
                            this.ui.aliveCount.innerHTML = `<i class="fas fa-chart-bar"></i> P1 점수: ${currentGameState.p1Score.toFixed(1)} | P2 점수: ${currentGameState.p2Score.toFixed(1)} | 라운드: ${currentGameState.currentRound}/${currentGameState.maxRounds}`;
                        } else {
                            this.ui.aliveCount.innerHTML = `<i class="fas fa-chart-bar"></i> P1: ${this.p1PlanetsCount} | P2: ${this.p2PlanetsCount}`;
                        }
                        this.ui.aliveCount.style.display = 'block';
                    }
                } catch (error) {
                    console.error("Error updating planet counts:", error);
                }
            }
            
            update(planets, mapData) {
                try {
                    this.updatePlanetCounts(planets.filter(p => p.owner === 'P1' || p.owner === 'P2'));
                    let winner = null;
                    if (this.p1PlanetsCount === 0 && this.p2PlanetsCount > 0) winner = 'P2';
                    else if (this.p2PlanetsCount === 0 && this.p1PlanetsCount > 0) winner = 'P1';
                    return { winner, gameData: { p1Count: this.p1PlanetsCount, p2Count: this.p2PlanetsCount } };
                } catch (error) {
                    console.error("Error in AlggagiMode update:", error);
                    return { winner: null, gameData: {} };
                }
            }
            
            shouldEndTurn(planetsOwnedByPlayers, isCurrentlyDraggingGlobal, wasDragJustStartedThisFrame, shotFiredThisTurnGlobal) {
                return false;
            }
            
            showUI() { 
                return { turnIndicator: true, aliveCount: true, powerBar: true, playerPicks: true, instructionsUI: true }; 
            }
            
            getEndGameMessage(winner) { 
                return { 
                    winnerMsg: `🏆 ${winner} 승리!`, 
                    congratsMsg: `${winner === 'P1' ? '1번' : '2번'} 플레이어가 상대방의 모든 행성을 맵 밖으로 밀어냈습니다! 축하합니다! 🎉` 
                }; 
            }
        }

        class CullingMode extends AlggagiMode {
            constructor() {
                super();
                this.name = GAME_MODES.CULLING;
            }
            
            update(planets, mapData) {
                try {
                    this.updatePlanetCounts(planets.filter(p => p.owner === 'P1' || p.owner === 'P2'));

                    let winner = null;
                    let gameData = { p1Score: currentGameState.p1Score, p2Score: currentGameState.p2Score, currentRound: currentGameState.currentRound };

                    if (currentGameState.currentRound > currentGameState.maxRounds) {
                        if (currentGameState.p1Score > currentGameState.p2Score) {
                            winner = 'P1';
                        } else if (currentGameState.p2Score > currentGameState.p1Score) {
                            winner = 'P2';
                        } else {
                            winner = '무승부';
                        }
                    }
                    return { winner, gameData: gameData };
                } catch (error) {
                    console.error("Error in CullingMode update:", error);
                    return { winner: null, gameData: {} };
                }
            }
            
            getEndGameMessage(winner) {
                if (winner === '무승부') {
                    return { 
                        winnerMsg: `🤝 무승부!`, 
                        congratsMsg: `총 점수 P1: ${currentGameState.p1Score.toFixed(1)}, P2: ${currentGameState.p2Score.toFixed(1)}로 무승부입니다! 훌륭한 경기였습니다! 🎯` 
                    };
                }
                return { 
                    winnerMsg: `🏆 ${winner} 승리!`, 
                    congratsMsg: `${winner === 'P1' ? '1번' : '2번'} 플레이어가 총 점수 ${winner === 'P1' ? currentGameState.p1Score.toFixed(1) : currentGameState.p2Score.toFixed(1)}점으로 승리했습니다! 🥌` 
                };
            }
        }
        
        function createGameMode(modeName) {
            try {
                if (modeName === GAME_MODES.CULLING) {
                    return new CullingMode();
                }
                return new AlggagiMode();
            } catch (error) {
                console.error("Error creating game mode:", error);
                return new AlggagiMode();
            }
        }

        // --- game-renderer.js content (Simplified) ---
        function createSpaceBackground(width, height) {
            if (width <= 0 || height <= 0) {
                console.warn(`Attempted to create space background with zero dimensions: ${width}x${height}`);
                const errCanvas = document.createElement('canvas');
                errCanvas.width = 1; errCanvas.height = 1;
                return errCanvas;
            }
            const bgCanvas = document.createElement('canvas'); bgCanvas.width = width; bgCanvas.height = height;
            const bgCtx = bgCanvas.getContext('2d');
            const gradient = bgCtx.createLinearGradient(0, 0, width, height);
            gradient.addColorStop(0, '#000018'); gradient.addColorStop(0.5, '#000020'); gradient.addColorStop(1, '#000028');
            bgCtx.fillStyle = gradient; bgCtx.fillRect(0, 0, width, height);
            for (let i = 0; i < 500; i++) {
                const x = Math.random() * width; const y = Math.random() * height;
                const radius = Math.random() * 0.8 + 0.1; const brightness = Math.floor(Math.random() * 70 + 185);
                bgCtx.fillStyle = `rgb(${brightness},${brightness},${brightness})`;
                bgCtx.beginPath(); bgCtx.arc(x, y, radius, 0, Math.PI * 2); bgCtx.fill();
            }
            for (let i = 0; i < 40; i++) {
                const x = Math.random() * width; const y = Math.random() * height;
                const radius = Math.random() * 1.2 + 0.4;
                const color = Math.random() < 0.5 ? `rgba(255,255,255,0.7)` : (Math.random() < 0.5 ? `rgba(200,220,255,0.6)` : `rgba(255,220,180,0.6)`);
                bgCtx.fillStyle = color; bgCtx.beginPath(); bgCtx.arc(x, y, radius, 0, Math.PI * 2); bgCtx.fill();
                const glow = bgCtx.createRadialGradient(x, y, radius, x, y, radius * 2.5);
                glow.addColorStop(0, color.replace(/,\s*\d(\.\d+)?\)/, ',0.5)')); glow.addColorStop(1, 'rgba(255,255,255,0)');
                bgCtx.fillStyle = glow; bgCtx.beginPath(); bgCtx.arc(x, y, radius * 2.5, 0, Math.PI * 2); bgCtx.fill();
            }
            for (let i = 0; i < 2; i++) {
                const x = Math.random() * width; const y = Math.random() * height;
                const radius = Math.random() * 120 + 40;
                const hue = Math.floor(Math.random() * 360); const color = `hsla(${hue}, 60%, 40%, 0.04)`;
                const cloudGrad = bgCtx.createRadialGradient(x, y, radius * 0.15, x, y, radius);
                cloudGrad.addColorStop(0, color); cloudGrad.addColorStop(1, 'rgba(0,0,0,0)');
                bgCtx.fillStyle = cloudGrad; bgCtx.save(); bgCtx.translate(x, y); bgCtx.rotate(Math.random() * Math.PI);
                bgCtx.scale(1, 0.5 + Math.random() * 0.7); bgCtx.beginPath(); bgCtx.arc(0, 0, radius, 0, Math.PI * 2); bgCtx.restore(); bgCtx.fill();
            }
            return bgCanvas;
        }
        function drawMapBoundaries(ctx, boundaries, width, height) {
            ctx.save();
            const padding = boundaries.padding || 0;
            ctx.fillStyle = 'rgba(0, 128, 255, 0.05)';
            ctx.fillRect(0, 0, width, 1); ctx.fillRect(0, height - 1, width, 1); ctx.fillRect(0, 0, 1, height); ctx.fillRect(width - 1, 0, 1, height);
            ctx.strokeStyle = 'rgba(0, 128, 255, 0.4)'; ctx.lineWidth = 1.5; ctx.setLineDash([8, 4]);
            ctx.strokeRect(padding, padding, width - padding * 2, height - padding * 2);
            ctx.restore();
        }
        function drawPlanets(ctx, planetsToDraw, width, height, selectedPlanet) {
            const sortedPlanets = [...planetsToDraw].sort((a, b) => (a.size * a.mass) - (b.size * b.mass));
            let selPlanet = null;
            sortedPlanets.forEach(planet => {
                if (selectedPlanet && planet === selectedPlanet) selPlanet = planet;
                else if(!planet.out) planet.draw(ctx);
            });
            if (selPlanet && !selPlanet.out) {
                ctx.save(); ctx.shadowColor = '#FFEB3B'; ctx.shadowBlur = 28;
                selPlanet.draw(ctx);
                ctx.restore();
            }
        }
        
        function updatePowerBar(powerBarFill, powerBarText, powerAmount) {
            if (!powerBarFill || !powerBarText) return;
            const percentage = powerAmount * 100;
            powerBarFill.style.width = `${percentage}%`;
            powerBarText.textContent = `파워: ${Math.round(percentage)}%`;
            let color;
            if (percentage < 33) color = '#4CAF50'; else if (percentage < 66) color = '#FFC107'; else color = '#F44336';
            powerBarFill.style.backgroundColor = color;
        }
        function showEndGameModal(winner, message) {
            const modal = document.getElementById('endGameModal');
            const winnerMessage = document.getElementById('winnerMessage');
            const congratsMessage = document.getElementById('congratsMessage');
            if (modal && winnerMessage && congratsMessage) {
                winnerMessage.textContent = winner; congratsMessage.textContent = message; modal.style.display = 'flex';
            }
        }
        function hideEndGameModal() { const modal = document.getElementById('endGameModal'); if (modal) modal.style.display = 'none'; }

        // New function to draw the culling circle
        function drawCullingCircle(ctx, mapWidth, mapHeight) {
            if (!currentGameState || currentGameState.gameMode.name !== GAME_MODES.CULLING) return;
            
            const cullingCircle = currentGameState.map?.cullingCircle;
            if (!cullingCircle) return;
            
            ctx.save();
            
            const centerX = cullingCircle.centerX;
            const centerY = cullingCircle.centerY;
            const radius = cullingCircle.radius;
            
            // 컬링 하우스 (중앙 타겟) 그리기
            ctx.beginPath();
            ctx.fillStyle = 'rgba(255, 215, 0, 0.15)'; // 황금색 배경
            ctx.arc(centerX, centerY, radius * 0.1, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.9)';
            ctx.lineWidth = 4;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.1, 0, Math.PI * 2);
            ctx.stroke();
            
            // 점수 원들 그리기 (동심원)
            const scoreRings = [
                { ratio: 0.3, color: 'rgba(255, 100, 100, 0.6)', points: '10점' },
                { ratio: 0.5, color: 'rgba(255, 165, 0, 0.6)', points: '7점' },
                { ratio: 0.7, color: 'rgba(255, 255, 100, 0.6)', points: '5점' },
                { ratio: 0.9, color: 'rgba(100, 255, 100, 0.6)', points: '3점' },
                { ratio: 1.0, color: 'rgba(100, 200, 255, 0.6)', points: '1점' }
            ];
            
            scoreRings.forEach((ring, index) => {
                const ringRadius = radius * ring.ratio;
                
                // 점수 원 테두리
                ctx.beginPath();
                ctx.strokeStyle = ring.color;
                ctx.lineWidth = 3;
                ctx.setLineDash(index === scoreRings.length - 1 ? [10, 5] : []);
                ctx.arc(centerX, centerY, ringRadius, 0, Math.PI * 2);
                ctx.stroke();
                
                // 점수 표시 텍스트
                if (ringRadius > 30) { // 충분히 큰 원에만 텍스트 표시
                    ctx.fillStyle = ring.color.replace('0.6', '0.9');
                    ctx.font = 'bold 14px "Noto Sans KR", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // 텍스트를 원 위쪽에 배치
                    const textY = centerY - ringRadius + 15;
                    if (textY > 10) { // 화면 밖으로 나가지 않도록
                        ctx.fillText(ring.points, centerX, textY);
                    }
                }
            });
            
            // 중앙 불즈 아이 표시
            ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
            ctx.font = 'bold 16px "Orbitron", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('🎯', centerX, centerY);
            
            // 컬링 하우스 라벨
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.font = 'bold 18px "Noto Sans KR", sans-serif';
            ctx.fillText('컬링 하우스', centerX, centerY + radius + 30);
            
            // 디버그 정보 표시 (디버그 모드일 때)
            if (debugMode) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = '12px monospace';
                ctx.textAlign = 'left';
                ctx.fillText(`중심: (${centerX}, ${centerY})`, 10, mapHeight - 60);
                ctx.fillText(`반지름: ${radius}`, 10, mapHeight - 45);
                ctx.fillText(`맵 크기: ${mapWidth}x${mapHeight}`, 10, mapHeight - 30);
                
                // 행성들과 중심점까지의 거리 표시
                if (currentGameState.planets) {
                    const planetsInRange = currentGameState.planets.filter(p => 
                        (p.owner === 'P1' || p.owner === 'P2') && !p.out &&
                        Math.hypot(p.x - centerX, p.y - centerY) <= radius
                    );
                    
                    planetsInRange.forEach(planet => {
                        const distance = Math.hypot(planet.x - centerX, planet.y - centerY);
                        ctx.fillStyle = planet.owner === 'P1' ? 'rgba(100, 200, 255, 0.8)' : 'rgba(255, 100, 100, 0.8)';
                        ctx.fillText(`${distance.toFixed(1)}`, planet.x + planet.size + 5, planet.y - 5);
                        
                        // 중심점까지 선 그리기
                        ctx.beginPath();
                        ctx.strokeStyle = planet.owner === 'P1' ? 'rgba(100, 200, 255, 0.4)' : 'rgba(255, 100, 100, 0.4)';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([3, 3]);
                        ctx.moveTo(planet.x, planet.y);
                        ctx.lineTo(centerX, centerY);
                        ctx.stroke();
                    });
                }
            }
            
            ctx.restore();
        }

        // --- game-initialization.js content (Simplified) ---
        // planets_data_template is already defined above with enhanced educational content
        // Reusing the same data structure for game initialization
        
        let uiStartScreen, uiMapThumbContainer, uiModeSelect, uiModeDescription, uiStartGameBtn;
        let uiDraftInfoPanel, uiDraftPlanetName, uiDraftPlanetDesc, uiDraftStatSize, uiDraftStatDensity, uiDraftStatGravity;
        let uiDraftStatSizeValue, uiDraftStatDensityValue, uiDraftStatGravityValue;
        let selectedMapData = getMapById("basic");
        let selectedGameModeType = GAME_MODES.ALGGAGI;

        function initializeStartScreenUI(onGameStartCallback) {
            uiStartScreen = document.getElementById('startScreen');
            uiStartGameBtn = document.getElementById('startGameBtn');
            uiDraftInfoPanel = document.getElementById('draftInfoPanel');
            uiDraftPlanetName = document.getElementById('draftPlanetName');
            uiDraftPlanetDesc = document.getElementById('draftPlanetDesc');
            uiDraftStatSize = document.getElementById('draftStatSize');
            uiDraftStatDensity = document.getElementById('draftStatDensity');
            uiDraftStatGravity = document.getElementById('draftStatGravity');
            uiInstructions = document.getElementById('instructions'); // Correctly assigned
            uiModeDescription = document.getElementById('modeDescription');
            uiModeSelect = document.getElementById('modeSelect'); // Get reference to modeSelect
            
            // Set up mode description based on selected mode
            if(uiModeSelect && uiModeDescription) {
                uiModeSelect.addEventListener('change', () => {
                    selectedGameModeType = uiModeSelect.value; // Update selected game mode
                    if (uiModeSelect.value === 'alggagi') {
                        uiModeDescription.innerHTML = `
                            <div style="display: flex; align-items: center; margin-bottom: 8px;">
                                <i class="fas fa-target" style="color: var(--primary-color); margin-right: 8px;"></i>
                                <strong style="color: var(--primary-color);">🎯 알까기 모드</strong>
                            </div>
                            <p style="margin: 0; color: var(--text-secondary); line-height: 1.4;">
                                상대방의 모든 행성을 맵 밖으로 밀어내면 승리! 전략적으로 행성을 발사하여 상대를 제거하세요.
                            </p>
                        `;
                    } else if (uiModeSelect.value === 'culling') {
                        uiModeDescription.innerHTML = `
                            <div style="display: flex; align-items: center; margin-bottom: 8px;">
                                <i class="fas fa-bullseye" style="color: var(--accent-color); margin-right: 8px;"></i>
                                <strong style="color: var(--accent-color);">🥌 컬링 모드</strong>
                            </div>
                            <div style="color: var(--text-secondary); line-height: 1.4;">
                                <p style="margin: 0 0 8px 0;">
                                    중앙의 <span style="color: var(--accent-color); font-weight: bold;">컬링 하우스</span>에 행성을 최대한 가깝게 보내세요!
                                </p>
                                <div style="background: rgba(255, 215, 0, 0.1); padding: 8px; border-radius: 6px; border-left: 3px solid var(--accent-color); font-size: 0.9em;">
                                    <div style="margin-bottom: 4px;">🎯 <strong>점수 체계:</strong> 중심에서 가까운 순서대로 10→7→5→3→1점</div>
                                    <div style="margin-bottom: 4px;">🏆 <strong>컬링 룰:</strong> 가장 가까운 행성의 소유자만 점수 획득</div>
                                    <div>📊 <strong>승부:</strong> 3라운드 후 총점으로 승부 결정</div>
                                </div>
                            </div>
                        `;
                    }
                });
                // Set initial description based on default selected value
                uiModeSelect.dispatchEvent(new Event('change')); // Trigger change to set initial description
            } else if (uiModeDescription) { // Fallback if modeSelect is not found but description is
                uiModeDescription.innerHTML = `
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <i class="fas fa-target" style="color: var(--primary-color); margin-right: 8px;"></i>
                        <strong style="color: var(--primary-color);">🎯 알까기 모드</strong>
                    </div>
                    <p style="margin: 0; color: var(--text-secondary); line-height: 1.4;">
                        상대방의 모든 행성을 맵 밖으로 밀어내면 승리! 전략적으로 행성을 발사하여 상대를 제거하세요.
                    </p>
                `;
            }

            const learnPlanetsBtn = document.getElementById('learnPlanetsBtn'); // Fixed ID here
            const planetInfoModal = document.getElementById('planetInfoModal');
            const closePlanetInfoBtn = document.getElementById('도움말 닫기'); // Fixed ID here
            const planetInfoGrid = document.getElementById('planetInfoGrid');

            if (learnPlanetsBtn && planetInfoModal && closePlanetInfoBtn && planetInfoGrid) {
                learnPlanetsBtn.addEventListener('click', () => {
                    planetInfoGrid.innerHTML = '';
                    planets_data_template.forEach(p => {
                        const item = document.createElement('div');
                        item.className = 'planet-info-item';
                        item.innerHTML = `
                            <h4>${p.name} (${p.type === 'star' ? '항성' : '행성'})</h4>
                            <p>크기 (반지름): ${p.size}</p>
                            <p>질량 (지구=1): ${p.mass}</p>
                            <p>밀도 (g/cm³): ${p.density !== undefined ? p.density.toFixed(2) : 'N/A'}</p>
                            <p>표면 중력 (지구=1): ${p.surfaceGravity !== undefined ? p.surfaceGravity.toFixed(2) : 'N/A'}</p>
                            <p>자전축 기울기: ${p.axialTiltDeg !== undefined ? p.axialTiltDeg.toFixed(2) + '°' : 'N/A'}</p>
                            <p>공전 주기 (지구일): ${p.orbitalPeriod !== undefined ? p.orbitalPeriod : 'N/A'}</p>
                            <p>특징: ${p.desc}</p>
                            <p style="color: var(--accent-color); font-weight: bold;">💡 게임 팁: ${p.gameStrategy}</p>
                        `;
                        planetInfoGrid.appendChild(item);
                    });
                    planetInfoModal.style.display = 'flex';
                });
                closePlanetInfoBtn.addEventListener('click', () => {
                    planetInfoModal.style.display = 'none';
                });
            }

            // Quiz button event listener
            const quizBtn = document.getElementById('quizBtn');
            const quizModal = document.getElementById('quizModal');
            if (quizBtn && quizModal) {
                quizBtn.addEventListener('click', () => {
                    quizModal.style.display = 'flex';
                });
            }

            // Debug mode button event listener
            const debugModeBtn = document.getElementById('debugModeBtn');
            if (debugModeBtn) {
                debugModeBtn.addEventListener('click', () => {
                    toggleDebugMode();
                });
            }

            // Tutorial button (existing)
            const tutorialBtn = document.getElementById('tutorialBtn');
            const tutorialModal = document.getElementById('tutorialModal');
            if (tutorialBtn && tutorialModal) {
                tutorialBtn.addEventListener('click', () => {
                    tutorialModal.style.display = 'flex';
                });
            }

            uiStartGameBtn.addEventListener('click', () => {
                if (onGameStartCallback) onGameStartCallback(selectedMapData, selectedGameModeType); // Pass selected game mode
                uiStartScreen.style.display = 'none';
            });
            uiStartScreen.style.display = 'block';
        }

        function showPlanetInfoForDraft(planetData, mouseX, mouseY) {
            if (!uiDraftInfoPanel || !planetData) return;
            uiDraftPlanetName.textContent = planetData.name;
            uiDraftPlanetDesc.innerHTML = `
                <p>${planetData.desc}</p>
                <div style="margin-top: 10px; padding: 8px; background: rgba(255, 215, 0, 0.1); border-radius: 6px; border-left: 3px solid var(--accent-color);">
                    <strong>🎯 게임 전략:</strong> ${planetData.gameStrategy || '균형잡힌 능력을 가진 행성입니다.'}
                </div>
                <div style="margin-top: 8px; padding: 8px; background: rgba(0, 212, 255, 0.1); border-radius: 6px; border-left: 3px solid var(--primary-color);">
                    <strong>🔬 재미있는 사실:</strong> ${planetData.funFact || '흥미로운 특징을 가진 행성입니다.'}
                </div>
            `;
            
            const maxDisplaySize = 60;
            const sizePercentage = (planetData.size / maxDisplaySize) * 100;
            if(uiDraftStatSize) uiDraftStatSize.style.width = `${Math.min(100, sizePercentage)}%`;
            if(uiDraftStatSizeValue) uiDraftStatSizeValue.textContent = planetData.size;
            
            const maxDisplayDensity = 6;
            const densityPercentage = (planetData.density / maxDisplayDensity) * 100;
            if(uiDraftStatDensity) uiDraftStatDensity.style.width = `${Math.min(100, densityPercentage)}%`;
            if(uiDraftStatDensityValue) uiDraftStatDensityValue.textContent = planetData.density !== undefined ? planetData.density.toFixed(2) : 'N/A';

            const maxDisplayGravity = 3;
            const gravityPercentage = (planetData.surfaceGravity / maxDisplayGravity) * 100;
            if(uiDraftStatGravity) uiDraftStatGravity.style.width = `${Math.min(100, gravityPercentage)}%`;
            if(uiDraftStatGravityValue) uiDraftStatGravityValue.textContent = planetData.surfaceGravity !== undefined ? planetData.surfaceGravity.toFixed(2) : 'N/A';
            
            uiDraftInfoPanel.style.display = 'block';
            
            // Track that player learned about this planet
            learningProgress.planetsLearned.add(planetData.id);
        }
        function initializeDraftModeSetup(draftCallback) {
            const planetsList = planets_data_template.map(p => ({ ...p, isSelected: false }));
            const draftOrder = ["P1", "P2", "P2", "P1", "P1", "P2"]; let currentIndex = 0;
            const localPickedPlanets = { P1: [], P2: [] };
            const selectPlanetForDraft = (planetId) => {
                if (currentIndex >= draftOrder.length) return;
                const currentPlayer = draftOrder[currentIndex];
                const planetIndex = planetsList.findIndex(p => p.id === planetId);
                if (planetIndex === -1) return;
                const planet = planetsList[planetIndex];
                if (planet.isSelected) return;
                planet.isSelected = true; localPickedPlanets[currentPlayer].push(planet);
                currentIndex++;
                updatePlayerPicksUI(localPickedPlanets);
                if (currentIndex >= draftOrder.length) {
                    const allSelectedIds = [...localPickedPlanets.P1, ...localPickedPlanets.P2].map(p => p.id);
                    const unselectedPlanetsData = planetsList.filter(p => !allSelectedIds.includes(p.id)).slice(0, 3);

                    setTimeout(() => {
                        if(uiDraftInfoPanel) uiDraftInfoPanel.style.display = 'none';
                        // Fix: Pass unselectedPlanetsData instead of unselectedNpcData
                        if (draftCallback) draftCallback(localPickedPlanets, unselectedPlanetsData);
                    }, 500); return;
                }
                showNextPlayerPromptUI(draftOrder[currentIndex]);
            };
            return {
                getAllPlanets: () => planetsList,
                getAvailablePlanets: () => planetsList.filter(p => !p.isSelected),
                getCurrentPlayer: () => currentIndex < draftOrder.length ? draftOrder[currentIndex] : null,
                selectPlanet: selectPlanetForDraft
            };
        }
        function showNextPlayerPromptUI(player) {
            const gameMessagesUI = document.getElementById('gameMessages');
            if (gameMessagesUI) {
                gameMessagesUI.textContent = `${player === 'P1' ? '1' : '2'}번 플레이어가 행성을 선택해주세요.`;
                gameMessagesUI.style.display = 'block';
            }
        }
        function updatePlayerPicksUI(currentPicks) {
            const p1PicksUI = document.getElementById('p1Picks'); const p2PicksUI = document.getElementById('p2Picks');
            if (p1PicksUI) {
                p1PicksUI.innerHTML = 'P1 선택: ';
                currentPicks.P1.forEach(planet => p1PicksUI.appendChild(createPlanetIconForUI(planet)));
                if (currentPicks.P1.length > 0) p1PicksUI.style.display = 'flex'; else p1PicksUI.style.display = 'none';
            }
            if (p2PicksUI) {
                p2PicksUI.innerHTML = 'P2 선택: ';
                currentPicks.P2.forEach(planet => p2PicksUI.appendChild(createPlanetIconForUI(planet)));
                if (currentPicks.P2.length > 0) p2PicksUI.style.display = 'flex'; else p2PicksUI.style.display = 'none';
            }
        }
        function createPlanetIconForUI(planet) {
            const icon = document.createElement('img'); icon.title = planet.name;
            const tempCanvas = document.createElement('canvas'); tempCanvas.width = 25; tempCanvas.height = 25;
            const ctxIcon = tempCanvas.getContext('2d');
            ctxIcon.clearRect(0, 0, 25, 25);
            ctxIcon.beginPath(); ctxIcon.arc(12.5, 12.5, 12, 0, Math.PI * 2); ctxIcon.fillStyle = planet.color; ctxIcon.fill();
            if (planet.type === "gas_giant_rings") {
                ctxIcon.save(); ctxIcon.scale(1, 0.4); ctxIcon.beginPath();
                ctxIcon.arc(12.5, 12.5 / 0.4, 16, 0, Math.PI * 2); ctxIcon.arc(12.5, 12.5 / 0.4, 10, 0, Math.PI * 2, true);
                ctxIcon.fillStyle = 'rgba(210,180,140,0.6)'; ctxIcon.fill(); ctxIcon.restore();
            } else if (planet.type === "star") {
                const gradient = ctxIcon.createRadialGradient(12.5, 12.5, 10, 12.5, 12.5, 16);
                gradient.addColorStop(0, 'rgba(255,215,0,0.8)'); gradient.addColorStop(1, 'rgba(255,165,0,0)');
                ctxIcon.beginPath(); ctxIcon.arc(12.5, 12.5, 16, 0, Math.PI * 2); ctxIcon.fillStyle = gradient; ctxIcon.fill();
            }
            icon.src = tempCanvas.toDataURL(); return icon;
        }
        
        function initializeGameState(mapData, gameModeType, draftedPlanetsData, unselectedNpcData) {
            const uiElements = {
                turnIndicator: document.getElementById('turnIndicator'), aliveCount: document.getElementById('aliveCount'),
                gameMessages: document.getElementById('gameMessages'), powerBarContainer: document.getElementById('powerBarContainer'),
                powerBarFill: document.getElementById('powerBarFill'), powerBarText: document.getElementById('powerBarText'),
                p1PicksUI: document.getElementById('p1Picks'), p2PicksUI: document.getElementById('p2Picks'),
                instructionsUI: uiInstructions // Use the correctly scoped variable
            };
            const gameModeObj = createGameMode(gameModeType);
            const gamePlanets = [];
            
            const placePlanet = (planetData, owner, spawnPoint, isNpc = false) => {
                let x, y;
                const maxPlacementAttempts = isNpc ? 200 : 50;
                let attempts = 0;
                let placedSuccessfully = false;
                const ownSize = planetData.size;

                while (!placedSuccessfully && attempts < maxPlacementAttempts) {
                    attempts++;
                    const margin = ownSize + 10;

                    if (isNpc) {
                        if (planetData.type === 'star' && owner === 'NPC') {
                            x = mapData.width / 2;
                            y = mapData.height / 2;
                        } else {
                            x = margin + Math.random() * (mapData.width - margin * 2);
                            y = margin + Math.random() * (mapData.height - margin * 2);
                        }
                    } else {
                        x = spawnPoint.x * mapData.width;
                        y = spawnPoint.y * mapData.height;
                    }

                    x = Math.max(margin, Math.min(x, mapData.width - margin));
                    y = Math.max(margin, Math.min(y, mapData.height - margin));
                    
                    let overlaps = false;
                    for (const existingPlanet of gamePlanets) {
                        const distBetween = Math.hypot(x - existingPlanet.x, y - existingPlanet.y);
                        const minSafeDist = ownSize + existingPlanet.size + 20;
                        if (distBetween < minSafeDist) {
                            overlaps = true;
                            break;
                        }
                    }

                    if (!overlaps) {
                        placedSuccessfully = true;
                    } else if (!isNpc) {
                        console.warn(`Player planet ${planetData.name} (${owner}) might overlap at spawn. Placing it anyway.`);
                        placedSuccessfully = true;
                    }
                }
                return new Planet(x, y, planetData, owner);
            };
            
            const sunData = planets_data_template.find(p => p.id === 'sun');
            // Fixed typo: draftedPlanitedData -> draftedPlanetsData
            const isSunPickedByPlayer = (draftedPlanetsData.P1.some(p => p.id === 'sun') || draftedPlanetsData.P2.some(p => p.id === 'sun'));
            if (sunData && !isSunPickedByPlayer) {
                gamePlanets.push(placePlanet(sunData, "NPC", null, true));
            }


            if (draftedPlanetsData.P1) {
                mapData.spawnPoints.p1.forEach((sp, idx) => {
                    if (idx < draftedPlanetsData.P1.length) gamePlanets.push(placePlanet(draftedPlanetsData.P1[idx], 'P1', sp));
                });
            }
            if (draftedPlanetsData.P2) {
                mapData.spawnPoints.p2.forEach((sp, idx) => {
                    if (idx < draftedPlanetsData.P2.length) gamePlanets.push(placePlanet(draftedPlanetsData.P2[idx], 'P2', sp));
                });
            }
            
            npcPlanets = [];
            if (unselectedNpcData) {
                unselectedNpcData.forEach(npcData => {
                    if (npcData.id !== 'sun') {
                        const npcPlanet = placePlanet(npcData, "NPC", null, true);
                        npcPlanets.push(npcPlanet);
                    }
                });
                gamePlanets.push(...npcPlanets);
            }
            
            gameModeObj.initialize(gamePlanets.filter(p => p.owner === 'P1' || p.owner === 'P2'), uiElements);
            
            const uiConfig = gameModeObj.showUI();
            if (uiConfig.turnIndicator && uiElements.turnIndicator) { uiElements.turnIndicator.textContent = 'P1의 턴'; uiElements.turnIndicator.style.display = 'block'; }
            if (uiConfig.instructionsUI && uiElements.instructionsUI) uiElements.instructionsUI.style.display = 'block';
            
            const cullingCircleData = { // Define culling circle data
                centerX: mapData.width / 2,
                centerY: mapData.height / 2,
                radius: Math.min(mapData.width, mapData.height) * 0.3 // 30% of smaller dimension for better gameplay
            };

            return {
                planets: gamePlanets,
                gameMode: gameModeObj,
                ui: uiElements,
                map: {
                    width: mapData.width,
                    height: mapData.height,
                    boundaries: mapData.boundaries,
                    cullingCircle: cullingCircleData // Add cullingCircle to map data
                },
                currentTurn: 'P1',
                p1Score: 0, // New: P1 score for culling mode
                p2Score: 0, // New: P2 score for culling mode
                currentRound: 1, // New: Current round for culling mode
                maxRounds: 3, // New: Total rounds for culling mode
                p1ShotsTaken: 0, // Shots taken by P1 in current round
                p2ShotsTaken: 0, // Shots taken by P2 in current round
                maxShotsPerPlayerPerRound: 3, // Max shots per player per round
                shotActive: false, // Indicates if a shot is currently active (for culling mode)
                shotPlanet: null,   // Reference to the planet that was shot
                physicsSettledForRoundEnd: false // New: Flag to wait for physics to settle before ending round
            };
        }

        // --- game-main.js content (initGame, update, event handlers etc.) ---
        function renderDraftSelectionScreen(mapData, onCompleteCallback) {
            draftState = initializeDraftModeSetup((picked, unselected) => {
                pickedPlanets.P1 = [...picked.P1];
                pickedPlanets.P2 = [...picked.P2];
                if (onCompleteCallback) onCompleteCallback(picked, unselected);
            });
            let cursorPlanetId = draftState.getAllPlanets()[0]?.id || null;
            const columns = 3; const planetRenderSize = 50;
            const gridSpacingX = planetRenderSize * 2.2; const gridSpacingY = planetRenderSize * 2.5;
            
            const draftDisplayWidth = Math.min(mapData.width, 800);

            // Calculate startX to center the grid of planets
            // The total width of the planet display area is (columns - 1) * gridSpacingX + 2 * planetRenderSize
            // We want to center this within draftDisplayWidth
            const totalGridContentWidth = (columns - 1) * gridSpacingX + (planetRenderSize * 2);
            const startX = (draftDisplayWidth - totalGridContentWidth) / 2 + planetRenderSize; // Add planetRenderSize to get center of first planet
            const startY = 180;

            // These event handlers are now attached to `window` for global drag,
            // but they need to correctly handle the `gameRunningState` to only act
            // when in 'draft' mode for planet selection.
            // The `getMousePos` function also needs to be robust for `currentGameState` being null.

            draftHandleClick = function(e) {
                if (gameRunningState !== "draft" || !draftState || draftState.getCurrentPlayer() === null) return; // Ensure in draft mode
                const mousePos = getMousePos(e); // getMousePos is now robust for null currentGameState
                const allPlanets = draftState.getAllPlanets();

                const scale = Math.min(canvas.width / draftDisplayWidth, canvas.height / mapData.height);
                const offsetX = (canvas.width - draftDisplayWidth * scale) / 2;
                const offsetY = (canvas.height - mapData.height * scale) / 2;

                for (let i = 0; i < allPlanets.length; i++) {
                    const planet = allPlanets[i]; const column = i % columns; const row = Math.floor(i / columns);
                    // Use the calculated startX for positioning
                    const drawX = offsetX + (startX + column * gridSpacingX) * scale;
                    const drawY = offsetY + (startY + row * gridSpacingY) * scale;
                    const scaledRenderSize = planetRenderSize * 0.8 * scale;

                    if (Math.hypot(mousePos.x - drawX , // Corrected: removed double scaling
                                   mousePos.y - drawY) < scaledRenderSize && !planet.isSelected) { // Corrected: removed double scaling
                        cursorPlanetId = planet.id; draftState.selectPlanet(planet.id); break;
                    }
                }
            };
            draftHandleMouseMove = function(e) {
                if (gameRunningState !== "draft" || !draftState || draftState.getCurrentPlayer() === null) return; // Ensure in draft mode
                const mousePos = getMousePos(e); // getMousePos is now robust for null currentGameState
                const allPlanets = draftState.getAllPlanets();
                let foundPlanet = false;

                const scale = Math.min(canvas.width / draftDisplayWidth, canvas.height / mapData.height);
                const offsetX = (canvas.width - draftDisplayWidth * scale) / 2;
                const offsetY = (canvas.height - mapData.height * scale) / 2;

                for (let i = 0; i < allPlanets.length; i++) {
                    const planet = allPlanets[i]; const column = i % columns; const row = Math.floor(i / columns);
                    // Use the calculated startX for positioning
                    const drawX = offsetX + (startX + column * gridSpacingX) * scale;
                    const drawY = offsetY + (startY + row * gridSpacingY) * scale;
                    const scaledRenderSize = planetRenderSize * 0.8 * scale;

                    if (Math.hypot(mousePos.x - drawX, // Corrected: removed double scaling
                                   mousePos.y - drawY) < scaledRenderSize) { // Corrected: removed double scaling
                        canvas.style.cursor = planet.isSelected ? 'not-allowed' : 'pointer';
                        if (!planet.isSelected) { showPlanetInfoForDraft(planet, e.clientX, e.clientY); cursorPlanetId = planet.id; foundPlanet = true; }
                        break;
                    }
                }
                if (!foundPlanet) { canvas.style.cursor = 'default'; if(uiDraftInfoPanel) uiDraftInfoPanel.style.display = 'none'; }
            };
            draftHandleKeyDown = function(e) {
                if (gameRunningState !== "draft" || !draftState || draftState.getCurrentPlayer() === null) return; // Ensure in draft mode
                const allPlanets = draftState.getAllPlanets();
                const currentIndex = allPlanets.findIndex(p => p.id === cursorPlanetId); if (currentIndex === -1) return;
                let nextIndex = currentIndex; let row = Math.floor(currentIndex / columns); let col = currentIndex % columns;
                const numRows = Math.ceil(allPlanets.length / columns);
                switch (e.key) {
                    case 'ArrowLeft': col = (col - 1 + columns) % columns; break;
                    case 'ArrowRight': col = (col + 1) % columns; break;
                    case 'ArrowUp': row = (row - 1 + numRows) % numRows; break;
                    case 'ArrowDown': row = (row + 1) % numRows; break;
                    case ' ': case 'Enter': e.preventDefault(); const planet = allPlanets.find(p => p.id === cursorPlanetId); if (planet && !planet.isSelected) draftState.selectPlanet(planet.id); return;
                    default: return;
                }
                nextIndex = row * columns + col;
                if (nextIndex >= allPlanets.length) {
                    if (e.key === 'ArrowRight' || e.key === 'ArrowDown') nextIndex = Math.min(allPlanets.length - 1, row * columns + (allPlanets.length % columns) -1) ;
                    else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') nextIndex = Math.min(allPlanets.length - 1, row * columns);
                }
                if (nextIndex < 0) nextIndex = 0;


                cursorPlanetId = allPlanets[nextIndex].id;
                const cursorPlanet = allPlanets.find(p => p.id === cursorPlanetId);
                if (cursorPlanet && !cursorPlanet.isSelected) {
                    showPlanetInfoForDraft(cursorPlanet, window.innerWidth / 2, window.innerHeight - 150);
                }
            };
            // Attach draft-specific event listeners to window
            window.addEventListener('mousedown', draftHandleClick); // Use draftHandleClick for mousedown
            window.addEventListener('mousemove', draftHandleMouseMove);
            window.addEventListener('mouseup', draftHandleClick); // Use draftHandleClick for mouseup (to select on release)
            window.addEventListener('touchstart', (e) => { e.preventDefault(); if (e.touches.length > 0) draftHandleClick(e.touches[0]); }, { passive: false });
            window.addEventListener('touchmove', (e) => { e.preventDefault(); if (e.touches.length > 0) draftHandleMouseMove(e.touches[0]); }, { passive: false });
            window.addEventListener('touchend', (e) => { e.preventDefault(); if (e.changedTouches.length > 0) draftHandleClick(e.changedTouches[0]); }, { passive: false });
            window.addEventListener('keydown', draftHandleKeyDown);
            
            function renderDraftLoop() {
                if (gameRunningState !== "draft") return; // Only run if in draft mode
                if (!spaceBackground || spaceBackground.width === 0 || spaceBackground.height === 0) {
                    requestAnimationFrame(renderDraftLoop); return;
                }
                ctx.drawImage(spaceBackground, 0, 0);
                
                ctx.save();
                const draftWorldWidth = draftDisplayWidth;
                const draftWorldHeight = mapData.height;
                const scale = Math.min(canvas.width / draftWorldWidth, canvas.height / draftWorldHeight);
                const offsetX = (canvas.width - draftWorldWidth * scale) / 2;
                const offsetY = (canvas.height - mapData.height * scale) / 2;
                ctx.translate(offsetX, offsetY);
                ctx.scale(scale, scale);

                ctx.fillStyle = '#FFFFFF'; ctx.font = '32px "Noto Sans KR", sans-serif'; ctx.textAlign = 'center';
                ctx.fillText('행성 선택', draftWorldWidth / 2, 80 );
                const currentPlayer = draftState.getCurrentPlayer();
                ctx.fillStyle = currentPlayer === 'P1' ? '#FF6464' : '#6464FF'; ctx.font = '24px "Noto Sans KR", sans-serif';
                ctx.fillText(`${currentPlayer === 'P1' ? '1' : '2'}번 플레이어 차례`, draftWorldWidth / 2, 120);

                const allPlanets = draftState.getAllPlanets();
                // Use the calculated startX for positioning
                const draftLoopStartX = startX;
                const draftLoopStartY = 180;


                for (let i = 0; i < allPlanets.length; i++) {
                    const planet = allPlanets[i]; const column = i % columns; const row = Math.floor(i / columns);
                    // x is the center of the planet
                    const x = draftLoopStartX + column * gridSpacingX;
                    const y = draftLoopStartY + row * gridSpacingY;
                    
                    ctx.save();
                    if (planet.id === cursorPlanetId) {
                        ctx.shadowColor = planet.isSelected ? '#888888' : '#FFD700'; ctx.shadowBlur = 24;
                        ctx.lineWidth = 4; ctx.strokeStyle = planet.isSelected ? '#888888' : '#FFD700';
                        ctx.beginPath(); ctx.arc(x, y, planetRenderSize * 0.75, 0, Math.PI * 2); ctx.stroke();
                    }
                    if (planet.isSelected) ctx.globalAlpha = 0.4;
                    
                    const tempPlanet = new Planet(x,y,planet);
                    tempPlanet.size = planetRenderSize * 0.7;
                    tempPlanet.textureCanvas = tempPlanet.buildTexture();
                    // Draw image centered on x,y
                    ctx.drawImage(tempPlanet.textureCanvas, x - tempPlanet.size, y - tempPlanet.size);

                    if (planet.isSelected) {
                        const playerWhoPicked = pickedPlanets.P1.some(p => p.id === planet.id) ? 'P1' : (pickedPlanets.P2.some(p => p.id === planet.id) ? 'P2' : null);
                        if(playerWhoPicked){
                            ctx.strokeStyle = playerWhoPicked === 'P1' ? '#FF6464' : '#6464FF';
                            ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(x, y, planetRenderSize * 0.65, 0, Math.PI * 2); ctx.stroke();
                        }
                        ctx.strokeStyle = '#FF4444'; ctx.lineWidth = 3; ctx.beginPath();
                        ctx.moveTo(x - planetRenderSize * 0.25, y - planetRenderSize * 0.25); ctx.lineTo(x + planetRenderSize * 0.25, y + planetRenderSize * 0.25);
                        ctx.moveTo(x + planetRenderSize * 0.25, y - planetRenderSize * 0.25); ctx.lineTo(x - planetRenderSize * 0.25, y + planetRenderSize * 0.25);
                        ctx.stroke();
                    }
                    ctx.fillStyle = planet.isSelected ? 'rgba(255,255,255,0.5)' : '#FFFFFF'; ctx.font = `15px "Noto Sans KR", sans-serif`;
                    ctx.textAlign = 'center'; ctx.fillText(planet.name, x, y + planetRenderSize + 15);
                    ctx.restore();
                }
                ctx.restore();
                requestAnimationFrame(renderDraftLoop);
            }
            renderDraftLoop();
        }

        function initializeMainGame(mapData, gameModeType, draftedPlanetsData, unselectedNpcData) {
            currentGameState = initializeGameState(mapData, gameModeType, draftedPlanetsData, unselectedNpcData);
            lastTime = performance.now(); isGameOver = false; gameRunningState = "play";
            // shotFiredThisTurn is no longer needed for turn progression, but can be kept for other logic if desired.
            // currentGameState.awaitingPhysicsSettling is also no longer used for turn progression.
            if (gameLoop) cancelAnimationFrame(gameLoop);
            gameLoop = requestAnimationFrame(updateGame);

            // Attach gameplay event listeners when entering play state
            window.addEventListener('mousedown', handleMouseDown);
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
            window.addEventListener('touchstart', (e) => { e.preventDefault(); if (e.touches.length > 0) handleMouseDown(e.touches[0]); }, { passive: false });
            window.addEventListener('touchmove', (e) => { e.preventDefault(); if (e.touches.length > 0) handleMouseMove(e.touches[0]); }, { passive: false });
            window.addEventListener('touchend', (e) => { e.preventDefault(); if (e.changedTouches.length > 0) handleMouseUp(e.changedTouches[0]); }, { passive: false });
            window.addEventListener('keydown', handleKeyDown);
        }

        function updateGame(currentTime) {
            if (gameRunningState !== "play" || !currentGameState) {
                if(isGameOver && gameRunningState === "end") { }
                else if (gameRunningState === "menu" || gameRunningState === "draft") { }
                else if (!currentGameState && gameRunningState === "play_init") { }
                else {
                    if (gameLoop) cancelAnimationFrame(gameLoop); gameLoop = null;
                }
                return;
            }
            
            const deltaTime = (currentTime - lastTime) / 1000; lastTime = currentTime;
            
            if (!spaceBackground || spaceBackground.width === 0 || spaceBackground.height === 0) {
                console.warn("Background not ready, skipping draw.");
                gameLoop = requestAnimationFrame(updateGame); return;
            }
            ctx.drawImage(spaceBackground, 0, 0);

            ctx.save();
            const gameWorldWidth = currentGameState.map.width;
            const gameWorldHeight = currentGameState.map.height;
            const scale = Math.min(canvas.width / gameWorldWidth, canvas.height / gameWorldHeight);
            const offsetX = (canvas.width - gameWorldWidth * scale) / 2;
            const offsetY = (canvas.height - gameWorldHeight * scale) / 2;
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            drawMapBoundaries(ctx, currentGameState.map.boundaries, gameWorldWidth, gameWorldHeight);
            
            // Draw culling circle if in culling mode
            if (currentGameState.gameMode.name === GAME_MODES.CULLING) {
                drawCullingCircle(ctx, gameWorldWidth, gameWorldHeight);
            }

            updatePhysics(deltaTime); // Physics update happens regardless of turn state
            renderGameObjects(currentTime);
            
            if (isDragging && selectedPlanet) {
                const mousePos = getMousePos(window.lastMouseEvent || {clientX: canvas.width/2 / scale - offsetX/scale, clientY: canvas.height/2 / scale - offsetY/scale});
                drawCueLine(ctx, selectedPlanet, mousePos.x, mousePos.y, powerAmount);
                // Removed trajectoryPoints drawing as per user request
                // if (trajectoryPoints.length > 0) {
                //     let trajectoryColor = powerAmount < 0.33 ? 'rgba(76, 175, 80, 0.6)' : powerAmount < 0.66 ? 'rgba(255, 193, 7, 0.6)' : 'rgba(244, 67, 54, 0.6)';
                //     drawTrajectory(ctx, trajectoryPoints, trajectoryColor);
                // }
            }
            ctx.restore();

            const result = currentGameState.gameMode.update(currentGameState.planets, currentGameState.map);
            if (result.winner && !isGameOver) {
                isGameOver = true; gameRunningState = "end"; endGame(result.winner, result.gameData); return; // Pass gameData for culling mode message
            }
            
            // Logic to deactivate shotActive for culling mode after the shot planet has settled
            // This logic is now specifically for the end of the round in culling mode.
            if (currentGameState.gameMode.name === GAME_MODES.CULLING && currentGameState.shotActive && currentGameState.shotPlanet) {
                const shotPlanet = currentGameState.shotPlanet;
                const allPlanetsEffectivelyStopped = currentGameState.planets.every(p => Math.hypot(p.vx, p.vy) < 0.05);

                if (allPlanetsEffectivelyStopped) {
                    currentGameState.shotActive = false;
                    currentGameState.shotPlanet = null;
                    currentGameState.physicsSettledForRoundEnd = true; // Mark physics as settled for round end

                    // If it's the 6th shot (P2's last shot), then end the round
                    if (currentGameState.p1ShotsTaken === currentGameState.maxShotsPerPlayerPerRound &&
                        currentGameState.p2ShotsTaken === currentGameState.maxShotsPerPlayerPerRound) {
                        endRound();
                        // If game ended, stop here.
                        if (isGameOver) return;
                    }
                    // If not the end of the round, just clear message if any specific culling message was shown
                    if (currentGameState.ui && currentGameState.ui.gameMessages && currentGameState.ui.gameMessages.textContent.includes("제거되었습니다")) {
                        setTimeout(() => {
                            if(currentGameState && currentGameState.ui && currentGameState.ui.gameMessages && currentGameState.ui.gameMessages.textContent.includes("제거되었습니다")) {
                                currentGameState.ui.gameMessages.style.display = 'none';
                            }
                        }, 500); // Short delay for culling message
                    }
                } else {
                    // If planets are still moving, show waiting message
                    if (currentGameState.ui && currentGameState.ui.gameMessages) {
                        currentGameState.ui.gameMessages.textContent = `행성들이 멈추기를 기다리는 중...`;
                        currentGameState.ui.gameMessages.style.display = 'block';
                    }
                }
            } else {
                // If not in culling mode's shot active state, ensure messages are hidden
                if (currentGameState.ui && currentGameState.ui.gameMessages && currentGameState.ui.gameMessages.textContent.includes("기다리는 중")) {
                    currentGameState.ui.gameMessages.style.display = 'none';
                }
            }


            if (dragJustStarted) {
                dragJustStarted = false;
            }
            
            // Update debug info if debug mode is active
            if (debugMode) {
                updateDebugInfo();
            }
            
            gameLoop = requestAnimationFrame(updateGame);
        }

        function updatePhysics(deltaTime) {
            const planets = currentGameState.planets;
            planets.forEach(planet => {
                // Only update physics for planets that are not out of bounds
                if (!planet.out) {
                    planet.update(deltaTime);
                }
            });

            planets.forEach(planet => {
                // Only check for out of bounds if the planet is not already out
                if (!planet.out && isOutOfBounds(planet, currentGameState.map.width, currentGameState.map.height, currentGameState.map.boundaries)) {
                    planet.out = true; // Mark as out of bounds
                    // Optionally, stop its velocity immediately if it goes out
                    planet.vx = 0;
                    planet.vy = 0;
                    // Clear its trails once it's out
                    planet.trails = [];

                    if (planet.owner && planet.owner !== "NPC" && planet.owner !== "SYSTEM" && currentGameState.ui && currentGameState.ui.gameMessages) {
                        currentGameState.ui.gameMessages.textContent = `${planet.owner}의 행성이 이탈!`;
                        currentGameState.ui.gameMessages.style.display = 'block';
                        setTimeout(() => { if(currentGameState && currentGameState.ui && currentGameState.ui.gameMessages) currentGameState.ui.gameMessages.style.display = 'none'; }, 2000);
                    }
                }
            });

            for (let i = 0; i < planets.length; i++) {
                const p1 = planets[i];
                // Skip physics calculations for planets that are out of bounds
                if (p1.out) continue;
                
                for (let j = i + 1; j < planets.length; j++) {
                    const p2 = planets[j];
                    // Skip physics calculations for planets that are out of bounds
                    if (p2.out) continue;
                    
                    applyGravity(p1, p2, deltaTime);
                    if (detectCollision(p1, p2)) {
                        const collisionResult = resolveCollision(p1, p2, deltaTime);

                        // --- Culling Mode Logic (Removed immediate culling on collision) ---
                        // The immediate culling on collision is removed as per new rules.
                        // Scoring is now done at the end of the round based on position.
                        // --- End Culling Mode Logic ---

                        const collisionParticles = createCollisionParticles(collisionResult.x, collisionResult.y, collisionResult.energy, p1.baseColor, p2.baseColor);
                        if (p1.particles.length < 100) p1.particles.push(...collisionParticles.slice(0, Math.floor(collisionParticles.length / 2)));
                        if (p2.particles.length < 100) p2.particles.push(...collisionParticles.slice(Math.floor(collisionParticles.length / 2)));
                    }
                }
            }
        }
        function renderGameObjects(currentTime) {
            drawPlanets(ctx, currentGameState.planets, currentGameState.map.width, currentGameState.map.height, selectedPlanet);
        }
        function shootPlanet(planet, directionX, directionY, power) {
            const MAX_FORCE = 25;
            const force = power * MAX_FORCE;
            planet.vx = directionX * force; planet.vy = directionY * force;
        }
        
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            // Use clientX/Y directly from the event, as they are relative to the viewport
            // This is crucial for drag outside canvas.
            const clientX = e.clientX;
            const clientY = e.clientY;

            // Convert client coordinates (relative to viewport) to canvas coordinates
            const canvasX = clientX - rect.left;
            const canvasY = clientY - rect.top;

            // If currentGameState is null (e.g., during menu or draft phase),
            // return coordinates scaled to the canvas's drawing buffer size.
            if (!currentGameState || !currentGameState.map) { // Added check for currentGameState.map
                // During draft phase, selectedMapData is available
                const mapWidth = selectedMapData.width;
                const mapHeight = selectedMapData.height;
                const scaleToFit = Math.min(canvas.width / mapWidth, canvas.height / mapHeight);
                const offsetX = (canvas.width - mapWidth * scaleToFit) / 2;
                const offsetY = (canvas.height - mapHeight * scaleToFit) / 2;

                const worldX = (canvasX - offsetX) / scaleToFit;
                const worldY = (canvasY - offsetY) / scaleToFit;
                
                return { x: worldX, y: worldY };
            }
            
            // If currentGameState exists, proceed with game world coordinate calculations.
            const gameWorldWidth = currentGameState.map.width;
            const gameWorldHeight = currentGameState.map.height;
            
            const currentCanvasWidth = canvas.width;
            const currentCanvasHeight = canvas.height;
            
            const scaleToFit = Math.min(currentCanvasWidth / gameWorldWidth, currentCanvasHeight / gameWorldHeight);
            const offsetX = (currentCanvasWidth - gameWorldWidth * scaleToFit) / 2;
            const offsetY = (currentCanvasHeight - gameWorldHeight * scaleToFit) / 2;

            // Convert canvas coordinates to game world coordinates
            const worldX = (canvasX - offsetX) / scaleToFit;
            const worldY = (canvasY - offsetY) / scaleToFit;
            
            return { x: worldX, y: worldY };
        }


        function drawCueLine(ctx, planet, endX, endY, power) { // Updated function signature
            if (!planet) return;
            const startX = planet.x; const startY = planet.y;
            const dirX = startX - endX;
            const dirY = startY - endY;
            const dist = Math.hypot(dirX, dirY);

            if (dist < 1) {
                // trajectoryPoints = []; // No longer needed as trajectory is removed
                return;
            }
            
            const normalizedX = dirX / dist; const normalizedY = dirY / dist;
            
            const lineLength = Math.min(dist, 50 + power * 100);
            const targetX = startX + normalizedX * lineLength;
            const targetY = startY + normalizedY * lineLength;

            ctx.save();
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(targetX, targetY);
            
            let lineColor;
            if (power < 0.33) lineColor = 'rgba(0, 255, 0, 0.7)';
            else if (power < 0.66) lineColor = 'rgba(255, 255, 0, 0.7)';
            else lineColor = 'rgba(255, 0, 0, 0.7)';
            
            ctx.strokeStyle = lineColor;
            ctx.lineWidth = 2.5;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(targetX, targetY, 3 + power * 3, 0, Math.PI * 2);
            ctx.fillStyle = lineColor;
            ctx.fill();
            
            ctx.restore();
            // Removed call to calculateTrajectory as per user request.
            // calculateTrajectory(planet, normalizedX, normalizedY, power);
        }
        // Removed calculateTrajectory function as per user request.
        // function calculateTrajectory(planet, dirX, dirY, power) { ... }

        function handleMouseDown(e) {
            // Allow interaction even if planets are moving from previous turn,
            // but prevent new drag if already dragging.
            if (isGameOver || gameRunningState !== "play" || isDragging) return;

            // Only process mouse down if it's within the canvas bounds to select a planet
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX;
            const mouseY = e.clientY;

            if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
                // Click was outside canvas, ignore for initial planet selection
                return;
            }

            const mousePos = getMousePos(e);
            const currentPlayer = currentGameState.currentTurn;

            // Find a selectable planet for the current player
            for (const planet of currentGameState.planets) {
                // Only allow selecting planets that belong to the current player and are not out of bounds
                if (planet.owner === currentPlayer && !planet.out && Math.hypot(mousePos.x - planet.x, mousePos.y - planet.y) <= planet.size) {
                    selectedPlanet = planet;
                    selectedPlanet.selected = true;
                    isDragging = true;
                    dragJustStarted = true;
                    startDragPos = { x: mousePos.x, y: mousePos.y };
                    if (currentGameState.ui && currentGameState.ui.powerBarContainer) currentGameState.ui.powerBarContainer.style.display = 'block';
                    powerAmount = 0;
                    if (currentGameState.ui && currentGameState.ui.powerBarFill && currentGameState.ui.powerBarText) {
                        updatePowerBar(currentGameState.ui.powerBarFill, currentGameState.ui.powerBarText, powerAmount);
                    }
                    canvas.style.cursor = 'grabbing';
                    break; // Found a planet, stop searching
                }
            }
        }
        function handleMouseMove(e) {
            window.lastMouseEvent = e;
            // Only respond to mouse move if currently dragging
            if (!isDragging || !selectedPlanet || isGameOver || gameRunningState !== "play") return;

            const mousePos = getMousePos(e);
            const dragDistance = Math.hypot(mousePos.x - selectedPlanet.x, mousePos.y - selectedPlanet.y);
            const maxDragDistance = 220;
            powerAmount = Math.min(1, dragDistance / maxDragDistance);
            if (currentGameState.ui && currentGameState.ui.powerBarFill && currentGameState.ui.powerBarText) {
                updatePowerBar(currentGameState.ui.powerBarFill, currentGameState.ui.powerBarText, powerAmount);
            }
            // Removed trajectory preview update during drag as per user request.
        }
        function handleMouseUp(e) {
            // Only respond to mouse up if currently dragging
            if (!isDragging || !selectedPlanet || isGameOver || gameRunningState !== "play") return;

            const mousePos = getMousePos(e);
            const dirX = selectedPlanet.x - mousePos.x;
            const dirY = selectedPlanet.y - mousePos.y;
            const dist = Math.hypot(dirX, dirY);

            if (dist > 10 && powerAmount > 0.05) { // A valid shot was made
                const normalizedX = dirX / dist;
                const normalizedY = dirY / dist;
                shootPlanet(selectedPlanet, normalizedX, normalizedY, powerAmount);
                
                // Store active shot planet for culling mode (if active)
                if (currentGameState.gameMode.name === GAME_MODES.CULLING) {
                    currentGameState.shotPlanet = selectedPlanet;
                    currentGameState.shotActive = true; // Mark a culling shot as active
                    currentGameState.physicsSettledForRoundEnd = false; // Reset for this shot
                }

                // Immediately switch turn after a valid shot, as per user's request
                switchTurn();

            } else { // Invalid shot (too short drag or low power)
                // No shot fired, no turn change
                if (selectedPlanet) selectedPlanet.selected = false;
            }
            
            // Reset dragging state regardless of shot validity
            isDragging = false;
            trajectoryPoints = []; // Ensure trajectory points are cleared
            canvas.style.cursor = 'default';
            if (currentGameState.ui && currentGameState.ui.powerBarContainer) {
                currentGameState.ui.powerBarContainer.style.display = 'none';
            }
            // Reset selected planet visual state
            if (selectedPlanet) {
                selectedPlanet.selected = false;
                selectedPlanet = null;
            }
            powerAmount = 0; // Reset power display
        }
        function handleKeyDown(e) {
            if (isGameOver && (e.key === 'r' || e.key === 'R')) { restartGame(); return; }
            if (gameRunningState !== "play" || !currentGameState || !isDragging || !selectedPlanet) return; // Only apply if currently dragging a planet
            
            if (e.code === 'Space') {
                e.preventDefault(); // Prevent scrolling if spacebar is pressed
                powerAmount = 1; // Set power to max
                if (currentGameState.ui && currentGameState.ui.powerBarFill && currentGameState.ui.powerBarText) {
                    updatePowerBar(currentGameState.ui.powerBarFill, currentGameState.ui.powerBarText, powerAmount);
                }
                // Removed recalculation of trajectory with max power as trajectory is removed.
            }
        }

        /**
         * Switches the current player's turn and updates UI.
         */
        function switchTurn() {
            if (!currentGameState) return;

            // Increment shots taken for the current player
            if (currentGameState.currentTurn === 'P1') {
                currentGameState.p1ShotsTaken++;
            } else {
                currentGameState.p2ShotsTaken++;
            }

            // Check if round ends (both players took max shots)
            // This check is now primarily for *triggering* the endRound logic, which waits for physics.
            // The actual endRound call is moved to updateGame after physics settle.
            // If it's the 6th shot (P2's last shot), we need to wait for physics to settle before ending the round.
            if (currentGameState.gameMode.name === GAME_MODES.CULLING &&
                currentGameState.p1ShotsTaken === currentGameState.maxShotsPerPlayerPerRound &&
                currentGameState.p2ShotsTaken === currentGameState.maxShotsPerPlayerPerRound) {
                
                // Do not call endRound() immediately here.
                // It will be called in updateGame once physics settle.
                // Just ensure the physicsSettledForRoundEnd flag is correctly set.
                currentGameState.physicsSettledForRoundEnd = false; // Ensure it's false to trigger waiting in updateGame
            } else {
                // If not the end of the round, physics are considered settled for turn transition
                // (as the next player can immediately shoot if previous planets are still moving)
                currentGameState.physicsSettledForRoundEnd = true; 
            }


            currentGameState.currentTurn = currentGameState.currentTurn === 'P1' ? 'P2' : 'P1';
            
            if (currentGameState.ui && currentGameState.ui.turnIndicator) {
                currentGameState.ui.turnIndicator.textContent = `${currentGameState.currentTurn}의 턴`;
            } else {
                console.warn("Turn indicator UI element not found in switchTurn");
            }

            // Reset selected planet and power for the new turn
            // These are also handled in handleMouseUp, but good to ensure here.
            if (selectedPlanet) {
                selectedPlanet.selected = false;
                selectedPlanet = null;
            }
            powerAmount = 0;
            if (currentGameState.ui && currentGameState.ui.powerBarContainer) {
                currentGameState.ui.powerBarContainer.style.display = 'none';
            }

            // Show a brief message for the new turn
            if (currentGameState.ui && currentGameState.ui.gameMessages) {
                currentGameState.ui.gameMessages.textContent = `${currentGameState.currentTurn}의 턴입니다!`;
                currentGameState.ui.gameMessages.style.display = 'block';
                setTimeout(() => {
                    if(currentGameState && currentGameState.ui && currentGameState.ui.gameMessages && currentGameState.ui.gameMessages.textContent.includes("턴입니다")) // Only clear if it's the turn message
                        currentGameState.ui.gameMessages.style.display = 'none';
                }, 1500); // Show message for 1.5 seconds
            }

            // After turn switch, update alive counts / scores to reflect new state
            if (currentGameState.gameMode) {
                currentGameState.gameMode.updatePlanetCounts(currentGameState.planets);
            }
        }

        /**
         * Calculates scores for the current round and prepares for the next round.
         * Only called in Culling Mode.
         */
        function endRound() {
            if (!currentGameState || currentGameState.gameMode.name !== GAME_MODES.CULLING) return;

            // Ensure cullingCircle is defined before accessing its properties
            const cullingCircle = currentGameState.map?.cullingCircle;
            if (!cullingCircle) {
                console.error("🚨 컬링 원 데이터가 정의되지 않았습니다.");
                return;
            }

            console.log(`🥌 라운드 ${currentGameState.currentRound} 종료 - 점수 계산 시작`);
            
            let roundScoreP1 = 0;
            let roundScoreP2 = 0;

            // 1. 컬링 원 안에 있는 모든 행성 찾기
            const eligiblePlanets = currentGameState.planets.filter(p => 
                (p.owner === 'P1' || p.owner === 'P2') && 
                !p.out && // 활성 행성만
                Math.hypot(p.x - cullingCircle.centerX, p.y - cullingCircle.centerY) <= cullingCircle.radius
            ).map(p => ({
                planet: p,
                distance: Math.hypot(p.x - cullingCircle.centerX, p.y - cullingCircle.centerY)
            }));

            console.log(`🎯 점수 구역 내 행성 수: ${eligiblePlanets.length}`);

            if (eligiblePlanets.length === 0) {
                console.log('🚫 점수 구역에 행성이 없음');
                displayRoundScore(0, 0, currentGameState.currentRound);
                proceedToNextRound();
                return;
            }

            // 2. 거리별로 정렬 (가까운 순)
            eligiblePlanets.sort((a, b) => a.distance - b.distance);
            
            // 3. 개선된 점수 계산 시스템
            eligiblePlanets.forEach((item, index) => {
                const planet = item.planet;
                const distance = item.distance;
                const radius = cullingCircle.radius;
                
                // 거리 기반 점수 계산 (중심에 가까울수록 높은 점수)
                let score = 0;
                const distanceRatio = distance / radius;
                
                if (distanceRatio <= 0.1) {
                    score = 10; // 불즈 아이 (중심 10% 내)
                } else if (distanceRatio <= 0.3) {
                    score = 7; // 내부 원 (30% 내)
                } else if (distanceRatio <= 0.5) {
                    score = 5; // 중간 원 (50% 내)
                } else if (distanceRatio <= 0.7) {
                    score = 3; // 외부 원 (70% 내)
                } else {
                    score = 1; // 가장 바깥 원 (100% 내)
                }
                
                // 컬링 룰: 가장 가까운 행성의 소유자만 점수를 얻음
                // 그 뒤의 행성들은 상대방 행성이 더 가까이 있으면 점수 없음
                const closestPlanet = eligiblePlanets[0].planet;
                const scoringPlayer = closestPlanet.owner;
                
                // 현재 행성이 점수를 받을 자격이 있는지 확인
                if (planet.owner === scoringPlayer) {
                    // 이 행성보다 가까운 상대방 행성이 있는지 확인
                    let hasCloserOpponent = false;
                    for (let i = 0; i < index; i++) {
                        if (eligiblePlanets[i].planet.owner !== scoringPlayer) {
                            hasCloserOpponent = true;
                            break;
                        }
                    }
                    
                    if (!hasCloserOpponent) {
                        if (scoringPlayer === 'P1') {
                            roundScoreP1 += score;
                        } else {
                            roundScoreP2 += score;
                        }
                        
                        console.log(`💎 ${planet.data.name} (${scoringPlayer}): ${score}점 (거리: ${distance.toFixed(1)})`);
                    }
                }
            });

            // 4. 총점에 라운드 점수 추가
            currentGameState.p1Score += roundScoreP1;
            currentGameState.p2Score += roundScoreP2;

            console.log(`🏆 라운드 점수 - P1: ${roundScoreP1}, P2: ${roundScoreP2}`);
            console.log(`🏆 총 점수 - P1: ${currentGameState.p1Score.toFixed(1)}, P2: ${currentGameState.p2Score.toFixed(1)}`);

            // 5. 점수 표시
            displayRoundScore(roundScoreP1, roundScoreP2, currentGameState.currentRound);
            
            // 6. 다음 라운드로 진행
            setTimeout(() => {
                proceedToNextRound();
            }, 3000); // 3초 후 다음 라운드
        }

        function displayRoundScore(p1Score, p2Score, round) {
            if (currentGameState.ui && currentGameState.ui.gameMessages) {
                const winner = p1Score > p2Score ? 'P1' : (p2Score > p1Score ? 'P2' : '무승부');
                let message = `🥌 라운드 ${round} 결과\n`;
                message += `P1: ${p1Score.toFixed(1)}점 | P2: ${p2Score.toFixed(1)}점\n`;
                message += `총점 - P1: ${currentGameState.p1Score.toFixed(1)} | P2: ${currentGameState.p2Score.toFixed(1)}\n`;
                if (winner !== '무승부') {
                    message += `🏆 라운드 승자: ${winner}`;
                } else {
                    message += `🤝 라운드 무승부`;
                }
                
                currentGameState.ui.gameMessages.innerHTML = message.replace(/\n/g, '<br>');
                currentGameState.ui.gameMessages.style.display = 'block';
                currentGameState.ui.gameMessages.style.background = 'rgba(0, 0, 0, 0.8)';
                currentGameState.ui.gameMessages.style.padding = '15px';
                currentGameState.ui.gameMessages.style.borderRadius = '10px';
                currentGameState.ui.gameMessages.style.border = '2px solid var(--accent-color)';
            }
        }

        function proceedToNextRound() {
            // 발사 횟수 초기화
            currentGameState.p1ShotsTaken = 0;
            currentGameState.p2ShotsTaken = 0;
            currentGameState.shotActive = false;
            currentGameState.shotPlanet = null;

            // 게임 종료 체크
            if (currentGameState.currentRound >= currentGameState.maxRounds) {
                let finalWinner;
                if (currentGameState.p1Score > currentGameState.p2Score) {
                    finalWinner = 'P1';
                } else if (currentGameState.p2Score > currentGameState.p1Score) {
                    finalWinner = 'P2';
                } else {
                    finalWinner = '무승부';
                }
                
                console.log(`🏁 게임 종료 - 최종 승자: ${finalWinner}`);
                endGame(finalWinner);
                return;
            }

            // 다음 라운드로
            currentGameState.currentRound++;
            console.log(`🔄 라운드 ${currentGameState.currentRound} 시작`);

            // 행성 위치 초기화
            currentGameState.planets.forEach(planet => {
                if (planet.owner === 'P1' || planet.owner === 'P2') {
                    planet.x = planet.initialX;
                    planet.y = planet.initialY;
                    planet.vx = 0;
                    planet.vy = 0;
                    planet.out = false;
                    planet.trails = [];
                    planet.particles = [];
                }
            });

            // UI 업데이트
            currentGameState.gameMode.updatePlanetCounts(currentGameState.planets);
            
            // 메시지 숨기기
            setTimeout(() => {
                if (currentGameState && currentGameState.ui && currentGameState.ui.gameMessages) {
                    currentGameState.ui.gameMessages.style.display = 'none';
                }
            }, 2000);
        }

        function finishQuiz() {
            learningProgress.quizzesTaken++;
            const percentage = Math.round((currentQuiz.score / currentQuiz.questions.length) * 100);
            
            document.getElementById('quizContent').innerHTML = `
                <div style="text-align: center; padding: 20px;">
                    <h3 style="color: var(--accent-color); margin-bottom: 20px;">🏆 퀴즈 완료!</h3>
                    <div style="font-size: 2em; margin: 20px 0; color: ${percentage >= 80 ? '#4caf50' : percentage >= 60 ? '#ff9800' : '#f44336'};">
                        ${currentQuiz.score} / ${currentQuiz.questions.length}
                    </div>
                    <p style="font-size: 1.2em; margin-bottom: 20px;">정답률: ${percentage}%</p>
                    <div style="margin-top: 20px;">
                        <button class="button" onclick="startQuiz()" style="margin: 5px;">
                            <i class="fas fa-redo"></i> 다시 도전
                        </button>
                        <button class="button secondary" onclick="document.getElementById('quizModal').style.display='none'" style="margin: 5px;">
                            <i class="fas fa-times"></i> 닫기
                        </button>
                    </div>
                </div>
            `;
        }

        function updateQuizScore() {
            document.getElementById('currentScore').textContent = currentQuiz.score;
            document.getElementById('totalQuestions').textContent = currentQuiz.questions.length;
        }

        function toggleDebugMode() {
            debugMode = !debugMode;
            const debugPanel = document.getElementById('debugPanel');
            const debugBtn = document.getElementById('debugModeBtn');
            
            if (debugMode) {
                console.log('🔧 디버그 모드 활성화');
                if (debugPanel) debugPanel.style.display = 'block';
                if (debugBtn) debugBtn.textContent = '🔧 디버그 끄기';
                if (currentGameState) updateDebugInfo();
            } else {
                console.log('🔧 디버그 모드 비활성화');
                if (debugPanel) debugPanel.style.display = 'none';
                if (debugBtn) debugBtn.textContent = '🔧 디버그 켜기';
            }
        }

        function updateDebugInfo() {
            if (!debugMode || !currentGameState) return;
            
            const debugDiv = document.getElementById('debugInfo');
            if (!debugDiv) return;
            
            const playerPlanets = currentGameState.planets.filter(p => p.owner === 'P1' || p.owner === 'P2');
            const activePlanets = playerPlanets.filter(p => !p.out);
            const movingPlanets = activePlanets.filter(p => Math.hypot(p.vx, p.vy) > 0.1);
            const p1Planets = currentGameState.planets.filter(p => p.owner === 'P1' && !p.out);
            const p2Planets = currentGameState.planets.filter(p => p.owner === 'P2' && !p.out);
            
            let debugInfo = `
                <div style="color: #00ff88; font-weight: bold;">🔧 디버그 정보</div>
                <div>━━━━━━━━━━━━━━━━━━━━━</div>
                <div>🌍 활성 행성: ${activePlanets.length} (P1: ${p1Planets.length}, P2: ${p2Planets.length})</div>
                <div>🚀 움직이는 행성: ${movingPlanets.length}</div>
                <div>🎮 현재 턴: ${currentGameState.currentTurn}</div>
                <div>⚙️ 게임 모드: ${currentGameState.gameMode.name === 'culling' ? '🥌 컬링' : '🎯 알까기'}</div>
                <div>📊 게임 상태: ${gameRunningState}</div>
            `;
            
            if (currentGameState.gameMode.name === 'culling') {
                const cullingCircle = currentGameState.map?.cullingCircle;
                debugInfo += `
                    <div>━━━━━━━━━━━━━━━━━━━━━</div>
                    <div style="color: #ffaa00;">🥌 컬링 모드 정보</div>
                    <div>📈 라운드: ${currentGameState.currentRound}/${currentGameState.maxRounds}</div>
                    <div>🏆 P1 점수: ${currentGameState.p1Score.toFixed(1)}</div>
                    <div>🏆 P2 점수: ${currentGameState.p2Score.toFixed(1)}</div>
                    <div>🎯 P1 발사 횟수: ${currentGameState.p1ShotsTaken || 0}</div>
                    <div>🎯 P2 발사 횟수: ${currentGameState.p2ShotsTaken || 0}</div>
                    <div>🔄 발사 활성: ${currentGameState.shotActive ? '예' : '아니오'}</div>
                `;
                
                if (cullingCircle) {
                    debugInfo += `
                        <div>🎯 컬링 원 중심: (${cullingCircle.centerX}, ${cullingCircle.centerY})</div>
                        <div>📏 컬링 원 반지름: ${cullingCircle.radius}</div>
                    `;
                }
            }
            
            if (selectedPlanet) {
                const velocity = Math.hypot(selectedPlanet.vx, selectedPlanet.vy);
                debugInfo += `
                    <div>━━━━━━━━━━━━━━━━━━━━━</div>
                    <div style="color: #ffff00;">🌟 선택된 행성</div>
                    <div>📛 이름: ${selectedPlanet.data.name}</div>
                    <div>👤 소유자: ${selectedPlanet.owner}</div>
                    <div>📍 위치: (${selectedPlanet.x.toFixed(1)}, ${selectedPlanet.y.toFixed(1)})</div>
                    <div>⚡ 속도: ${velocity.toFixed(2)}</div>
                    <div>⚖️ 질량: ${selectedPlanet.mass.toFixed(2)}</div>
                    <div>📏 크기: ${selectedPlanet.size}</div>
                    <div>🎯 맵 밖: ${selectedPlanet.out ? '예' : '아니오'}</div>
                `;
            }
            
            // 성능 정보 추가
            const fps = lastTime ? Math.round(1000 / (performance.now() - lastTime)) : 0;
            debugInfo += `
                <div>━━━━━━━━━━━━━━━━━━━━━</div>
                <div style="color: #88ff88;">🔧 성능 정보</div>
                <div>📊 FPS: ${fps}</div>
                <div>🖥️ 캔버스: ${canvas?.width || 0}x${canvas?.height || 0}</div>
                <div>🌌 맵 크기: ${currentGameState.map?.width || 0}x${currentGameState.map?.height || 0}</div>
            `;
            
            debugDiv.innerHTML = debugInfo;
        }
    </script>
</body>
</html>
